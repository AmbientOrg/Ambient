# [doc = r" Auto-generated component definitions. These come from `ambient.toml` in the root of the project."] pub mod components {# [doc = "**Core**: Contains all core components for the Ambient Runtime."] pub mod core {# [doc = "**App**: High-level state relevant to the application (including the in-development Editor)."] pub mod app {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("app" , {# [doc = "**Cursor position**: Absolute mouse cursor position in screen-space.\n\n*Attributes*: Debuggable, Networked"] @ [Debuggable , Networked , Name ["cursor_position"] , Description ["Absolute mouse cursor position in screen-space."]] cursor_position : Vec2 , # [doc = "**Delta Time**: How long the previous tick took in seconds.\n\nAlso known as frametime.\n\n*Attributes*: Debuggable, Resource"] @ [Debuggable , Resource , Name ["dtime"] , Description ["How long the previous tick took in seconds.\nAlso known as frametime."]] dtime : f32 , # [doc = "**Element**: The identifier of the `Element` that controls this entity.\n\nThis is automatically generated by `ElementTree`.\n\n*Attributes*: Debuggable, Networked"] @ [Debuggable , Networked , Name ["element"] , Description ["The identifier of the `Element` that controls this entity.\nThis is automatically generated by `ElementTree`."]] element : String , # [doc = "**Element unmanaged children**: If this is set, the user is expected to manage the children of the `Element` themselves.\n\n*Attributes*: Debuggable, Networked"] @ [Debuggable , Networked , Name ["element_unmanaged_children"] , Description ["If this is set, the user is expected to manage the children of the `Element` themselves."]] element_unmanaged_children : () , # [doc = "**Main scene**: If attached, this entity belongs to the main scene.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["main_scene"] , Description ["If attached, this entity belongs to the main scene."]] main_scene : () , # [doc = "**Map seed**: A random number seed for this map.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["map_seed"] , Description ["A random number seed for this map."]] map_seed : u64 , # [doc = "**Name**: A human-friendly name for this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["name"] , Description ["A human-friendly name for this entity."]] name : String , # [doc = "**Project Name**: The name of the project, from the manifest.\n\nDefaults to \"Ambient\".\n\n*Attributes*: Debuggable, Resource"] @ [Debuggable , Resource , Name ["project_name"] , Description ["The name of the project, from the manifest.\nDefaults to \"Ambient\"."]] project_name : String , # [doc = "**Selectable**: If attached, this object can be selected in the editor.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["selectable"] , Description ["If attached, this object can be selected in the editor."]] selectable : () , # [doc = "**Snap to ground**: This object should automatically be moved with the terrain if the terrain is changed.\n\nThe value is the offset from the terrain.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["snap_to_ground"] , Description ["This object should automatically be moved with the terrain if the terrain is changed.\nThe value is the offset from the terrain."]] snap_to_ground : f32 , # [doc = "**Tags**: Tags for categorizing this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["tags"] , Description ["Tags for categorizing this entity."]] tags : Vec < String > , # [doc = "**UI scene**: If attached, this entity belongs to the UI scene.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["ui_scene"] , Description ["If attached, this entity belongs to the UI scene."]] ui_scene : () , # [doc = "**Window logical size**: The logical size is the physical size divided by the scale factor.\n\n*Attributes*: Debuggable, Networked"] @ [Debuggable , Networked , Name ["window_logical_size"] , Description ["The logical size is the physical size divided by the scale factor."]] window_logical_size : UVec2 , # [doc = "**Window physical size**: The physical size is the actual number of pixels on the screen.\n\n*Attributes*: Debuggable, Networked"] @ [Debuggable , Networked , Name ["window_physical_size"] , Description ["The physical size is the actual number of pixels on the screen."]] window_physical_size : UVec2 , # [doc = "**Window scale factor**: The DPI/pixel scale factor of the window.\n\nOn standard displays, this is 1, but it can be higher on high-DPI displays like Apple Retina displays.\n\n*Attributes*: Debuggable, Networked"] @ [Debuggable , Networked , Name ["window_scale_factor"] , Description ["The DPI/pixel scale factor of the window.\nOn standard displays, this is 1, but it can be higher on high-DPI displays like Apple Retina displays."]] window_scale_factor : f64 ,}) ;} # [doc = "**Camera**: Camera matrices, types, parameters, and more."] pub mod camera {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("camera" , {# [doc = "**Active camera**: The camera with the highest `active_camera` value will be used for rendering. Cameras are also filtered by the `user_id`.\n\nIf there's no `user_id`, the camera is considered global and potentially applies to all users (if its `active_camera` value is high enough).\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["active_camera"] , Description ["The camera with the highest `active_camera` value will be used for rendering. Cameras are also filtered by the `user_id`.\nIf there's no `user_id`, the camera is considered global and potentially applies to all users (if its `active_camera` value is high enough)."]] active_camera : f32 , # [doc = "**Aspect ratio**: The aspect ratio of this camera.\n\nIf `aspect_ratio_from_window` is set, this will be automatically updated to match the window.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["aspect_ratio"] , Description ["The aspect ratio of this camera.\nIf `aspect_ratio_from_window` is set, this will be automatically updated to match the window."]] aspect_ratio : f32 , # [doc = "**Aspect ratio from window**: If attached, the `aspect_ratio` component will be automatically updated to match the aspect ratio of the window. Should point to an entity with a `window_physical_size` component.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["aspect_ratio_from_window"] , Description ["If attached, the `aspect_ratio` component will be automatically updated to match the aspect ratio of the window. Should point to an entity with a `window_physical_size` component."]] aspect_ratio_from_window : EntityId , # [doc = "**Far plane**: The far plane of this camera, measured in meters.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["far"] , Description ["The far plane of this camera, measured in meters."]] far : f32 , # [doc = "**Fog**: If attached, this camera will see/render fog.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["fog"] , Description ["If attached, this camera will see/render fog."]] fog : () , # [doc = "**Field of View Y**: The field of view of this camera in the Y/vertical direction, measured in radians.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["fovy"] , Description ["The field of view of this camera in the Y/vertical direction, measured in radians."]] fovy : f32 , # [doc = "**Near plane**: The near plane of this camera, measured in meters.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["near"] , Description ["The near plane of this camera, measured in meters."]] near : f32 , # [doc = "**Orthographic projection**: If attached, this camera will use a standard orthographic projection matrix.\n\nEnsure that the `orthographic_` components are set, including `left`, right`, `top` and `bottom`, as well as `near` and `far`.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["orthographic"] , Description ["If attached, this camera will use a standard orthographic projection matrix.\nEnsure that the `orthographic_` components are set, including `left`, right`, `top` and `bottom`, as well as `near` and `far`."]] orthographic : () , # [doc = "**Orthographic bottom**: The bottom bound for this `orthographic` camera.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["orthographic_bottom"] , Description ["The bottom bound for this `orthographic` camera."]] orthographic_bottom : f32 , # [doc = "**Orthographic from window**: The bounds of this orthographic camera will be updated to match the window automatically. Should point to an entity with a `window_logical_size` component.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["orthographic_from_window"] , Description ["The bounds of this orthographic camera will be updated to match the window automatically. Should point to an entity with a `window_logical_size` component."]] orthographic_from_window : EntityId , # [doc = "**Orthographic left**: The left bound for this `orthographic` camera.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["orthographic_left"] , Description ["The left bound for this `orthographic` camera."]] orthographic_left : f32 , # [doc = "**Orthographic right**: The right bound for this `orthographic` camera.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["orthographic_right"] , Description ["The right bound for this `orthographic` camera."]] orthographic_right : f32 , # [doc = "**Orthographic top**: The top bound for this `orthographic` camera.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["orthographic_top"] , Description ["The top bound for this `orthographic` camera."]] orthographic_top : f32 , # [doc = "**Perspective projection**: If attached, this camera will use a standard perspective projection matrix.\n\nEnsure that `near` and `far` are set.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["perspective"] , Description ["If attached, this camera will use a standard perspective projection matrix.\nEnsure that `near` and `far` are set."]] perspective : () , # [doc = "**Perspective-infinite-reverse projection**: If attached, this camera will use a perspective-infinite-reverse projection matrix.\n\nThis is well-suited for rendering large worlds as it has no far plane. Ensure `near` is set.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["perspective_infinite_reverse"] , Description ["If attached, this camera will use a perspective-infinite-reverse projection matrix.\nThis is well-suited for rendering large worlds as it has no far plane. Ensure `near` is set."]] perspective_infinite_reverse : () , # [doc = "**Projection**: The projection matrix of this camera.\n\nThis can be driven by other components, including `perspective` and `perspective_infinite_reverse`.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["projection"] , Description ["The projection matrix of this camera.\nThis can be driven by other components, including `perspective` and `perspective_infinite_reverse`."]] projection : Mat4 , # [doc = "**Projection-view**: The composition of the projection and view (inverse-local-to-world) matrices.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["projection_view"] , Description ["The composition of the projection and view (inverse-local-to-world) matrices."]] projection_view : Mat4 , # [doc = "**Shadows far plane**: The far plane for the shadow camera, measured in meters.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["shadows_far"] , Description ["The far plane for the shadow camera, measured in meters."]] shadows_far : f32 ,}) ;} # [doc = "**Entity Component System**: Core components for the ECS and entities."] pub mod ecs {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("ecs" , {# [doc = "**Children**: The children of this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["children"] , Description ["The children of this entity."]] children : Vec < EntityId > , # [doc = "**Don't automatically despawn on module unload**: Indicates that this entity shouldn't be despawned when the module that spawned it unloads.\n\n*Attributes*: Debuggable, Store"] @ [Debuggable , Store , Name ["dont_despawn_on_unload"] , Description ["Indicates that this entity shouldn't be despawned when the module that spawned it unloads."]] dont_despawn_on_unload : () , # [doc = "**Don't store**: Indicates that this entity shouldn't be stored on disk.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["dont_store"] , Description ["Indicates that this entity shouldn't be stored on disk."]] dont_store : () , # [doc = "**ID**: The ID of the entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["id"] , Description ["The ID of the entity."]] id : EntityId , # [doc = "**IDs**: A generic list of entity IDs, with no semantic meaning.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["ids"] , Description ["A generic list of entity IDs, with no semantic meaning."]] ids : Vec < EntityId > , # [doc = "**Parent**: The parent of this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["parent"] , Description ["The parent of this entity."]] parent : EntityId ,}) ;} # [doc = "**Game Objects**: Pre-defined game objects that implement specific behaviours."] pub mod game_objects {} # [doc = "**Input**: Mouse, keyboard and controller input."] pub mod input {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("input" , {# [doc = "**Event focus change**: The window was focused or list its focus.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["event_focus_change"] , Description ["The window was focused or list its focus."]] event_focus_change : bool , # [doc = "**Event keyboard input**: A keyboard key was pressed (true) or released (false). Will also contain a `keycode` component.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["event_keyboard_input"] , Description ["A keyboard key was pressed (true) or released (false). Will also contain a `keycode` component."]] event_keyboard_input : bool , # [doc = "**Event mouse input**: A mouse button was pressed (true) or released (false). Will also contain a `mouse_button` component.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["event_mouse_input"] , Description ["A mouse button was pressed (true) or released (false). Will also contain a `mouse_button` component."]] event_mouse_input : bool , # [doc = "**Event mouse motion**: The mouse was moved. The value represents the delta.\n\nUse `mouse_position` or `current_position` from `RawInput` to get the current position.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["event_mouse_motion"] , Description ["The mouse was moved. The value represents the delta.\nUse `mouse_position` or `current_position` from `RawInput` to get the current position."]] event_mouse_motion : Vec2 , # [doc = "**Event mouse wheel**: The mouse wheel moved. The value represents the delta.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["event_mouse_wheel"] , Description ["The mouse wheel moved. The value represents the delta."]] event_mouse_wheel : Vec2 , # [doc = "**Event mouse wheel**: If true, the `mouse_wheel_event`'s value should be interpreted as pixels. If false, it should be interpreted as lines.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["event_mouse_wheel_pixels"] , Description ["If true, the `mouse_wheel_event`'s value should be interpreted as pixels. If false, it should be interpreted as lines."]] event_mouse_wheel_pixels : bool , # [doc = "**Event received character**: The window received a character.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["event_received_character"] , Description ["The window received a character."]] event_received_character : String , # [doc = "**Keyboard modifiers**: Modifiers active.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["keyboard_modifiers"] , Description ["Modifiers active."]] keyboard_modifiers : u32 , # [doc = "**Keycode**: Keycode when a keyboard key was pressed.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["keycode"] , Description ["Keycode when a keyboard key was pressed."]] keycode : String , # [doc = "**Mouse button**: The mouse button. 0=left, 1=right, 2=middle.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["mouse_button"] , Description ["The mouse button. 0=left, 1=right, 2=middle."]] mouse_button : u32 , # [doc = "**Mouse over**: The number of mouse cursors that are currently over this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["mouse_over"] , Description ["The number of mouse cursors that are currently over this entity."]] mouse_over : u32 , # [doc = "**Mouse pickable max**: This entity can be clicked by the mouse, and this component defines the max AABB bound of the click area.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["mouse_pickable_max"] , Description ["This entity can be clicked by the mouse, and this component defines the max AABB bound of the click area."]] mouse_pickable_max : Vec3 , # [doc = "**Mouse pickable min**: This entity can be clicked by the mouse, and this component defines the min AABB bound of the click area.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["mouse_pickable_min"] , Description ["This entity can be clicked by the mouse, and this component defines the min AABB bound of the click area."]] mouse_pickable_min : Vec3 ,}) ;} # [doc = "**Layout**: Layout components such as flow, margins etc."] pub mod layout {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("layout" , {# [doc = "**Align horizontal begin**: Layout alignment: horizontal begin.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["align_horizontal_begin"] , Description ["Layout alignment: horizontal begin."]] align_horizontal_begin : () , # [doc = "**Align horizontal center**: Layout alignment: horizontal center.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["align_horizontal_center"] , Description ["Layout alignment: horizontal center."]] align_horizontal_center : () , # [doc = "**Align horizontal end**: Layout alignment: horizontal end.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["align_horizontal_end"] , Description ["Layout alignment: horizontal end."]] align_horizontal_end : () , # [doc = "**Align vertical begin**: Layout alignment: vertical begin.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["align_vertical_begin"] , Description ["Layout alignment: vertical begin."]] align_vertical_begin : () , # [doc = "**Align vertical center**: Layout alignment: vertical center.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["align_vertical_center"] , Description ["Layout alignment: vertical center."]] align_vertical_center : () , # [doc = "**Align vertical end**: Layout alignment: vertical end.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["align_vertical_end"] , Description ["Layout alignment: vertical end."]] align_vertical_end : () , # [doc = "**Docking bottom**: Layout docking: bottom.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["docking_bottom"] , Description ["Layout docking: bottom."]] docking_bottom : () , # [doc = "**Docking fill**: Layout docking: fill.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["docking_fill"] , Description ["Layout docking: fill."]] docking_fill : () , # [doc = "**Docking left**: Layout docking: left.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["docking_left"] , Description ["Layout docking: left."]] docking_left : () , # [doc = "**Docking right**: Layout docking: right.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["docking_right"] , Description ["Layout docking: right."]] docking_right : () , # [doc = "**Docking top**: Layout docking: top.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["docking_top"] , Description ["Layout docking: top."]] docking_top : () , # [doc = "**Fit horizontal children**: Layout fit: horizontal children.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["fit_horizontal_children"] , Description ["Layout fit: horizontal children."]] fit_horizontal_children : () , # [doc = "**Fit horizontal none**: Layout fit: horizontal none.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["fit_horizontal_none"] , Description ["Layout fit: horizontal none."]] fit_horizontal_none : () , # [doc = "**Fit horizontal parent**: Layout fit: horizontal parent.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["fit_horizontal_parent"] , Description ["Layout fit: horizontal parent."]] fit_horizontal_parent : () , # [doc = "**Fit vertical children**: Layout fit: vertical children.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["fit_vertical_children"] , Description ["Layout fit: vertical children."]] fit_vertical_children : () , # [doc = "**Fit vertical none**: Layout fit: vertical none.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["fit_vertical_none"] , Description ["Layout fit: vertical none."]] fit_vertical_none : () , # [doc = "**Fit vertical parent**: Layout fit: vertical parent.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["fit_vertical_parent"] , Description ["Layout fit: vertical parent."]] fit_vertical_parent : () , # [doc = "**GPU UI size**: Upload the width and height of this UI element to the GPU.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["gpu_ui_size"] , Description ["Upload the width and height of this UI element to the GPU."]] gpu_ui_size : Vec4 , # [doc = "**Height**: The height of a UI element.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["height"] , Description ["The height of a UI element."]] height : f32 , # [doc = "**Is book file**: This is a file in a `layout_bookcase`.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["is_book_file"] , Description ["This is a file in a `layout_bookcase`."]] is_book_file : () , # [doc = "**Bookcase layout**: Min-max bookcase layout.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["layout_bookcase"] , Description ["Min-max bookcase layout."]] layout_bookcase : () , # [doc = "**Dock layout**: Top-down dock layout.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["layout_dock"] , Description ["Top-down dock layout."]] layout_dock : () , # [doc = "**Flow layout**: Bottom-up flow layout.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["layout_flow"] , Description ["Bottom-up flow layout."]] layout_flow : () , # [doc = "**Layout width to children**: Width to children.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["layout_width_to_children"] , Description ["Width to children."]] layout_width_to_children : () , # [doc = "**Margin bottom**: Layout margin: bottom.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["margin_bottom"] , Description ["Layout margin: bottom."]] margin_bottom : f32 , # [doc = "**Margin left**: Layout margin: left.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["margin_left"] , Description ["Layout margin: left."]] margin_left : f32 , # [doc = "**Margin right**: Layout margin: right.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["margin_right"] , Description ["Layout margin: right."]] margin_right : f32 , # [doc = "**Margin top**: Layout margin: top.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["margin_top"] , Description ["Layout margin: top."]] margin_top : f32 , # [doc = "**Mest to local from size**: Update the `mesh_to_local` based on the width and height of this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["mesh_to_local_from_size"] , Description ["Update the `mesh_to_local` based on the width and height of this entity."]] mesh_to_local_from_size : () , # [doc = "**Minimum height**: The minimum height of a UI element.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["min_height"] , Description ["The minimum height of a UI element."]] min_height : f32 , # [doc = "**Minimum width**: The minimum width of a UI element.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["min_width"] , Description ["The minimum width of a UI element."]] min_width : f32 , # [doc = "**Orientation horizontal**: Layout orientation: horizontal.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["orientation_horizontal"] , Description ["Layout orientation: horizontal."]] orientation_horizontal : () , # [doc = "**Orientation vertical**: Layout orientation: vertical.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["orientation_vertical"] , Description ["Layout orientation: vertical."]] orientation_vertical : () , # [doc = "**Padding bottom**: Layout padding: bottom.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["padding_bottom"] , Description ["Layout padding: bottom."]] padding_bottom : f32 , # [doc = "**Padding left**: Layout padding: left.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["padding_left"] , Description ["Layout padding: left."]] padding_left : f32 , # [doc = "**Padding right**: Layout padding: right.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["padding_right"] , Description ["Layout padding: right."]] padding_right : f32 , # [doc = "**Padding top**: Layout padding: top.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["padding_top"] , Description ["Layout padding: top."]] padding_top : f32 , # [doc = "**Screen**: This entity will be treated as a screen. Used by the Screen ui component.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["screen"] , Description ["This entity will be treated as a screen. Used by the Screen ui component."]] screen : () , # [doc = "**Space between items**: Space between items in a layout.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["space_between_items"] , Description ["Space between items in a layout."]] space_between_items : f32 , # [doc = "**Width**: The width of a UI element.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["width"] , Description ["The width of a UI element."]] width : f32 ,}) ;} # [doc = "**Model**: Information about models attached to entities."] pub mod model {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("model" , {# [doc = "**Model animatable**: Controls whether this model can be animated.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["model_animatable"] , Description ["Controls whether this model can be animated."]] model_animatable : bool , # [doc = "**Model from URL**: Load a model from the given URL or relative path.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["model_from_url"] , Description ["Load a model from the given URL or relative path."]] model_from_url : String , # [doc = "**Model loaded**: If attached, this entity has a model attached to it.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["model_loaded"] , Description ["If attached, this entity has a model attached to it."]] model_loaded : () ,}) ;} # [doc = "**Network**: Network-related state."] pub mod network {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("network" , {# [doc = "**Is remote entity**: If attached, this entity was not spawned locally (e.g. if this is the client, it was spawned by the server).\n\n*Attributes*: Debuggable, Networked"] @ [Debuggable , Networked , Name ["is_remote_entity"] , Description ["If attached, this entity was not spawned locally (e.g. if this is the client, it was spawned by the server)."]] is_remote_entity : () , # [doc = "**Persistent resources**: If attached, this entity contains global resources that are persisted to disk and synchronized to clients.\n\n*Attributes*: Debuggable, Networked"] @ [Debuggable , Networked , Name ["persistent_resources"] , Description ["If attached, this entity contains global resources that are persisted to disk and synchronized to clients."]] persistent_resources : () , # [doc = "**Synchronized resources**: If attached, this entity contains global resources that are synchronized to clients, but not persisted.\n\n*Attributes*: Debuggable, Networked"] @ [Debuggable , Networked , Name ["synced_resources"] , Description ["If attached, this entity contains global resources that are synchronized to clients, but not persisted."]] synced_resources : () ,}) ;} # [doc = "**Physics**: Physics functionality and state."] pub mod physics {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("physics" , {# [doc = "**Angular velocity**: Angular velocity (radians/second) of this entity in the physics scene.\n\nUpdating this component will update the entity's angular velocity in the physics scene.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["angular_velocity"] , Description ["Angular velocity (radians/second) of this entity in the physics scene.\nUpdating this component will update the entity's angular velocity in the physics scene."]] angular_velocity : Vec3 , # [doc = "**Box collider**: If attached, this entity will have a box physics collider.\n\n`x, y, z` is the size of the box.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["box_collider"] , Description ["If attached, this entity will have a box physics collider.\n`x, y, z` is the size of the box."]] box_collider : Vec3 , # [doc = "**Character controller height**: The height of the physics character controller attached to this entity.\n\nIf an entity has both this and a `character_controller_radius`, it will be given a physical character collider.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["character_controller_height"] , Description ["The height of the physics character controller attached to this entity.\nIf an entity has both this and a `character_controller_radius`, it will be given a physical character collider."]] character_controller_height : f32 , # [doc = "**Character controller radius**: The radius of the physics character controller attached to this entity.\n\nIf an entity has both this and a `character_controller_height`, it will be given a physical character collider.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["character_controller_radius"] , Description ["The radius of the physics character controller attached to this entity.\nIf an entity has both this and a `character_controller_height`, it will be given a physical character collider."]] character_controller_radius : f32 , # [doc = "**Collider from URL**: This entity will load its physics collider from the URL.\n\nThe value is the URL to load from.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["collider_from_url"] , Description ["This entity will load its physics collider from the URL.\nThe value is the URL to load from."]] collider_from_url : String , # [doc = "**Collider loads**: Contains all colliders that were loaded in this physics tick.\n\n*Attributes*: Debuggable, Networked, Resource, Store"] @ [Debuggable , Networked , Resource , Store , Name ["collider_loads"] , Description ["Contains all colliders that were loaded in this physics tick."]] collider_loads : Vec < EntityId > , # [doc = "**Contact offset**: Contact offset (in meters) of this entity in the physics scene.\n\nUpdating this component will update the entity's contact offset for each attached shape in the physics scene.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["contact_offset"] , Description ["Contact offset (in meters) of this entity in the physics scene.\nUpdating this component will update the entity's contact offset for each attached shape in the physics scene."]] contact_offset : f32 , # [doc = "**Density**: The density of this entity.\n\nThis is used to update the `mass` when the entity is rescaled.\n\n*Attributes*: Debuggable, Networked, Store\n\n*Suggested Default*: 1.0"] @ [Debuggable , Networked , Store , Name ["density"] , Description ["The density of this entity.\nThis is used to update the `mass` when the entity is rescaled."]] density : f32 , # [doc = "**Dynamic**: If this is true, the entity will be dynamic (i.e. be able to move). Otherwise, it will be static.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["dynamic"] , Description ["If this is true, the entity will be dynamic (i.e. be able to move). Otherwise, it will be static."]] dynamic : bool , # [doc = "**Kinematic**: If attached, and this entity is dynamic, this entity will also be kinematic (i.e. unable to be affected by other entities motion). Otherwise, it will receive forces normally.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["kinematic"] , Description ["If attached, and this entity is dynamic, this entity will also be kinematic (i.e. unable to be affected by other entities motion). Otherwise, it will receive forces normally."]] kinematic : () , # [doc = "**Linear velocity**: Linear velocity (meters/second) of this entity in the physics scene.\n\nUpdating this component will update the entity's linear velocity in the physics scene.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["linear_velocity"] , Description ["Linear velocity (meters/second) of this entity in the physics scene.\nUpdating this component will update the entity's linear velocity in the physics scene."]] linear_velocity : Vec3 , # [doc = "**Make physics static**: All physics objects will be made static when loaded.\n\n*Attributes*: Debuggable, Networked, Resource, Store"] @ [Debuggable , Networked , Resource , Store , Name ["make_physics_static"] , Description ["All physics objects will be made static when loaded."]] make_physics_static : bool , # [doc = "**Mass**: The mass of this entity, measured in kilograms.\n\n*Attributes*: Debuggable, Networked, Store\n\n*Suggested Default*: 1.0"] @ [Debuggable , Networked , Store , Name ["mass"] , Description ["The mass of this entity, measured in kilograms."]] mass : f32 , # [doc = "**Physics controlled**: If attached, this entity will be controlled by physics.\n\nNote that this requires the entity to have a collider.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["physics_controlled"] , Description ["If attached, this entity will be controlled by physics.\nNote that this requires the entity to have a collider."]] physics_controlled : () , # [doc = "**Plane collider**: If attached, this entity will have a plane physics collider.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["plane_collider"] , Description ["If attached, this entity will have a plane physics collider."]] plane_collider : () , # [doc = "**Rest offset**: Rest offset (in meters) of this entity in the physics scene.\n\nUpdating this component will update the entity's rest offset for each attached shape in the physics scene.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["rest_offset"] , Description ["Rest offset (in meters) of this entity in the physics scene.\nUpdating this component will update the entity's rest offset for each attached shape in the physics scene."]] rest_offset : f32 , # [doc = "**Sphere collider**: If attached, this entity will have a sphere physics collider.\n\nThe value corresponds to the radius of the sphere.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["sphere_collider"] , Description ["If attached, this entity will have a sphere physics collider.\nThe value corresponds to the radius of the sphere."]] sphere_collider : f32 , # [doc = "**Unit mass**: The mass of a character/unit.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["unit_mass"] , Description ["The mass of a character/unit."]] unit_mass : f32 , # [doc = "**Unit velocity**: The velocity of a character/unit.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["unit_velocity"] , Description ["The velocity of a character/unit."]] unit_velocity : Vec3 , # [doc = "**Unit yaw**: The yaw of a character/unit.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["unit_yaw"] , Description ["The yaw of a character/unit."]] unit_yaw : f32 , # [doc = "**Visualizing**: If attached, the physics state of this object will be rendered for debugging purposes.\n\n*Attributes*: Debuggable, Networked"] @ [Debuggable , Networked , Name ["visualizing"] , Description ["If attached, the physics state of this object will be rendered for debugging purposes."]] visualizing : () ,}) ;} # [doc = "**Player**: Components that are attached to player entities."] pub mod player {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("player" , {# [doc = "**Local user ID**: The user ID of the local player.\n\n*Attributes*: Debuggable, Networked, Resource, Store"] @ [Debuggable , Networked , Resource , Store , Name ["local_user_id"] , Description ["The user ID of the local player."]] local_user_id : String , # [doc = "**Player**: This entity is a player.\n\nNote that this is a logical construct; a player's body may be separate from the player itself.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["player"] , Description ["This entity is a player.\nNote that this is a logical construct; a player's body may be separate from the player itself."]] player : () , # [doc = "**User ID**: An identifier attached to all things owned by a user, and supplied by the user.\n\nThis can be attached to more than just the player; by convention, it is also attached to related entities, including their camera and body.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["user_id"] , Description ["An identifier attached to all things owned by a user, and supplied by the user.\nThis can be attached to more than just the player; by convention, it is also attached to related entities, including their camera and body."]] user_id : String ,}) ;} # [doc = "**Prefab**: Prefab-related state, including loading of prefabs."] pub mod prefab {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("prefab" , {# [doc = "**Prefab from URL**: Load and attach a prefab from a URL or relative path.\n\nWhen loaded, the components from this prefab will add to or replace the existing components for the entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["prefab_from_url"] , Description ["Load and attach a prefab from a URL or relative path.\nWhen loaded, the components from this prefab will add to or replace the existing components for the entity."]] prefab_from_url : String , # [doc = "**Spawned**: If attached, this entity was built from a prefab that has finished spawning.\n\n*Attributes*: Debuggable"] @ [Debuggable , Name ["spawned"] , Description ["If attached, this entity was built from a prefab that has finished spawning."]] spawned : () ,}) ;} # [doc = "**Primitives**: Components that create primitive (in the geometric sense) objects from their attached entities."] pub mod primitives {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("primitives" , {# [doc = "**Cube**: If attached to an entity, the entity will be converted to a cube primitive.\n\nThe cube is unit-sized (i.e. 0.5 metres out to each side).\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["cube"] , Description ["If attached to an entity, the entity will be converted to a cube primitive.\nThe cube is unit-sized (i.e. 0.5 metres out to each side)."]] cube : () , # [doc = "**Quad**: If attached to an entity, the entity will be converted to a quad primitive.\n\nThe quad is unit-sized on the XY axes, and flat on the Z axis (i.e. 0.5 metres out to the XY axes).\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["quad"] , Description ["If attached to an entity, the entity will be converted to a quad primitive.\nThe quad is unit-sized on the XY axes, and flat on the Z axis (i.e. 0.5 metres out to the XY axes)."]] quad : () , # [doc = "**Sphere**: If attached to an entity alongside the other `sphere_*` components, the entity will be converted to a sphere primitive.\n\nTo easily instantiate a unit-diameter `sphere`, consider using the `sphere` concept (e.g. `make_sphere`).\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["sphere"] , Description ["If attached to an entity alongside the other `sphere_*` components, the entity will be converted to a sphere primitive.\nTo easily instantiate a unit-diameter `sphere`, consider using the `sphere` concept (e.g. `make_sphere`)."]] sphere : () , # [doc = "**Sphere radius**: Set the radius of a `sphere` entity.\n\n*Attributes*: Debuggable, Networked, Store\n\n*Suggested Default*: 0.5"] @ [Debuggable , Networked , Store , Name ["sphere_radius"] , Description ["Set the radius of a `sphere` entity."]] sphere_radius : f32 , # [doc = "**Sphere sectors**: Set the longitudinal sectors of a `sphere` entity.\n\n*Attributes*: Debuggable, Networked, Store\n\n*Suggested Default*: 36"] @ [Debuggable , Networked , Store , Name ["sphere_sectors"] , Description ["Set the longitudinal sectors of a `sphere` entity."]] sphere_sectors : u32 , # [doc = "**Sphere stacks**: Set the latitudinal stacks of a `sphere` entity.\n\n*Attributes*: Debuggable, Networked, Store\n\n*Suggested Default*: 18"] @ [Debuggable , Networked , Store , Name ["sphere_stacks"] , Description ["Set the latitudinal stacks of a `sphere` entity."]] sphere_stacks : u32 ,}) ;} # [doc = "**Rect**: Rounded corners rectangle rendering components, with an optional border."] pub mod rect {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("rect" , {# [doc = "**Background color**: Background color of an entity with a `rect` component.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["background_color"] , Description ["Background color of an entity with a `rect` component."]] background_color : Vec4 , # [doc = "**Border color**: Border color of an entity with a `rect` component.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["border_color"] , Description ["Border color of an entity with a `rect` component."]] border_color : Vec4 , # [doc = "**Border radius**: Radius for each corner of an entity with a `rect` component.\n\n`x` = top-left, `y` = top-right, `z` = bottom-left, `w` = bottom-right.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["border_radius"] , Description ["Radius for each corner of an entity with a `rect` component.\n`x` = top-left, `y` = top-right, `z` = bottom-left, `w` = bottom-right."]] border_radius : Vec4 , # [doc = "**Border thickness**: Border thickness of an entity with a `rect` component.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["border_thickness"] , Description ["Border thickness of an entity with a `rect` component."]] border_thickness : f32 , # [doc = "**Line from**: Start point of a line.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["line_from"] , Description ["Start point of a line."]] line_from : Vec3 , # [doc = "**Line to**: End point of a line.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["line_to"] , Description ["End point of a line."]] line_to : Vec3 , # [doc = "**Line width**: Width of line.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["line_width"] , Description ["Width of line."]] line_width : f32 , # [doc = "**Rect**: If attached to an entity, the entity will be converted to a UI rectangle, with optionally rounded corners and borders.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["rect"] , Description ["If attached to an entity, the entity will be converted to a UI rectangle, with optionally rounded corners and borders."]] rect : () ,}) ;} # [doc = "**Rendering**: Rendering-related state, including global rendering parameters and per-entity state."] pub mod rendering {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("rendering" , {# [doc = "**Cast shadows**: If attached, this entity will cast shadows.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["cast_shadows"] , Description ["If attached, this entity will cast shadows."]] cast_shadows : () , # [doc = "**Color**: This entity will be tinted with the specified color if the color is not black.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["color"] , Description ["This entity will be tinted with the specified color if the color is not black."]] color : Vec4 , # [doc = "**Double-sided**: If this is set, the entity will be rendered with double-sided rendering.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["double_sided"] , Description ["If this is set, the entity will be rendered with double-sided rendering."]] double_sided : bool , # [doc = "**Fog color**: The color of the fog for this `sun`.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["fog_color"] , Description ["The color of the fog for this `sun`."]] fog_color : Vec3 , # [doc = "**Fog density**: The density of the fog for this `sun`.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["fog_density"] , Description ["The density of the fog for this `sun`."]] fog_density : f32 , # [doc = "**Fog height fall-off**: The height at which the fog will fall off (i.e. stop being visible) for this `sun`.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["fog_height_falloff"] , Description ["The height at which the fog will fall off (i.e. stop being visible) for this `sun`."]] fog_height_falloff : f32 , # [doc = "**Joint Matrices**: Contains the matrices for each joint of this skinned mesh.\n\nThis should be used in combination with `joints`.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["joint_matrices"] , Description ["Contains the matrices for each joint of this skinned mesh.\nThis should be used in combination with `joints`."]] joint_matrices : Vec < Mat4 > , # [doc = "**Joints**: Contains the joints that comprise this skinned mesh.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["joints"] , Description ["Contains the joints that comprise this skinned mesh."]] joints : Vec < EntityId > , # [doc = "**Light ambient**: The ambient light color of the `sun`.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["light_ambient"] , Description ["The ambient light color of the `sun`."]] light_ambient : Vec3 , # [doc = "**Light diffuse**: The diffuse light color of the `sun`.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["light_diffuse"] , Description ["The diffuse light color of the `sun`."]] light_diffuse : Vec3 , # [doc = "**Outline**: If attached, this entity will be rendered with an outline with the color specified.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["outline"] , Description ["If attached, this entity will be rendered with an outline with the color specified."]] outline : Vec4 , # [doc = "**Outline (recursive)**: If attached, this entity and all of its children will be rendered with an outline with the color specified.\n\nYou do not need to attach `outline` if you have attached `outline_recursive`.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["outline_recursive"] , Description ["If attached, this entity and all of its children will be rendered with an outline with the color specified.\nYou do not need to attach `outline` if you have attached `outline_recursive`."]] outline_recursive : Vec4 , # [doc = "**Overlay**: If attached, this entity will be rendered with an overlay.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["overlay"] , Description ["If attached, this entity will be rendered with an overlay."]] overlay : () , # [doc = "**PBR material from URL**: Load a PBR material from the URL and attach it to this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["pbr_material_from_url"] , Description ["Load a PBR material from the URL and attach it to this entity."]] pbr_material_from_url : String , # [doc = "**Sky**: Add a realistic skybox to the scene.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["sky"] , Description ["Add a realistic skybox to the scene."]] sky : () , # [doc = "**Sun**: Marks this entity as a sun (i.e. its rotation will be used to control the global light direction).\n\nThe entity with the highest `sun` value takes precedence.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["sun"] , Description ["Marks this entity as a sun (i.e. its rotation will be used to control the global light direction).\nThe entity with the highest `sun` value takes precedence."]] sun : f32 , # [doc = "**Transparency group**: Controls when this transparent object will be rendered. Transparent objects are sorted by `(transparency_group, z-depth)`.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["transparency_group"] , Description ["Controls when this transparent object will be rendered. Transparent objects are sorted by `(transparency_group, z-depth)`."]] transparency_group : i32 , # [doc = "**Water**: Add a realistic water plane to this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["water"] , Description ["Add a realistic water plane to this entity."]] water : () ,}) ;} # [doc = "**Text**: Text rendering."] pub mod text {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("text" , {# [doc = "**Font family**: Font family to be used. Can either be 'Default', 'FontAwesome', 'FontAwesomeSolid', 'Code' or a url to a font.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["font_family"] , Description ["Font family to be used. Can either be 'Default', 'FontAwesome', 'FontAwesomeSolid', 'Code' or a url to a font."]] font_family : String , # [doc = "**Font size**: Size of the font.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["font_size"] , Description ["Size of the font."]] font_size : f32 , # [doc = "**Font style**: One of Bold, BoldItalic, Medium, MediumItalic, Regular, Italic, Light or LightItalic.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["font_style"] , Description ["One of Bold, BoldItalic, Medium, MediumItalic, Regular, Italic, Light or LightItalic."]] font_style : String , # [doc = "**Text**: Create a text mesh on this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["text"] , Description ["Create a text mesh on this entity."]] text : String ,}) ;} # [doc = "**Transform**: Entity transform state (including translation, rotation and scale), as well as other transformations for this entity."] pub mod transform {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("transform" , {# [doc = "**Cylindrical billboard Z**: If attached, this ensures this entity is always aligned with the camera, except on the Z-axis.\n\nThis is useful for decorations that the player will be looking at from roughly the same altitude.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["cylindrical_billboard_z"] , Description ["If attached, this ensures this entity is always aligned with the camera, except on the Z-axis.\nThis is useful for decorations that the player will be looking at from roughly the same altitude."]] cylindrical_billboard_z : () , # [doc = "**Euler rotation**: The Euler rotation of this entity in ZYX order.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["euler_rotation"] , Description ["The Euler rotation of this entity in ZYX order."]] euler_rotation : Vec3 , # [doc = "**Inverse Local to World**: Converts a world position to a local position.\n\nThis is automatically updated.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["inv_local_to_world"] , Description ["Converts a world position to a local position.\nThis is automatically updated."]] inv_local_to_world : Mat4 , # [doc = "**Local to Parent**: Transformation from the entity's local space to the parent's space.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["local_to_parent"] , Description ["Transformation from the entity's local space to the parent's space."]] local_to_parent : Mat4 , # [doc = "**Local to World**: Transformation from the entity's local space to worldspace.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["local_to_world"] , Description ["Transformation from the entity's local space to worldspace."]] local_to_world : Mat4 , # [doc = "**Look-at center**: The position that this entity should be looking at.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["lookat_center"] , Description ["The position that this entity should be looking at."]] lookat_center : Vec3 , # [doc = "**Look-at up**: When combined with `lookat_center`, the up vector for this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["lookat_up"] , Description ["When combined with `lookat_center`, the up vector for this entity."]] lookat_up : Vec3 , # [doc = "**Mesh to Local**: Transformation from mesh-space to the entity's local space.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["mesh_to_local"] , Description ["Transformation from mesh-space to the entity's local space."]] mesh_to_local : Mat4 , # [doc = "**Mesh to World**: Transformation from mesh-space to world space.\n\nThis is automatically updated when `mesh_to_local` and `local_to_world` change.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["mesh_to_world"] , Description ["Transformation from mesh-space to world space.\nThis is automatically updated when `mesh_to_local` and `local_to_world` change."]] mesh_to_world : Mat4 , # [doc = "**Reset scale**: If attached to a transform hierarchy, the scale will be reset at that point, with only rotation/translation considered.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["reset_scale"] , Description ["If attached to a transform hierarchy, the scale will be reset at that point, with only rotation/translation considered."]] reset_scale : () , # [doc = "**Rotation**: The rotation of this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["rotation"] , Description ["The rotation of this entity."]] rotation : Quat , # [doc = "**Scale**: The scale of this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["scale"] , Description ["The scale of this entity."]] scale : Vec3 , # [doc = "**Spherical billboard**: If attached, this ensures that this entity is always aligned with the camera.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["spherical_billboard"] , Description ["If attached, this ensures that this entity is always aligned with the camera."]] spherical_billboard : () , # [doc = "**Translation**: The translation/position of this entity.\n\n*Attributes*: Debuggable, Networked, Store"] @ [Debuggable , Networked , Store , Name ["translation"] , Description ["The translation/position of this entity."]] translation : Vec3 ,}) ;} # [doc = "**WASM**: Internal implementation details of WASM integration."] pub mod wasm {# [doc = "**WASM messaging**: Information attached to a message sent across WASM boundaries."] pub mod message {use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Debuggable , Networked , Store , Resource , Name , Description} ; ambient_ecs :: components ! ("wasm::message" , {# [doc = "**Data**: The data payload of a message.\n\n*Attributes*: Debuggable"] @ [Debuggable , Name ["data"] , Description ["The data payload of a message."]] data : Vec < u8 > , # [doc = "**Source: Local**: This message came from the specified module on this side.\n\n*Attributes*: Debuggable"] @ [Debuggable , Name ["source_local"] , Description ["This message came from the specified module on this side."]] source_local : EntityId , # [doc = "**Source: Remote**: This message came from the network with no specific source (likely the server).\n\n*Attributes*: Debuggable"] @ [Debuggable , Name ["source_remote"] , Description ["This message came from the network with no specific source (likely the server)."]] source_remote : () , # [doc = "**Source: Remote (User ID)**: This message came from this user.\n\n*Attributes*: Debuggable"] @ [Debuggable , Name ["source_remote_user_id"] , Description ["This message came from this user."]] source_remote_user_id : String ,}) ;}}} fn init () {core :: app :: init_components () ; core :: camera :: init_components () ; core :: ecs :: init_components () ; core :: input :: init_components () ; core :: layout :: init_components () ; core :: model :: init_components () ; core :: network :: init_components () ; core :: physics :: init_components () ; core :: player :: init_components () ; core :: prefab :: init_components () ; core :: primitives :: init_components () ; core :: rect :: init_components () ; core :: rendering :: init_components () ; core :: text :: init_components () ; core :: transform :: init_components () ; core :: wasm :: message :: init_components () ;}} # [doc = r" Auto-generated concept definitions. Concepts are collections of components that describe some form of gameplay concept."] # [doc = r""] # [doc = r" They do not have any runtime representation outside of the components that compose them."] pub mod concepts {use super :: components ; use glam :: {Vec2 , Vec3 , Vec4 , UVec2 , UVec3 , UVec4 , Mat4 , Quat} ; use ambient_ecs :: {EntityId , Entity} ; # [allow (clippy :: approx_constant)] # [doc = "Makes a *Camera*.\n\nBase components for a camera. You will need other components to make a fully-functioning camera.\n\n*Definition*:\n\n```\n{\n  \"core::camera::active_camera\": f32 = 0f32,\n  \"core::camera::near\": f32 = 0.1f32,\n  \"core::camera::projection\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n  \"core::camera::projection_view\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n  \"core::transform::inv_local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n  \"core::transform::local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n  \"transformable\": { // Concept.\n    \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n    \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n    \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n  },\n}\n```\n"] pub fn make_camera () -> Entity {Entity :: new () . with_merge (make_transformable ()) . with (components :: core :: camera :: active_camera () , 0f32) . with (components :: core :: camera :: near () , 0.1f32) . with (components :: core :: camera :: projection () , Mat4 :: from_cols_array (& [1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32])) . with (components :: core :: camera :: projection_view () , Mat4 :: from_cols_array (& [1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32])) . with (components :: core :: transform :: inv_local_to_world () , Mat4 :: from_cols_array (& [1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32])) . with (components :: core :: transform :: local_to_world () , Mat4 :: from_cols_array (& [1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32 , 0f32 , 0f32 , 0f32 , 0f32 , 1f32]))} # [doc = "Checks if the entity is a *Camera*.\n\nBase components for a camera. You will need other components to make a fully-functioning camera.\n\n*Definition*:\n\n```\n{\n  \"core::camera::active_camera\": f32 = 0f32,\n  \"core::camera::near\": f32 = 0.1f32,\n  \"core::camera::projection\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n  \"core::camera::projection_view\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n  \"core::transform::inv_local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n  \"core::transform::local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n  \"transformable\": { // Concept.\n    \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n    \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n    \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n  },\n}\n```\n"] pub fn is_camera (world : & ambient_ecs :: World , id : EntityId) -> bool {is_transformable (world , id) && world . has_components (id , & {let mut set = ambient_ecs :: ComponentSet :: new () ; set . insert (components :: core :: camera :: active_camera () . desc ()) ; set . insert (components :: core :: camera :: near () . desc ()) ; set . insert (components :: core :: camera :: projection () . desc ()) ; set . insert (components :: core :: camera :: projection_view () . desc ()) ; set . insert (components :: core :: transform :: inv_local_to_world () . desc ()) ; set . insert (components :: core :: transform :: local_to_world () . desc ()) ; set})} # [allow (clippy :: approx_constant)] # [doc = "Makes a *Orthographic Camera*.\n\nAn orthographic camera.\n\n*Definition*:\n\n```\n{\n  \"core::camera::far\": f32 = 1f32,\n  \"core::camera::near\": f32 = -1f32,\n  \"core::camera::orthographic\": () = (),\n  \"core::camera::orthographic_bottom\": f32 = -1f32,\n  \"core::camera::orthographic_left\": f32 = -1f32,\n  \"core::camera::orthographic_right\": f32 = 1f32,\n  \"core::camera::orthographic_top\": f32 = 1f32,\n  \"camera\": { // Concept.\n    \"core::camera::active_camera\": f32 = 0f32,\n    \"core::camera::near\": f32 = 0.1f32,\n    \"core::camera::projection\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::camera::projection_view\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::transform::inv_local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::transform::local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"transformable\": { // Concept.\n      \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n      \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n      \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n    },\n  },\n}\n```\n"] pub fn make_orthographic_camera () -> Entity {Entity :: new () . with_merge (make_camera ()) . with (components :: core :: camera :: far () , 1f32) . with (components :: core :: camera :: near () , -1f32) . with (components :: core :: camera :: orthographic () , ()) . with (components :: core :: camera :: orthographic_bottom () , -1f32) . with (components :: core :: camera :: orthographic_left () , -1f32) . with (components :: core :: camera :: orthographic_right () , 1f32) . with (components :: core :: camera :: orthographic_top () , 1f32)} # [doc = "Checks if the entity is a *Orthographic Camera*.\n\nAn orthographic camera.\n\n*Definition*:\n\n```\n{\n  \"core::camera::far\": f32 = 1f32,\n  \"core::camera::near\": f32 = -1f32,\n  \"core::camera::orthographic\": () = (),\n  \"core::camera::orthographic_bottom\": f32 = -1f32,\n  \"core::camera::orthographic_left\": f32 = -1f32,\n  \"core::camera::orthographic_right\": f32 = 1f32,\n  \"core::camera::orthographic_top\": f32 = 1f32,\n  \"camera\": { // Concept.\n    \"core::camera::active_camera\": f32 = 0f32,\n    \"core::camera::near\": f32 = 0.1f32,\n    \"core::camera::projection\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::camera::projection_view\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::transform::inv_local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::transform::local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"transformable\": { // Concept.\n      \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n      \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n      \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n    },\n  },\n}\n```\n"] pub fn is_orthographic_camera (world : & ambient_ecs :: World , id : EntityId) -> bool {is_camera (world , id) && world . has_components (id , & {let mut set = ambient_ecs :: ComponentSet :: new () ; set . insert (components :: core :: camera :: far () . desc ()) ; set . insert (components :: core :: camera :: near () . desc ()) ; set . insert (components :: core :: camera :: orthographic () . desc ()) ; set . insert (components :: core :: camera :: orthographic_bottom () . desc ()) ; set . insert (components :: core :: camera :: orthographic_left () . desc ()) ; set . insert (components :: core :: camera :: orthographic_right () . desc ()) ; set . insert (components :: core :: camera :: orthographic_top () . desc ()) ; set})} # [allow (clippy :: approx_constant)] # [doc = "Makes a *Perspective Camera*.\n\nA perspective camera.\n\n*Definition*:\n\n```\n{\n  \"core::camera::far\": f32 = 1000f32,\n  \"core::camera::perspective\": () = (),\n  \"perspective_common_camera\": { // Concept.\n    \"core::camera::aspect_ratio\": f32 = 1f32,\n    \"core::camera::fovy\": f32 = 1f32,\n    \"camera\": { // Concept.\n      \"core::camera::active_camera\": f32 = 0f32,\n      \"core::camera::near\": f32 = 0.1f32,\n      \"core::camera::projection\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::camera::projection_view\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::transform::inv_local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::transform::local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"transformable\": { // Concept.\n        \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n        \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n        \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n      },\n    },\n  },\n}\n```\n"] pub fn make_perspective_camera () -> Entity {Entity :: new () . with_merge (make_perspective_common_camera ()) . with (components :: core :: camera :: far () , 1000f32) . with (components :: core :: camera :: perspective () , ())} # [doc = "Checks if the entity is a *Perspective Camera*.\n\nA perspective camera.\n\n*Definition*:\n\n```\n{\n  \"core::camera::far\": f32 = 1000f32,\n  \"core::camera::perspective\": () = (),\n  \"perspective_common_camera\": { // Concept.\n    \"core::camera::aspect_ratio\": f32 = 1f32,\n    \"core::camera::fovy\": f32 = 1f32,\n    \"camera\": { // Concept.\n      \"core::camera::active_camera\": f32 = 0f32,\n      \"core::camera::near\": f32 = 0.1f32,\n      \"core::camera::projection\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::camera::projection_view\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::transform::inv_local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::transform::local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"transformable\": { // Concept.\n        \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n        \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n        \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n      },\n    },\n  },\n}\n```\n"] pub fn is_perspective_camera (world : & ambient_ecs :: World , id : EntityId) -> bool {is_perspective_common_camera (world , id) && world . has_components (id , & {let mut set = ambient_ecs :: ComponentSet :: new () ; set . insert (components :: core :: camera :: far () . desc ()) ; set . insert (components :: core :: camera :: perspective () . desc ()) ; set})} # [allow (clippy :: approx_constant)] # [doc = "Makes a *Perspective Common Camera*.\n\nBase components for a perspective camera. Consider `perspective_camera` or `perspective_infinite_reverse_camera`.\n\n*Definition*:\n\n```\n{\n  \"core::camera::aspect_ratio\": f32 = 1f32,\n  \"core::camera::fovy\": f32 = 1f32,\n  \"camera\": { // Concept.\n    \"core::camera::active_camera\": f32 = 0f32,\n    \"core::camera::near\": f32 = 0.1f32,\n    \"core::camera::projection\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::camera::projection_view\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::transform::inv_local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::transform::local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"transformable\": { // Concept.\n      \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n      \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n      \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n    },\n  },\n}\n```\n"] pub fn make_perspective_common_camera () -> Entity {Entity :: new () . with_merge (make_camera ()) . with (components :: core :: camera :: aspect_ratio () , 1f32) . with (components :: core :: camera :: fovy () , 1f32)} # [doc = "Checks if the entity is a *Perspective Common Camera*.\n\nBase components for a perspective camera. Consider `perspective_camera` or `perspective_infinite_reverse_camera`.\n\n*Definition*:\n\n```\n{\n  \"core::camera::aspect_ratio\": f32 = 1f32,\n  \"core::camera::fovy\": f32 = 1f32,\n  \"camera\": { // Concept.\n    \"core::camera::active_camera\": f32 = 0f32,\n    \"core::camera::near\": f32 = 0.1f32,\n    \"core::camera::projection\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::camera::projection_view\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::transform::inv_local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"core::transform::local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n    \"transformable\": { // Concept.\n      \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n      \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n      \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n    },\n  },\n}\n```\n"] pub fn is_perspective_common_camera (world : & ambient_ecs :: World , id : EntityId) -> bool {is_camera (world , id) && world . has_components (id , & {let mut set = ambient_ecs :: ComponentSet :: new () ; set . insert (components :: core :: camera :: aspect_ratio () . desc ()) ; set . insert (components :: core :: camera :: fovy () . desc ()) ; set})} # [allow (clippy :: approx_constant)] # [doc = "Makes a *Perspective-Infinite-Reverse Camera*.\n\nA perspective-infinite-reverse camera. This is recommended for most use-cases.\n\n*Definition*:\n\n```\n{\n  \"core::camera::perspective_infinite_reverse\": () = (),\n  \"perspective_common_camera\": { // Concept.\n    \"core::camera::aspect_ratio\": f32 = 1f32,\n    \"core::camera::fovy\": f32 = 1f32,\n    \"camera\": { // Concept.\n      \"core::camera::active_camera\": f32 = 0f32,\n      \"core::camera::near\": f32 = 0.1f32,\n      \"core::camera::projection\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::camera::projection_view\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::transform::inv_local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::transform::local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"transformable\": { // Concept.\n        \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n        \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n        \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n      },\n    },\n  },\n}\n```\n"] pub fn make_perspective_infinite_reverse_camera () -> Entity {Entity :: new () . with_merge (make_perspective_common_camera ()) . with (components :: core :: camera :: perspective_infinite_reverse () , ())} # [doc = "Checks if the entity is a *Perspective-Infinite-Reverse Camera*.\n\nA perspective-infinite-reverse camera. This is recommended for most use-cases.\n\n*Definition*:\n\n```\n{\n  \"core::camera::perspective_infinite_reverse\": () = (),\n  \"perspective_common_camera\": { // Concept.\n    \"core::camera::aspect_ratio\": f32 = 1f32,\n    \"core::camera::fovy\": f32 = 1f32,\n    \"camera\": { // Concept.\n      \"core::camera::active_camera\": f32 = 0f32,\n      \"core::camera::near\": f32 = 0.1f32,\n      \"core::camera::projection\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::camera::projection_view\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::transform::inv_local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"core::transform::local_to_world\": Mat4 = Mat4::from_cols_array(&[1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32, 0f32, 0f32, 0f32, 0f32, 1f32]),\n      \"transformable\": { // Concept.\n        \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n        \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n        \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n      },\n    },\n  },\n}\n```\n"] pub fn is_perspective_infinite_reverse_camera (world : & ambient_ecs :: World , id : EntityId) -> bool {is_perspective_common_camera (world , id) && world . has_components (id , & {let mut set = ambient_ecs :: ComponentSet :: new () ; set . insert (components :: core :: camera :: perspective_infinite_reverse () . desc ()) ; set})} # [allow (clippy :: approx_constant)] # [doc = "Makes a *Sphere*.\n\nA primitive sphere.\n\n*Definition*:\n\n```\n{\n  \"core::primitives::sphere\": () = (),\n  \"core::primitives::sphere_radius\": f32 = 0.5f32,\n  \"core::primitives::sphere_sectors\": u32 = 36u32,\n  \"core::primitives::sphere_stacks\": u32 = 18u32,\n}\n```\n"] pub fn make_sphere () -> Entity {Entity :: new () . with (components :: core :: primitives :: sphere () , ()) . with (components :: core :: primitives :: sphere_radius () , 0.5f32) . with (components :: core :: primitives :: sphere_sectors () , 36u32) . with (components :: core :: primitives :: sphere_stacks () , 18u32)} # [doc = "Checks if the entity is a *Sphere*.\n\nA primitive sphere.\n\n*Definition*:\n\n```\n{\n  \"core::primitives::sphere\": () = (),\n  \"core::primitives::sphere_radius\": f32 = 0.5f32,\n  \"core::primitives::sphere_sectors\": u32 = 36u32,\n  \"core::primitives::sphere_stacks\": u32 = 18u32,\n}\n```\n"] pub fn is_sphere (world : & ambient_ecs :: World , id : EntityId) -> bool {world . has_components (id , & {let mut set = ambient_ecs :: ComponentSet :: new () ; set . insert (components :: core :: primitives :: sphere () . desc ()) ; set . insert (components :: core :: primitives :: sphere_radius () . desc ()) ; set . insert (components :: core :: primitives :: sphere_sectors () . desc ()) ; set . insert (components :: core :: primitives :: sphere_stacks () . desc ()) ; set})} # [allow (clippy :: approx_constant)] # [doc = "Makes a *Transformable*.\n\nCan be translated, rotated and scaled.\n\n*Definition*:\n\n```\n{\n  \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n  \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n  \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n}\n```\n"] pub fn make_transformable () -> Entity {Entity :: new () . with (components :: core :: transform :: rotation () , Quat :: from_xyzw (0f32 , 0f32 , 0f32 , 1f32)) . with (components :: core :: transform :: scale () , Vec3 :: new (1f32 , 1f32 , 1f32)) . with (components :: core :: transform :: translation () , Vec3 :: new (0f32 , 0f32 , 0f32))} # [doc = "Checks if the entity is a *Transformable*.\n\nCan be translated, rotated and scaled.\n\n*Definition*:\n\n```\n{\n  \"core::transform::rotation\": Quat = Quat::from_xyzw(0f32, 0f32, 0f32, 1f32),\n  \"core::transform::scale\": Vec3 = Vec3::new(1f32, 1f32, 1f32),\n  \"core::transform::translation\": Vec3 = Vec3::new(0f32, 0f32, 0f32),\n}\n```\n"] pub fn is_transformable (world : & ambient_ecs :: World , id : EntityId) -> bool {world . has_components (id , & {let mut set = ambient_ecs :: ComponentSet :: new () ; set . insert (components :: core :: transform :: rotation () . desc ()) ; set . insert (components :: core :: transform :: scale () . desc ()) ; set . insert (components :: core :: transform :: translation () . desc ()) ; set})}} # [doc = r" Auto-generated message definitions. Messages are used to communicate between the client and serverside,"] # [doc = r" as well as to other modules."] pub mod messages {}