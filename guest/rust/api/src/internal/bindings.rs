// Generated by `wit-bindgen` 0.3.0. DO NOT EDIT!

#[allow(clippy::all)]
pub mod types{ use super::wit_bindgen;
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Vec4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
  }
  impl core::fmt::Debug for Vec4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Vec4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
  }
  impl core::fmt::Debug for Vec3 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Vec3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Vec2 {
    pub x: f32,
    pub y: f32,
  }
  impl core::fmt::Debug for Vec2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Vec2").field("x", &self.x).field("y", &self.y).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Uvec4 {
    pub x: u32,
    pub y: u32,
    pub z: u32,
    pub w: u32,
  }
  impl core::fmt::Debug for Uvec4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Uvec4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Uvec3 {
    pub x: u32,
    pub y: u32,
    pub z: u32,
  }
  impl core::fmt::Debug for Uvec3 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Uvec3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Uvec2 {
    pub x: u32,
    pub y: u32,
  }
  impl core::fmt::Debug for Uvec2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Uvec2").field("x", &self.x).field("y", &self.y).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Quat {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
  }
  impl core::fmt::Debug for Quat {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Quat").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Mat4 {
    pub x: Vec4,
    pub y: Vec4,
    pub z: Vec4,
    pub w: Vec4,
  }
  impl core::fmt::Debug for Mat4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Mat4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct EntityId {
    pub id0: u64,
    pub id1: u64,
  }
  impl core::fmt::Debug for EntityId {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("EntityId").field("id0", &self.id0).field("id1", &self.id1).finish()
    }
  }
  
}


#[allow(clippy::all)]
pub mod component{ use super::wit_bindgen;
  pub type EntityId = super::types::EntityId;
  pub type Mat4 = super::types::Mat4;
  pub type Quat = super::types::Quat;
  pub type Vec2 = super::types::Vec2;
  pub type Vec3 = super::types::Vec3;
  pub type Vec4 = super::types::Vec4;
  pub type Uvec2 = super::types::Uvec2;
  pub type Uvec3 = super::types::Uvec3;
  pub type Uvec4 = super::types::Uvec4;
  #[repr(u8)]
  #[derive(Clone, Copy, PartialEq, Eq)]
  pub enum QueryEvent {
    Frame,
    Spawn,
    Despawn,
  }
  impl core::fmt::Debug for QueryEvent {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        QueryEvent::Frame => {
          f.debug_tuple("QueryEvent::Frame").finish()
        }
        QueryEvent::Spawn => {
          f.debug_tuple("QueryEvent::Spawn").finish()
        }
        QueryEvent::Despawn => {
          f.debug_tuple("QueryEvent::Despawn").finish()
        }
      }
    }
  }
  #[derive(Clone)]
  pub struct QueryBuild<'a,> {
    pub components: &'a [u32],
    pub include: &'a [u32],
    pub exclude: &'a [u32],
    pub changed: &'a [u32],
  }
  impl<'a,> core::fmt::Debug for QueryBuild<'a,> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("QueryBuild").field("components", &self.components).field("include", &self.include).field("exclude", &self.exclude).field("changed", &self.changed).finish()
    }
  }
  #[derive(Clone)]
  pub enum ComponentOptionTypeResult{
    TypeEmpty(Option<()>),
    TypeBool(Option<bool>),
    TypeEntityId(Option<EntityId>),
    TypeF32(Option<f32>),
    TypeF64(Option<f64>),
    TypeMat4(Option<Mat4>),
    TypeI32(Option<i32>),
    TypeQuat(Option<Quat>),
    TypeString(Option<wit_bindgen::rt::string::String>),
    TypeU32(Option<u32>),
    TypeU64(Option<u64>),
    TypeVec2(Option<Vec2>),
    TypeVec3(Option<Vec3>),
    TypeVec4(Option<Vec4>),
    TypeUvec2(Option<Uvec2>),
    TypeUvec3(Option<Uvec3>),
    TypeUvec4(Option<Uvec4>),
  }
  impl core::fmt::Debug for ComponentOptionTypeResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentOptionTypeResult::TypeEmpty(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeEmpty").field(e).finish()
        }
        ComponentOptionTypeResult::TypeBool(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeBool").field(e).finish()
        }
        ComponentOptionTypeResult::TypeEntityId(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeEntityId").field(e).finish()
        }
        ComponentOptionTypeResult::TypeF32(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeF32").field(e).finish()
        }
        ComponentOptionTypeResult::TypeF64(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeF64").field(e).finish()
        }
        ComponentOptionTypeResult::TypeMat4(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeMat4").field(e).finish()
        }
        ComponentOptionTypeResult::TypeI32(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeI32").field(e).finish()
        }
        ComponentOptionTypeResult::TypeQuat(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeQuat").field(e).finish()
        }
        ComponentOptionTypeResult::TypeString(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeString").field(e).finish()
        }
        ComponentOptionTypeResult::TypeU32(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeU32").field(e).finish()
        }
        ComponentOptionTypeResult::TypeU64(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeU64").field(e).finish()
        }
        ComponentOptionTypeResult::TypeVec2(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeVec2").field(e).finish()
        }
        ComponentOptionTypeResult::TypeVec3(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeVec3").field(e).finish()
        }
        ComponentOptionTypeResult::TypeVec4(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeVec4").field(e).finish()
        }
        ComponentOptionTypeResult::TypeUvec2(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeUvec2").field(e).finish()
        }
        ComponentOptionTypeResult::TypeUvec3(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeUvec3").field(e).finish()
        }
        ComponentOptionTypeResult::TypeUvec4(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeUvec4").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum ComponentOptionTypeParam<'a,>{
    TypeEmpty(Option<()>),
    TypeBool(Option<bool>),
    TypeEntityId(Option<EntityId>),
    TypeF32(Option<f32>),
    TypeF64(Option<f64>),
    TypeMat4(Option<Mat4>),
    TypeI32(Option<i32>),
    TypeQuat(Option<Quat>),
    TypeString(Option<&'a str>),
    TypeU32(Option<u32>),
    TypeU64(Option<u64>),
    TypeVec2(Option<Vec2>),
    TypeVec3(Option<Vec3>),
    TypeVec4(Option<Vec4>),
    TypeUvec2(Option<Uvec2>),
    TypeUvec3(Option<Uvec3>),
    TypeUvec4(Option<Uvec4>),
  }
  impl<'a,> core::fmt::Debug for ComponentOptionTypeParam<'a,> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentOptionTypeParam::TypeEmpty(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeEmpty").field(e).finish()
        }
        ComponentOptionTypeParam::TypeBool(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeBool").field(e).finish()
        }
        ComponentOptionTypeParam::TypeEntityId(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeEntityId").field(e).finish()
        }
        ComponentOptionTypeParam::TypeF32(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeF32").field(e).finish()
        }
        ComponentOptionTypeParam::TypeF64(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeF64").field(e).finish()
        }
        ComponentOptionTypeParam::TypeMat4(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeMat4").field(e).finish()
        }
        ComponentOptionTypeParam::TypeI32(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeI32").field(e).finish()
        }
        ComponentOptionTypeParam::TypeQuat(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeQuat").field(e).finish()
        }
        ComponentOptionTypeParam::TypeString(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeString").field(e).finish()
        }
        ComponentOptionTypeParam::TypeU32(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeU32").field(e).finish()
        }
        ComponentOptionTypeParam::TypeU64(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeU64").field(e).finish()
        }
        ComponentOptionTypeParam::TypeVec2(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeVec2").field(e).finish()
        }
        ComponentOptionTypeParam::TypeVec3(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeVec3").field(e).finish()
        }
        ComponentOptionTypeParam::TypeVec4(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeVec4").field(e).finish()
        }
        ComponentOptionTypeParam::TypeUvec2(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeUvec2").field(e).finish()
        }
        ComponentOptionTypeParam::TypeUvec3(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeUvec3").field(e).finish()
        }
        ComponentOptionTypeParam::TypeUvec4(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeUvec4").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum ComponentListTypeResult{
    TypeEmpty(wit_bindgen::rt::vec::Vec::<()>),
    TypeBool(wit_bindgen::rt::vec::Vec::<bool>),
    TypeEntityId(wit_bindgen::rt::vec::Vec::<EntityId>),
    TypeF32(wit_bindgen::rt::vec::Vec::<f32>),
    TypeF64(wit_bindgen::rt::vec::Vec::<f64>),
    TypeMat4(wit_bindgen::rt::vec::Vec::<Mat4>),
    TypeI32(wit_bindgen::rt::vec::Vec::<i32>),
    TypeQuat(wit_bindgen::rt::vec::Vec::<Quat>),
    TypeString(wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>),
    TypeU32(wit_bindgen::rt::vec::Vec::<u32>),
    TypeU64(wit_bindgen::rt::vec::Vec::<u64>),
    TypeVec2(wit_bindgen::rt::vec::Vec::<Vec2>),
    TypeVec3(wit_bindgen::rt::vec::Vec::<Vec3>),
    TypeVec4(wit_bindgen::rt::vec::Vec::<Vec4>),
    TypeUvec2(wit_bindgen::rt::vec::Vec::<Uvec2>),
    TypeUvec3(wit_bindgen::rt::vec::Vec::<Uvec3>),
    TypeUvec4(wit_bindgen::rt::vec::Vec::<Uvec4>),
  }
  impl core::fmt::Debug for ComponentListTypeResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentListTypeResult::TypeEmpty(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeEmpty").field(e).finish()
        }
        ComponentListTypeResult::TypeBool(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeBool").field(e).finish()
        }
        ComponentListTypeResult::TypeEntityId(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeEntityId").field(e).finish()
        }
        ComponentListTypeResult::TypeF32(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeF32").field(e).finish()
        }
        ComponentListTypeResult::TypeF64(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeF64").field(e).finish()
        }
        ComponentListTypeResult::TypeMat4(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeMat4").field(e).finish()
        }
        ComponentListTypeResult::TypeI32(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeI32").field(e).finish()
        }
        ComponentListTypeResult::TypeQuat(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeQuat").field(e).finish()
        }
        ComponentListTypeResult::TypeString(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeString").field(e).finish()
        }
        ComponentListTypeResult::TypeU32(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeU32").field(e).finish()
        }
        ComponentListTypeResult::TypeU64(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeU64").field(e).finish()
        }
        ComponentListTypeResult::TypeVec2(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeVec2").field(e).finish()
        }
        ComponentListTypeResult::TypeVec3(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeVec3").field(e).finish()
        }
        ComponentListTypeResult::TypeVec4(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeVec4").field(e).finish()
        }
        ComponentListTypeResult::TypeUvec2(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeUvec2").field(e).finish()
        }
        ComponentListTypeResult::TypeUvec3(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeUvec3").field(e).finish()
        }
        ComponentListTypeResult::TypeUvec4(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeUvec4").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum ComponentListTypeParam<'a,>{
    TypeEmpty(&'a [()]),
    TypeBool(&'a [bool]),
    TypeEntityId(&'a [EntityId]),
    TypeF32(&'a [f32]),
    TypeF64(&'a [f64]),
    TypeMat4(&'a [Mat4]),
    TypeI32(&'a [i32]),
    TypeQuat(&'a [Quat]),
    TypeString(&'a [&'a str]),
    TypeU32(&'a [u32]),
    TypeU64(&'a [u64]),
    TypeVec2(&'a [Vec2]),
    TypeVec3(&'a [Vec3]),
    TypeVec4(&'a [Vec4]),
    TypeUvec2(&'a [Uvec2]),
    TypeUvec3(&'a [Uvec3]),
    TypeUvec4(&'a [Uvec4]),
  }
  impl<'a,> core::fmt::Debug for ComponentListTypeParam<'a,> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentListTypeParam::TypeEmpty(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeEmpty").field(e).finish()
        }
        ComponentListTypeParam::TypeBool(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeBool").field(e).finish()
        }
        ComponentListTypeParam::TypeEntityId(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeEntityId").field(e).finish()
        }
        ComponentListTypeParam::TypeF32(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeF32").field(e).finish()
        }
        ComponentListTypeParam::TypeF64(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeF64").field(e).finish()
        }
        ComponentListTypeParam::TypeMat4(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeMat4").field(e).finish()
        }
        ComponentListTypeParam::TypeI32(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeI32").field(e).finish()
        }
        ComponentListTypeParam::TypeQuat(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeQuat").field(e).finish()
        }
        ComponentListTypeParam::TypeString(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeString").field(e).finish()
        }
        ComponentListTypeParam::TypeU32(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeU32").field(e).finish()
        }
        ComponentListTypeParam::TypeU64(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeU64").field(e).finish()
        }
        ComponentListTypeParam::TypeVec2(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeVec2").field(e).finish()
        }
        ComponentListTypeParam::TypeVec3(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeVec3").field(e).finish()
        }
        ComponentListTypeParam::TypeVec4(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeVec4").field(e).finish()
        }
        ComponentListTypeParam::TypeUvec2(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeUvec2").field(e).finish()
        }
        ComponentListTypeParam::TypeUvec3(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeUvec3").field(e).finish()
        }
        ComponentListTypeParam::TypeUvec4(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeUvec4").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum ComponentTypeResult{
    TypeEmpty(()),
    TypeBool(bool),
    TypeEntityId(EntityId),
    TypeF32(f32),
    TypeF64(f64),
    TypeMat4(Mat4),
    TypeI32(i32),
    TypeQuat(Quat),
    TypeString(wit_bindgen::rt::string::String),
    TypeU32(u32),
    TypeU64(u64),
    TypeVec2(Vec2),
    TypeVec3(Vec3),
    TypeVec4(Vec4),
    TypeUvec2(Uvec2),
    TypeUvec3(Uvec3),
    TypeUvec4(Uvec4),
    TypeList(ComponentListTypeResult),
    TypeOption(ComponentOptionTypeResult),
  }
  impl core::fmt::Debug for ComponentTypeResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentTypeResult::TypeEmpty(e) => {
          f.debug_tuple("ComponentTypeResult::TypeEmpty").field(e).finish()
        }
        ComponentTypeResult::TypeBool(e) => {
          f.debug_tuple("ComponentTypeResult::TypeBool").field(e).finish()
        }
        ComponentTypeResult::TypeEntityId(e) => {
          f.debug_tuple("ComponentTypeResult::TypeEntityId").field(e).finish()
        }
        ComponentTypeResult::TypeF32(e) => {
          f.debug_tuple("ComponentTypeResult::TypeF32").field(e).finish()
        }
        ComponentTypeResult::TypeF64(e) => {
          f.debug_tuple("ComponentTypeResult::TypeF64").field(e).finish()
        }
        ComponentTypeResult::TypeMat4(e) => {
          f.debug_tuple("ComponentTypeResult::TypeMat4").field(e).finish()
        }
        ComponentTypeResult::TypeI32(e) => {
          f.debug_tuple("ComponentTypeResult::TypeI32").field(e).finish()
        }
        ComponentTypeResult::TypeQuat(e) => {
          f.debug_tuple("ComponentTypeResult::TypeQuat").field(e).finish()
        }
        ComponentTypeResult::TypeString(e) => {
          f.debug_tuple("ComponentTypeResult::TypeString").field(e).finish()
        }
        ComponentTypeResult::TypeU32(e) => {
          f.debug_tuple("ComponentTypeResult::TypeU32").field(e).finish()
        }
        ComponentTypeResult::TypeU64(e) => {
          f.debug_tuple("ComponentTypeResult::TypeU64").field(e).finish()
        }
        ComponentTypeResult::TypeVec2(e) => {
          f.debug_tuple("ComponentTypeResult::TypeVec2").field(e).finish()
        }
        ComponentTypeResult::TypeVec3(e) => {
          f.debug_tuple("ComponentTypeResult::TypeVec3").field(e).finish()
        }
        ComponentTypeResult::TypeVec4(e) => {
          f.debug_tuple("ComponentTypeResult::TypeVec4").field(e).finish()
        }
        ComponentTypeResult::TypeUvec2(e) => {
          f.debug_tuple("ComponentTypeResult::TypeUvec2").field(e).finish()
        }
        ComponentTypeResult::TypeUvec3(e) => {
          f.debug_tuple("ComponentTypeResult::TypeUvec3").field(e).finish()
        }
        ComponentTypeResult::TypeUvec4(e) => {
          f.debug_tuple("ComponentTypeResult::TypeUvec4").field(e).finish()
        }
        ComponentTypeResult::TypeList(e) => {
          f.debug_tuple("ComponentTypeResult::TypeList").field(e).finish()
        }
        ComponentTypeResult::TypeOption(e) => {
          f.debug_tuple("ComponentTypeResult::TypeOption").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum ComponentTypeParam<'a,>{
    TypeEmpty(()),
    TypeBool(bool),
    TypeEntityId(EntityId),
    TypeF32(f32),
    TypeF64(f64),
    TypeMat4(Mat4),
    TypeI32(i32),
    TypeQuat(Quat),
    TypeString(&'a str),
    TypeU32(u32),
    TypeU64(u64),
    TypeVec2(Vec2),
    TypeVec3(Vec3),
    TypeVec4(Vec4),
    TypeUvec2(Uvec2),
    TypeUvec3(Uvec3),
    TypeUvec4(Uvec4),
    TypeList(ComponentListTypeParam<'a,>),
    TypeOption(ComponentOptionTypeParam<'a,>),
  }
  impl<'a,> core::fmt::Debug for ComponentTypeParam<'a,> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentTypeParam::TypeEmpty(e) => {
          f.debug_tuple("ComponentTypeParam::TypeEmpty").field(e).finish()
        }
        ComponentTypeParam::TypeBool(e) => {
          f.debug_tuple("ComponentTypeParam::TypeBool").field(e).finish()
        }
        ComponentTypeParam::TypeEntityId(e) => {
          f.debug_tuple("ComponentTypeParam::TypeEntityId").field(e).finish()
        }
        ComponentTypeParam::TypeF32(e) => {
          f.debug_tuple("ComponentTypeParam::TypeF32").field(e).finish()
        }
        ComponentTypeParam::TypeF64(e) => {
          f.debug_tuple("ComponentTypeParam::TypeF64").field(e).finish()
        }
        ComponentTypeParam::TypeMat4(e) => {
          f.debug_tuple("ComponentTypeParam::TypeMat4").field(e).finish()
        }
        ComponentTypeParam::TypeI32(e) => {
          f.debug_tuple("ComponentTypeParam::TypeI32").field(e).finish()
        }
        ComponentTypeParam::TypeQuat(e) => {
          f.debug_tuple("ComponentTypeParam::TypeQuat").field(e).finish()
        }
        ComponentTypeParam::TypeString(e) => {
          f.debug_tuple("ComponentTypeParam::TypeString").field(e).finish()
        }
        ComponentTypeParam::TypeU32(e) => {
          f.debug_tuple("ComponentTypeParam::TypeU32").field(e).finish()
        }
        ComponentTypeParam::TypeU64(e) => {
          f.debug_tuple("ComponentTypeParam::TypeU64").field(e).finish()
        }
        ComponentTypeParam::TypeVec2(e) => {
          f.debug_tuple("ComponentTypeParam::TypeVec2").field(e).finish()
        }
        ComponentTypeParam::TypeVec3(e) => {
          f.debug_tuple("ComponentTypeParam::TypeVec3").field(e).finish()
        }
        ComponentTypeParam::TypeVec4(e) => {
          f.debug_tuple("ComponentTypeParam::TypeVec4").field(e).finish()
        }
        ComponentTypeParam::TypeUvec2(e) => {
          f.debug_tuple("ComponentTypeParam::TypeUvec2").field(e).finish()
        }
        ComponentTypeParam::TypeUvec3(e) => {
          f.debug_tuple("ComponentTypeParam::TypeUvec3").field(e).finish()
        }
        ComponentTypeParam::TypeUvec4(e) => {
          f.debug_tuple("ComponentTypeParam::TypeUvec4").field(e).finish()
        }
        ComponentTypeParam::TypeList(e) => {
          f.debug_tuple("ComponentTypeParam::TypeList").field(e).finish()
        }
        ComponentTypeParam::TypeOption(e) => {
          f.debug_tuple("ComponentTypeParam::TypeOption").field(e).finish()
        }
      }
    }
  }
  pub type Entity<'a,> = &'a [(u32,ComponentTypeParam<'a,>,)];
  #[allow(clippy::all)]
  pub fn get_index(id: &str,) -> Option<u32>{
    
    #[allow(unused_imports)]
    use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
    unsafe {
      
      #[repr(align(4))]
      struct RetArea([u8; 8]);
      let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
      let vec0 = id;
      let ptr0 = vec0.as_ptr() as i32;
      let len0 = vec0.len() as i32;
      let ptr1 = ret_area.as_mut_ptr() as i32;
      #[link(wasm_import_module = "component")]
      extern "C" {
        #[cfg_attr(target_arch = "wasm32", link_name = "get-index")]
        #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_get-index")]
        fn wit_import(
        _: i32, _: i32, _: i32, );
      }
      wit_import(ptr0, len0, ptr1);
      match i32::from(*((ptr1 + 0) as *const u8)) {
        0 => None,
        1 => Some(*((ptr1 + 4) as *const i32) as u32),
        #[cfg(not(debug_assertions))]
        _ => core::hint::unreachable_unchecked(),
        #[cfg(debug_assertions)]
        _ => panic!("invalid enum discriminant"),
      }
    }
  }
  #[allow(clippy::all)]
  pub fn get_component(entity: EntityId,index: u32,) -> Option<ComponentTypeResult>{
    
    #[allow(unused_imports)]
    use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
    unsafe {
      
      #[repr(align(8))]
      struct RetArea([u8; 96]);
      let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
      let super::types::EntityId{ id0:id00, id1:id10, } = entity;
      let ptr1 = ret_area.as_mut_ptr() as i32;
      #[link(wasm_import_module = "component")]
      extern "C" {
        #[cfg_attr(target_arch = "wasm32", link_name = "get-component")]
        #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_get-component")]
        fn wit_import(
        _: i64, _: i64, _: i32, _: i32, );
      }
      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index), ptr1);
      match i32::from(*((ptr1 + 0) as *const u8)) {
        0 => None,
        1 => Some({{match i32::from(*((ptr1 + 8) as *const u8)) {
          0 => ComponentTypeResult::TypeEmpty(()),
          1 => ComponentTypeResult::TypeBool({
            #[cfg(not(debug_assertions))]
            { core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 16) as *const u8)) as u8) }
            #[cfg(debug_assertions)]
            {
              match i32::from(*((ptr1 + 16) as *const u8)) {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
              }
            }
          }),
          2 => ComponentTypeResult::TypeEntityId(super::types::EntityId{id0:*((ptr1 + 16) as *const i64) as u64, id1:*((ptr1 + 24) as *const i64) as u64, }),
          3 => ComponentTypeResult::TypeF32(*((ptr1 + 16) as *const f32)),
          4 => ComponentTypeResult::TypeF64(*((ptr1 + 16) as *const f64)),
          5 => ComponentTypeResult::TypeMat4(super::types::Mat4{x:super::types::Vec4{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }, y:super::types::Vec4{x:*((ptr1 + 32) as *const f32), y:*((ptr1 + 36) as *const f32), z:*((ptr1 + 40) as *const f32), w:*((ptr1 + 44) as *const f32), }, z:super::types::Vec4{x:*((ptr1 + 48) as *const f32), y:*((ptr1 + 52) as *const f32), z:*((ptr1 + 56) as *const f32), w:*((ptr1 + 60) as *const f32), }, w:super::types::Vec4{x:*((ptr1 + 64) as *const f32), y:*((ptr1 + 68) as *const f32), z:*((ptr1 + 72) as *const f32), w:*((ptr1 + 76) as *const f32), }, }),
          6 => ComponentTypeResult::TypeI32(*((ptr1 + 16) as *const i32)),
          7 => ComponentTypeResult::TypeQuat(super::types::Quat{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }),
          8 => ComponentTypeResult::TypeString({
            let len2 = *((ptr1 + 20) as *const i32) as usize;
            
            {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 16) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 16) as *const i32) as *mut _, len2, len2)).unwrap()}}
          }),
          9 => ComponentTypeResult::TypeU32(*((ptr1 + 16) as *const i32) as u32),
          10 => ComponentTypeResult::TypeU64(*((ptr1 + 16) as *const i64) as u64),
          11 => ComponentTypeResult::TypeVec2(super::types::Vec2{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), }),
          12 => ComponentTypeResult::TypeVec3(super::types::Vec3{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), }),
          13 => ComponentTypeResult::TypeVec4(super::types::Vec4{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }),
          14 => ComponentTypeResult::TypeUvec2(super::types::Uvec2{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, }),
          15 => ComponentTypeResult::TypeUvec3(super::types::Uvec3{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, z:*((ptr1 + 24) as *const i32) as u32, }),
          16 => ComponentTypeResult::TypeUvec4(super::types::Uvec4{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, z:*((ptr1 + 24) as *const i32) as u32, w:*((ptr1 + 28) as *const i32) as u32, }),
          17 => ComponentTypeResult::TypeList({{match i32::from(*((ptr1 + 16) as *const u8)) {
            0 => ComponentListTypeResult::TypeEmpty({
              let len3 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len3, len3)
            }),
            1 => ComponentListTypeResult::TypeBool({
              let base4 = *((ptr1 + 20) as *const i32);
              let len4 = *((ptr1 + 24) as *const i32);
              let mut result4 = Vec::with_capacity(len4 as usize);
              for i in 0..len4 {
                let base = base4 + i *1;
                result4.push({
                  #[cfg(not(debug_assertions))]
                  { core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                  #[cfg(debug_assertions)]
                  {
                    match i32::from(*((base + 0) as *const u8)) {
                      0 => false,
                      1 => true,
                      _ => panic!("invalid bool discriminant"),
                    }
                  }
                });
              }
              wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
              
              result4
            }),
            2 => ComponentListTypeResult::TypeEntityId({
              let len5 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len5, len5)
            }),
            3 => ComponentListTypeResult::TypeF32({
              let len6 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len6, len6)
            }),
            4 => ComponentListTypeResult::TypeF64({
              let len7 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len7, len7)
            }),
            5 => ComponentListTypeResult::TypeMat4({
              let len8 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len8, len8)
            }),
            6 => ComponentListTypeResult::TypeI32({
              let len9 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len9, len9)
            }),
            7 => ComponentListTypeResult::TypeQuat({
              let len10 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len10, len10)
            }),
            8 => ComponentListTypeResult::TypeString({
              let base12 = *((ptr1 + 20) as *const i32);
              let len12 = *((ptr1 + 24) as *const i32);
              let mut result12 = Vec::with_capacity(len12 as usize);
              for i in 0..len12 {
                let base = base12 + i *8;
                result12.push({
                  let len11 = *((base + 4) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len11, len11))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len11, len11)).unwrap()}}
                });
              }
              wit_bindgen::rt::dealloc(base12, (len12 as usize) * 8, 4);
              
              result12
            }),
            9 => ComponentListTypeResult::TypeU32({
              let len13 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len13, len13)
            }),
            10 => ComponentListTypeResult::TypeU64({
              let len14 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len14, len14)
            }),
            11 => ComponentListTypeResult::TypeVec2({
              let len15 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len15, len15)
            }),
            12 => ComponentListTypeResult::TypeVec3({
              let len16 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len16, len16)
            }),
            13 => ComponentListTypeResult::TypeVec4({
              let len17 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len17, len17)
            }),
            14 => ComponentListTypeResult::TypeUvec2({
              let len18 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len18, len18)
            }),
            15 => ComponentListTypeResult::TypeUvec3({
              let len19 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len19, len19)
            }),
            #[cfg(debug_assertions)]16 => ComponentListTypeResult::TypeUvec4({
              let len20 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len20, len20)
            }),
            #[cfg(not(debug_assertions))]_ => ComponentListTypeResult::TypeUvec4({
              let len20 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len20, len20)
            }),
            #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
          }}}),
          #[cfg(debug_assertions)]18 => ComponentTypeResult::TypeOption({{match i32::from(*((ptr1 + 16) as *const u8)) {
            0 => ComponentOptionTypeResult::TypeEmpty(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(()),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            1 => ComponentOptionTypeResult::TypeBool(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some({
                #[cfg(not(debug_assertions))]
                { core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 25) as *const u8)) as u8) }
                #[cfg(debug_assertions)]
                {
                  match i32::from(*((ptr1 + 25) as *const u8)) {
                    0 => false,
                    1 => true,
                    _ => panic!("invalid bool discriminant"),
                  }
                }
              }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            2 => ComponentOptionTypeResult::TypeEntityId(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::EntityId{id0:*((ptr1 + 32) as *const i64) as u64, id1:*((ptr1 + 40) as *const i64) as u64, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            3 => ComponentOptionTypeResult::TypeF32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const f32)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            4 => ComponentOptionTypeResult::TypeF64(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 32) as *const f64)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            5 => ComponentOptionTypeResult::TypeMat4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }, y:super::types::Vec4{x:*((ptr1 + 44) as *const f32), y:*((ptr1 + 48) as *const f32), z:*((ptr1 + 52) as *const f32), w:*((ptr1 + 56) as *const f32), }, z:super::types::Vec4{x:*((ptr1 + 60) as *const f32), y:*((ptr1 + 64) as *const f32), z:*((ptr1 + 68) as *const f32), w:*((ptr1 + 72) as *const f32), }, w:super::types::Vec4{x:*((ptr1 + 76) as *const f32), y:*((ptr1 + 80) as *const f32), z:*((ptr1 + 84) as *const f32), w:*((ptr1 + 88) as *const f32), }, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            6 => ComponentOptionTypeResult::TypeI32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const i32)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            7 => ComponentOptionTypeResult::TypeQuat(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Quat{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            8 => ComponentOptionTypeResult::TypeString(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some({
                let len21 = *((ptr1 + 32) as *const i32) as usize;
                
                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len21, len21))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len21, len21)).unwrap()}}
              }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            9 => ComponentOptionTypeResult::TypeU32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const i32) as u32),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            10 => ComponentOptionTypeResult::TypeU64(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 32) as *const i64) as u64),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            11 => ComponentOptionTypeResult::TypeVec2(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec2{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            12 => ComponentOptionTypeResult::TypeVec3(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec3{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            13 => ComponentOptionTypeResult::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            14 => ComponentOptionTypeResult::TypeUvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Uvec2{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            15 => ComponentOptionTypeResult::TypeUvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Uvec3{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(debug_assertions)]16 => ComponentOptionTypeResult::TypeUvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Uvec4{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, w:*((ptr1 + 40) as *const i32) as u32, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(not(debug_assertions))]_ => ComponentOptionTypeResult::TypeUvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Uvec4{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, w:*((ptr1 + 40) as *const i32) as u32, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
          }}}),
          #[cfg(not(debug_assertions))]_ => ComponentTypeResult::TypeOption({{match i32::from(*((ptr1 + 16) as *const u8)) {
            0 => ComponentOptionTypeResult::TypeEmpty(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(()),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            1 => ComponentOptionTypeResult::TypeBool(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some({
                #[cfg(not(debug_assertions))]
                { core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 25) as *const u8)) as u8) }
                #[cfg(debug_assertions)]
                {
                  match i32::from(*((ptr1 + 25) as *const u8)) {
                    0 => false,
                    1 => true,
                    _ => panic!("invalid bool discriminant"),
                  }
                }
              }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            2 => ComponentOptionTypeResult::TypeEntityId(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::EntityId{id0:*((ptr1 + 32) as *const i64) as u64, id1:*((ptr1 + 40) as *const i64) as u64, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            3 => ComponentOptionTypeResult::TypeF32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const f32)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            4 => ComponentOptionTypeResult::TypeF64(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 32) as *const f64)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            5 => ComponentOptionTypeResult::TypeMat4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }, y:super::types::Vec4{x:*((ptr1 + 44) as *const f32), y:*((ptr1 + 48) as *const f32), z:*((ptr1 + 52) as *const f32), w:*((ptr1 + 56) as *const f32), }, z:super::types::Vec4{x:*((ptr1 + 60) as *const f32), y:*((ptr1 + 64) as *const f32), z:*((ptr1 + 68) as *const f32), w:*((ptr1 + 72) as *const f32), }, w:super::types::Vec4{x:*((ptr1 + 76) as *const f32), y:*((ptr1 + 80) as *const f32), z:*((ptr1 + 84) as *const f32), w:*((ptr1 + 88) as *const f32), }, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            6 => ComponentOptionTypeResult::TypeI32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const i32)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            7 => ComponentOptionTypeResult::TypeQuat(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Quat{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            8 => ComponentOptionTypeResult::TypeString(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some({
                let len21 = *((ptr1 + 32) as *const i32) as usize;
                
                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len21, len21))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len21, len21)).unwrap()}}
              }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            9 => ComponentOptionTypeResult::TypeU32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const i32) as u32),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            10 => ComponentOptionTypeResult::TypeU64(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 32) as *const i64) as u64),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            11 => ComponentOptionTypeResult::TypeVec2(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec2{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            12 => ComponentOptionTypeResult::TypeVec3(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec3{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            13 => ComponentOptionTypeResult::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            14 => ComponentOptionTypeResult::TypeUvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Uvec2{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            15 => ComponentOptionTypeResult::TypeUvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Uvec3{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(debug_assertions)]16 => ComponentOptionTypeResult::TypeUvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Uvec4{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, w:*((ptr1 + 40) as *const i32) as u32, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(not(debug_assertions))]_ => ComponentOptionTypeResult::TypeUvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Uvec4{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, w:*((ptr1 + 40) as *const i32) as u32, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
          }}}),
          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
        }}}),
        #[cfg(not(debug_assertions))]
        _ => core::hint::unreachable_unchecked(),
        #[cfg(debug_assertions)]
        _ => panic!("invalid enum discriminant"),
      }
    }
  }
  #[allow(clippy::all)]
  pub fn add_component(entity: EntityId,index: u32,value: ComponentTypeParam<'_,>,){
    
    #[allow(unused_imports)]
    use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
    unsafe {
      let mut cleanup_list = Vec::new();
      
      #[repr(align(8))]
      struct RetArea([u8; 112]);
      let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
      let ptr0 = ret_area.as_mut_ptr() as i32;let super::types::EntityId{ id0:id01, id1:id11, } = entity;
      *((ptr0 + 0) as *mut i64) = wit_bindgen::rt::as_i64(id01);
      *((ptr0 + 8) as *mut i64) = wit_bindgen::rt::as_i64(id11);
      *((ptr0 + 16) as *mut i32) = wit_bindgen::rt::as_i32(index);
      match value {
        ComponentTypeParam::TypeEmpty(e) => {
          *((ptr0 + 24) as *mut u8) = (0i32) as u8;
          let () = e;
          
        },
        ComponentTypeParam::TypeBool(e) => {
          *((ptr0 + 24) as *mut u8) = (1i32) as u8;
          *((ptr0 + 32) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
          
        },
        ComponentTypeParam::TypeEntityId(e) => {
          *((ptr0 + 24) as *mut u8) = (2i32) as u8;
          let super::types::EntityId{ id0:id03, id1:id13, } = e;
          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(id03);
          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(id13);
          
        },
        ComponentTypeParam::TypeF32(e) => {
          *((ptr0 + 24) as *mut u8) = (3i32) as u8;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(e);
          
        },
        ComponentTypeParam::TypeF64(e) => {
          *((ptr0 + 24) as *mut u8) = (4i32) as u8;
          *((ptr0 + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
          
        },
        ComponentTypeParam::TypeMat4(e) => {
          *((ptr0 + 24) as *mut u8) = (5i32) as u8;
          let super::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
          let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
          let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
          *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
          *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
          *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
          *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
          let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
          *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
          *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
          *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
          *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
          let super::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
          *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(x8);
          *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(y8);
          *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(z8);
          *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(w8);
          
        },
        ComponentTypeParam::TypeI32(e) => {
          *((ptr0 + 24) as *mut u8) = (6i32) as u8;
          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
          
        },
        ComponentTypeParam::TypeQuat(e) => {
          *((ptr0 + 24) as *mut u8) = (7i32) as u8;
          let super::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x9);
          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y9);
          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z9);
          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w9);
          
        },
        ComponentTypeParam::TypeString(e) => {
          *((ptr0 + 24) as *mut u8) = (8i32) as u8;
          let vec10 = e;
          let ptr10 = vec10.as_ptr() as i32;
          let len10 = vec10.len() as i32;
          *((ptr0 + 36) as *mut i32) = len10;
          *((ptr0 + 32) as *mut i32) = ptr10;
          
        },
        ComponentTypeParam::TypeU32(e) => {
          *((ptr0 + 24) as *mut u8) = (9i32) as u8;
          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
          
        },
        ComponentTypeParam::TypeU64(e) => {
          *((ptr0 + 24) as *mut u8) = (10i32) as u8;
          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
          
        },
        ComponentTypeParam::TypeVec2(e) => {
          *((ptr0 + 24) as *mut u8) = (11i32) as u8;
          let super::types::Vec2{ x:x11, y:y11, } = e;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x11);
          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y11);
          
        },
        ComponentTypeParam::TypeVec3(e) => {
          *((ptr0 + 24) as *mut u8) = (12i32) as u8;
          let super::types::Vec3{ x:x12, y:y12, z:z12, } = e;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x12);
          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y12);
          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z12);
          
        },
        ComponentTypeParam::TypeVec4(e) => {
          *((ptr0 + 24) as *mut u8) = (13i32) as u8;
          let super::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x13);
          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y13);
          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z13);
          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w13);
          
        },
        ComponentTypeParam::TypeUvec2(e) => {
          *((ptr0 + 24) as *mut u8) = (14i32) as u8;
          let super::types::Uvec2{ x:x14, y:y14, } = e;
          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x14);
          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y14);
          
        },
        ComponentTypeParam::TypeUvec3(e) => {
          *((ptr0 + 24) as *mut u8) = (15i32) as u8;
          let super::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x15);
          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y15);
          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z15);
          
        },
        ComponentTypeParam::TypeUvec4(e) => {
          *((ptr0 + 24) as *mut u8) = (16i32) as u8;
          let super::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x16);
          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y16);
          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z16);
          *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w16);
          
        },
        ComponentTypeParam::TypeList(e) => {
          *((ptr0 + 24) as *mut u8) = (17i32) as u8;
          match e {
            ComponentListTypeParam::TypeEmpty(e) => {
              *((ptr0 + 32) as *mut u8) = (0i32) as u8;
              let vec17 = e;
              let ptr17 = vec17.as_ptr() as i32;
              let len17 = vec17.len() as i32;
              *((ptr0 + 40) as *mut i32) = len17;
              *((ptr0 + 36) as *mut i32) = ptr17;
              
            },
            ComponentListTypeParam::TypeBool(e) => {
              *((ptr0 + 32) as *mut u8) = (1i32) as u8;
              let vec18 = e;
              let len18 = vec18.len() as i32;
              let layout18 = alloc::Layout::from_size_align_unchecked(vec18.len() * 1, 1);
              let result18 = if layout18.size() != 0
              {
                let ptr = alloc::alloc(layout18);
                if ptr.is_null()
                {
                  alloc::handle_alloc_error(layout18);
                }
                ptr
              }else {
                core::ptr::null_mut()
              };
              for (i, e) in vec18.into_iter().enumerate() {
                let base = result18 as i32 + (i as i32) * 1;
                {
                  *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                  
                }}
                *((ptr0 + 40) as *mut i32) = len18;
                *((ptr0 + 36) as *mut i32) = result18 as i32;
                cleanup_list.extend_from_slice(&[(result18, layout18),]);
                
              },
              ComponentListTypeParam::TypeEntityId(e) => {
                *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                let vec19 = e;
                let ptr19 = vec19.as_ptr() as i32;
                let len19 = vec19.len() as i32;
                *((ptr0 + 40) as *mut i32) = len19;
                *((ptr0 + 36) as *mut i32) = ptr19;
                
              },
              ComponentListTypeParam::TypeF32(e) => {
                *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                let vec20 = e;
                let ptr20 = vec20.as_ptr() as i32;
                let len20 = vec20.len() as i32;
                *((ptr0 + 40) as *mut i32) = len20;
                *((ptr0 + 36) as *mut i32) = ptr20;
                
              },
              ComponentListTypeParam::TypeF64(e) => {
                *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                let vec21 = e;
                let ptr21 = vec21.as_ptr() as i32;
                let len21 = vec21.len() as i32;
                *((ptr0 + 40) as *mut i32) = len21;
                *((ptr0 + 36) as *mut i32) = ptr21;
                
              },
              ComponentListTypeParam::TypeMat4(e) => {
                *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                let vec22 = e;
                let ptr22 = vec22.as_ptr() as i32;
                let len22 = vec22.len() as i32;
                *((ptr0 + 40) as *mut i32) = len22;
                *((ptr0 + 36) as *mut i32) = ptr22;
                
              },
              ComponentListTypeParam::TypeI32(e) => {
                *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                let vec23 = e;
                let ptr23 = vec23.as_ptr() as i32;
                let len23 = vec23.len() as i32;
                *((ptr0 + 40) as *mut i32) = len23;
                *((ptr0 + 36) as *mut i32) = ptr23;
                
              },
              ComponentListTypeParam::TypeQuat(e) => {
                *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                let vec24 = e;
                let ptr24 = vec24.as_ptr() as i32;
                let len24 = vec24.len() as i32;
                *((ptr0 + 40) as *mut i32) = len24;
                *((ptr0 + 36) as *mut i32) = ptr24;
                
              },
              ComponentListTypeParam::TypeString(e) => {
                *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                let vec26 = e;
                let len26 = vec26.len() as i32;
                let layout26 = alloc::Layout::from_size_align_unchecked(vec26.len() * 8, 4);
                let result26 = if layout26.size() != 0
                {
                  let ptr = alloc::alloc(layout26);
                  if ptr.is_null()
                  {
                    alloc::handle_alloc_error(layout26);
                  }
                  ptr
                }else {
                  core::ptr::null_mut()
                };
                for (i, e) in vec26.into_iter().enumerate() {
                  let base = result26 as i32 + (i as i32) * 8;
                  {
                    let vec25 = e;
                    let ptr25 = vec25.as_ptr() as i32;
                    let len25 = vec25.len() as i32;
                    *((base + 4) as *mut i32) = len25;
                    *((base + 0) as *mut i32) = ptr25;
                    
                  }}
                  *((ptr0 + 40) as *mut i32) = len26;
                  *((ptr0 + 36) as *mut i32) = result26 as i32;
                  cleanup_list.extend_from_slice(&[(result26, layout26),]);
                  
                },
                ComponentListTypeParam::TypeU32(e) => {
                  *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                  let vec27 = e;
                  let ptr27 = vec27.as_ptr() as i32;
                  let len27 = vec27.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len27;
                  *((ptr0 + 36) as *mut i32) = ptr27;
                  
                },
                ComponentListTypeParam::TypeU64(e) => {
                  *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                  let vec28 = e;
                  let ptr28 = vec28.as_ptr() as i32;
                  let len28 = vec28.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len28;
                  *((ptr0 + 36) as *mut i32) = ptr28;
                  
                },
                ComponentListTypeParam::TypeVec2(e) => {
                  *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                  let vec29 = e;
                  let ptr29 = vec29.as_ptr() as i32;
                  let len29 = vec29.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len29;
                  *((ptr0 + 36) as *mut i32) = ptr29;
                  
                },
                ComponentListTypeParam::TypeVec3(e) => {
                  *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                  let vec30 = e;
                  let ptr30 = vec30.as_ptr() as i32;
                  let len30 = vec30.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len30;
                  *((ptr0 + 36) as *mut i32) = ptr30;
                  
                },
                ComponentListTypeParam::TypeVec4(e) => {
                  *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                  let vec31 = e;
                  let ptr31 = vec31.as_ptr() as i32;
                  let len31 = vec31.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len31;
                  *((ptr0 + 36) as *mut i32) = ptr31;
                  
                },
                ComponentListTypeParam::TypeUvec2(e) => {
                  *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                  let vec32 = e;
                  let ptr32 = vec32.as_ptr() as i32;
                  let len32 = vec32.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len32;
                  *((ptr0 + 36) as *mut i32) = ptr32;
                  
                },
                ComponentListTypeParam::TypeUvec3(e) => {
                  *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                  let vec33 = e;
                  let ptr33 = vec33.as_ptr() as i32;
                  let len33 = vec33.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len33;
                  *((ptr0 + 36) as *mut i32) = ptr33;
                  
                },
                ComponentListTypeParam::TypeUvec4(e) => {
                  *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                  let vec34 = e;
                  let ptr34 = vec34.as_ptr() as i32;
                  let len34 = vec34.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len34;
                  *((ptr0 + 36) as *mut i32) = ptr34;
                  
                },
              };
              
            },
            ComponentTypeParam::TypeOption(e) => {
              *((ptr0 + 24) as *mut u8) = (18i32) as u8;
              match e {
                ComponentOptionTypeParam::TypeEmpty(e) => {
                  *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let () = e;
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeBool(e) => {
                  *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 41) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeEntityId(e) => {
                  *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::EntityId{ id0:id036, id1:id136, } = e;
                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(id036);
                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(id136);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeF32(e) => {
                  *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(e);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeF64(e) => {
                  *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 48) as *mut f64) = wit_bindgen::rt::as_f64(e);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeMat4(e) => {
                  *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Mat4{ x:x37, y:y37, z:z37, w:w37, } = e;
                      let super::types::Vec4{ x:x38, y:y38, z:z38, w:w38, } = x37;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x38);
                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y38);
                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z38);
                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w38);
                      let super::types::Vec4{ x:x39, y:y39, z:z39, w:w39, } = y37;
                      *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(x39);
                      *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(y39);
                      *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(z39);
                      *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(w39);
                      let super::types::Vec4{ x:x40, y:y40, z:z40, w:w40, } = z37;
                      *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(x40);
                      *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(y40);
                      *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(z40);
                      *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(w40);
                      let super::types::Vec4{ x:x41, y:y41, z:z41, w:w41, } = w37;
                      *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(x41);
                      *((ptr0 + 96) as *mut f32) = wit_bindgen::rt::as_f32(y41);
                      *((ptr0 + 100) as *mut f32) = wit_bindgen::rt::as_f32(z41);
                      *((ptr0 + 104) as *mut f32) = wit_bindgen::rt::as_f32(w41);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeI32(e) => {
                  *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeQuat(e) => {
                  *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Quat{ x:x42, y:y42, z:z42, w:w42, } = e;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x42);
                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y42);
                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z42);
                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w42);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeString(e) => {
                  *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let vec43 = e;
                      let ptr43 = vec43.as_ptr() as i32;
                      let len43 = vec43.len() as i32;
                      *((ptr0 + 48) as *mut i32) = len43;
                      *((ptr0 + 44) as *mut i32) = ptr43;
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeU32(e) => {
                  *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeU64(e) => {
                  *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeVec2(e) => {
                  *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Vec2{ x:x44, y:y44, } = e;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x44);
                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y44);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeVec3(e) => {
                  *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Vec3{ x:x45, y:y45, z:z45, } = e;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x45);
                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y45);
                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z45);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeVec4(e) => {
                  *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Vec4{ x:x46, y:y46, z:z46, w:w46, } = e;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x46);
                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y46);
                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z46);
                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w46);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeUvec2(e) => {
                  *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Uvec2{ x:x47, y:y47, } = e;
                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x47);
                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y47);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeUvec3(e) => {
                  *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Uvec3{ x:x48, y:y48, z:z48, } = e;
                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x48);
                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y48);
                      *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z48);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeUvec4(e) => {
                  *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Uvec4{ x:x49, y:y49, z:z49, w:w49, } = e;
                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x49);
                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y49);
                      *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z49);
                      *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w49);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
              };
              
            },
          };
          
          #[link(wasm_import_module = "component")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "add-component")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_add-component")]
            fn wit_import(
            _: i32, );
          }
          wit_import(ptr0);
          for (ptr, layout) in cleanup_list {
            
            if layout.size() != 0 {
              
              alloc::dealloc(ptr, layout);
              
            }
            
          }
        }
      }
      #[allow(clippy::all)]
      pub fn add_components(entity: EntityId,data: Entity<'_,>,){
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
        unsafe {
          let mut cleanup_list = Vec::new();
          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
          let vec50 = data;
          let len50 = vec50.len() as i32;
          let layout50 = alloc::Layout::from_size_align_unchecked(vec50.len() * 96, 8);
          let result50 = if layout50.size() != 0
          {
            let ptr = alloc::alloc(layout50);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout50);
            }
            ptr
          }else {
            core::ptr::null_mut()
          };
          for (i, e) in vec50.into_iter().enumerate() {
            let base = result50 as i32 + (i as i32) * 96;
            {
              let (t1_0, t1_1, ) = e;
              *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t1_0);
              match t1_1 {
                ComponentTypeParam::TypeEmpty(e) => {
                  *((base + 8) as *mut u8) = (0i32) as u8;
                  let () = e;
                  
                },
                ComponentTypeParam::TypeBool(e) => {
                  *((base + 8) as *mut u8) = (1i32) as u8;
                  *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                  
                },
                ComponentTypeParam::TypeEntityId(e) => {
                  *((base + 8) as *mut u8) = (2i32) as u8;
                  let super::types::EntityId{ id0:id03, id1:id13, } = e;
                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id03);
                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id13);
                  
                },
                ComponentTypeParam::TypeF32(e) => {
                  *((base + 8) as *mut u8) = (3i32) as u8;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                  
                },
                ComponentTypeParam::TypeF64(e) => {
                  *((base + 8) as *mut u8) = (4i32) as u8;
                  *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                  
                },
                ComponentTypeParam::TypeMat4(e) => {
                  *((base + 8) as *mut u8) = (5i32) as u8;
                  let super::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
                  let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                  let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
                  *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                  *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                  *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                  *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                  let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
                  *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                  *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                  *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                  *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                  let super::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
                  *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                  *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                  *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                  *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                  
                },
                ComponentTypeParam::TypeI32(e) => {
                  *((base + 8) as *mut u8) = (6i32) as u8;
                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                  
                },
                ComponentTypeParam::TypeQuat(e) => {
                  *((base + 8) as *mut u8) = (7i32) as u8;
                  let super::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                  
                },
                ComponentTypeParam::TypeString(e) => {
                  *((base + 8) as *mut u8) = (8i32) as u8;
                  let vec10 = e;
                  let ptr10 = vec10.as_ptr() as i32;
                  let len10 = vec10.len() as i32;
                  *((base + 20) as *mut i32) = len10;
                  *((base + 16) as *mut i32) = ptr10;
                  
                },
                ComponentTypeParam::TypeU32(e) => {
                  *((base + 8) as *mut u8) = (9i32) as u8;
                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                  
                },
                ComponentTypeParam::TypeU64(e) => {
                  *((base + 8) as *mut u8) = (10i32) as u8;
                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                  
                },
                ComponentTypeParam::TypeVec2(e) => {
                  *((base + 8) as *mut u8) = (11i32) as u8;
                  let super::types::Vec2{ x:x11, y:y11, } = e;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                  
                },
                ComponentTypeParam::TypeVec3(e) => {
                  *((base + 8) as *mut u8) = (12i32) as u8;
                  let super::types::Vec3{ x:x12, y:y12, z:z12, } = e;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                  
                },
                ComponentTypeParam::TypeVec4(e) => {
                  *((base + 8) as *mut u8) = (13i32) as u8;
                  let super::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x13);
                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y13);
                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z13);
                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w13);
                  
                },
                ComponentTypeParam::TypeUvec2(e) => {
                  *((base + 8) as *mut u8) = (14i32) as u8;
                  let super::types::Uvec2{ x:x14, y:y14, } = e;
                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                  
                },
                ComponentTypeParam::TypeUvec3(e) => {
                  *((base + 8) as *mut u8) = (15i32) as u8;
                  let super::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                  
                },
                ComponentTypeParam::TypeUvec4(e) => {
                  *((base + 8) as *mut u8) = (16i32) as u8;
                  let super::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z16);
                  *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w16);
                  
                },
                ComponentTypeParam::TypeList(e) => {
                  *((base + 8) as *mut u8) = (17i32) as u8;
                  match e {
                    ComponentListTypeParam::TypeEmpty(e) => {
                      *((base + 16) as *mut u8) = (0i32) as u8;
                      let vec17 = e;
                      let ptr17 = vec17.as_ptr() as i32;
                      let len17 = vec17.len() as i32;
                      *((base + 24) as *mut i32) = len17;
                      *((base + 20) as *mut i32) = ptr17;
                      
                    },
                    ComponentListTypeParam::TypeBool(e) => {
                      *((base + 16) as *mut u8) = (1i32) as u8;
                      let vec18 = e;
                      let len18 = vec18.len() as i32;
                      let layout18 = alloc::Layout::from_size_align_unchecked(vec18.len() * 1, 1);
                      let result18 = if layout18.size() != 0
                      {
                        let ptr = alloc::alloc(layout18);
                        if ptr.is_null()
                        {
                          alloc::handle_alloc_error(layout18);
                        }
                        ptr
                      }else {
                        core::ptr::null_mut()
                      };
                      for (i, e) in vec18.into_iter().enumerate() {
                        let base = result18 as i32 + (i as i32) * 1;
                        {
                          *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                          
                        }}
                        *((base + 24) as *mut i32) = len18;
                        *((base + 20) as *mut i32) = result18 as i32;
                        cleanup_list.extend_from_slice(&[(result18, layout18),]);
                        
                      },
                      ComponentListTypeParam::TypeEntityId(e) => {
                        *((base + 16) as *mut u8) = (2i32) as u8;
                        let vec19 = e;
                        let ptr19 = vec19.as_ptr() as i32;
                        let len19 = vec19.len() as i32;
                        *((base + 24) as *mut i32) = len19;
                        *((base + 20) as *mut i32) = ptr19;
                        
                      },
                      ComponentListTypeParam::TypeF32(e) => {
                        *((base + 16) as *mut u8) = (3i32) as u8;
                        let vec20 = e;
                        let ptr20 = vec20.as_ptr() as i32;
                        let len20 = vec20.len() as i32;
                        *((base + 24) as *mut i32) = len20;
                        *((base + 20) as *mut i32) = ptr20;
                        
                      },
                      ComponentListTypeParam::TypeF64(e) => {
                        *((base + 16) as *mut u8) = (4i32) as u8;
                        let vec21 = e;
                        let ptr21 = vec21.as_ptr() as i32;
                        let len21 = vec21.len() as i32;
                        *((base + 24) as *mut i32) = len21;
                        *((base + 20) as *mut i32) = ptr21;
                        
                      },
                      ComponentListTypeParam::TypeMat4(e) => {
                        *((base + 16) as *mut u8) = (5i32) as u8;
                        let vec22 = e;
                        let ptr22 = vec22.as_ptr() as i32;
                        let len22 = vec22.len() as i32;
                        *((base + 24) as *mut i32) = len22;
                        *((base + 20) as *mut i32) = ptr22;
                        
                      },
                      ComponentListTypeParam::TypeI32(e) => {
                        *((base + 16) as *mut u8) = (6i32) as u8;
                        let vec23 = e;
                        let ptr23 = vec23.as_ptr() as i32;
                        let len23 = vec23.len() as i32;
                        *((base + 24) as *mut i32) = len23;
                        *((base + 20) as *mut i32) = ptr23;
                        
                      },
                      ComponentListTypeParam::TypeQuat(e) => {
                        *((base + 16) as *mut u8) = (7i32) as u8;
                        let vec24 = e;
                        let ptr24 = vec24.as_ptr() as i32;
                        let len24 = vec24.len() as i32;
                        *((base + 24) as *mut i32) = len24;
                        *((base + 20) as *mut i32) = ptr24;
                        
                      },
                      ComponentListTypeParam::TypeString(e) => {
                        *((base + 16) as *mut u8) = (8i32) as u8;
                        let vec26 = e;
                        let len26 = vec26.len() as i32;
                        let layout26 = alloc::Layout::from_size_align_unchecked(vec26.len() * 8, 4);
                        let result26 = if layout26.size() != 0
                        {
                          let ptr = alloc::alloc(layout26);
                          if ptr.is_null()
                          {
                            alloc::handle_alloc_error(layout26);
                          }
                          ptr
                        }else {
                          core::ptr::null_mut()
                        };
                        for (i, e) in vec26.into_iter().enumerate() {
                          let base = result26 as i32 + (i as i32) * 8;
                          {
                            let vec25 = e;
                            let ptr25 = vec25.as_ptr() as i32;
                            let len25 = vec25.len() as i32;
                            *((base + 4) as *mut i32) = len25;
                            *((base + 0) as *mut i32) = ptr25;
                            
                          }}
                          *((base + 24) as *mut i32) = len26;
                          *((base + 20) as *mut i32) = result26 as i32;
                          cleanup_list.extend_from_slice(&[(result26, layout26),]);
                          
                        },
                        ComponentListTypeParam::TypeU32(e) => {
                          *((base + 16) as *mut u8) = (9i32) as u8;
                          let vec27 = e;
                          let ptr27 = vec27.as_ptr() as i32;
                          let len27 = vec27.len() as i32;
                          *((base + 24) as *mut i32) = len27;
                          *((base + 20) as *mut i32) = ptr27;
                          
                        },
                        ComponentListTypeParam::TypeU64(e) => {
                          *((base + 16) as *mut u8) = (10i32) as u8;
                          let vec28 = e;
                          let ptr28 = vec28.as_ptr() as i32;
                          let len28 = vec28.len() as i32;
                          *((base + 24) as *mut i32) = len28;
                          *((base + 20) as *mut i32) = ptr28;
                          
                        },
                        ComponentListTypeParam::TypeVec2(e) => {
                          *((base + 16) as *mut u8) = (11i32) as u8;
                          let vec29 = e;
                          let ptr29 = vec29.as_ptr() as i32;
                          let len29 = vec29.len() as i32;
                          *((base + 24) as *mut i32) = len29;
                          *((base + 20) as *mut i32) = ptr29;
                          
                        },
                        ComponentListTypeParam::TypeVec3(e) => {
                          *((base + 16) as *mut u8) = (12i32) as u8;
                          let vec30 = e;
                          let ptr30 = vec30.as_ptr() as i32;
                          let len30 = vec30.len() as i32;
                          *((base + 24) as *mut i32) = len30;
                          *((base + 20) as *mut i32) = ptr30;
                          
                        },
                        ComponentListTypeParam::TypeVec4(e) => {
                          *((base + 16) as *mut u8) = (13i32) as u8;
                          let vec31 = e;
                          let ptr31 = vec31.as_ptr() as i32;
                          let len31 = vec31.len() as i32;
                          *((base + 24) as *mut i32) = len31;
                          *((base + 20) as *mut i32) = ptr31;
                          
                        },
                        ComponentListTypeParam::TypeUvec2(e) => {
                          *((base + 16) as *mut u8) = (14i32) as u8;
                          let vec32 = e;
                          let ptr32 = vec32.as_ptr() as i32;
                          let len32 = vec32.len() as i32;
                          *((base + 24) as *mut i32) = len32;
                          *((base + 20) as *mut i32) = ptr32;
                          
                        },
                        ComponentListTypeParam::TypeUvec3(e) => {
                          *((base + 16) as *mut u8) = (15i32) as u8;
                          let vec33 = e;
                          let ptr33 = vec33.as_ptr() as i32;
                          let len33 = vec33.len() as i32;
                          *((base + 24) as *mut i32) = len33;
                          *((base + 20) as *mut i32) = ptr33;
                          
                        },
                        ComponentListTypeParam::TypeUvec4(e) => {
                          *((base + 16) as *mut u8) = (16i32) as u8;
                          let vec34 = e;
                          let ptr34 = vec34.as_ptr() as i32;
                          let len34 = vec34.len() as i32;
                          *((base + 24) as *mut i32) = len34;
                          *((base + 20) as *mut i32) = ptr34;
                          
                        },
                      };
                      
                    },
                    ComponentTypeParam::TypeOption(e) => {
                      *((base + 8) as *mut u8) = (18i32) as u8;
                      match e {
                        ComponentOptionTypeParam::TypeEmpty(e) => {
                          *((base + 16) as *mut u8) = (0i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let () = e;
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeBool(e) => {
                          *((base + 16) as *mut u8) = (1i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeEntityId(e) => {
                          *((base + 16) as *mut u8) = (2i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::EntityId{ id0:id036, id1:id136, } = e;
                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id036);
                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id136);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeF32(e) => {
                          *((base + 16) as *mut u8) = (3i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeF64(e) => {
                          *((base + 16) as *mut u8) = (4i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeMat4(e) => {
                          *((base + 16) as *mut u8) = (5i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Mat4{ x:x37, y:y37, z:z37, w:w37, } = e;
                              let super::types::Vec4{ x:x38, y:y38, z:z38, w:w38, } = x37;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x38);
                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y38);
                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z38);
                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w38);
                              let super::types::Vec4{ x:x39, y:y39, z:z39, w:w39, } = y37;
                              *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x39);
                              *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y39);
                              *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z39);
                              *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w39);
                              let super::types::Vec4{ x:x40, y:y40, z:z40, w:w40, } = z37;
                              *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x40);
                              *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y40);
                              *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z40);
                              *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w40);
                              let super::types::Vec4{ x:x41, y:y41, z:z41, w:w41, } = w37;
                              *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x41);
                              *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y41);
                              *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z41);
                              *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w41);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeI32(e) => {
                          *((base + 16) as *mut u8) = (6i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeQuat(e) => {
                          *((base + 16) as *mut u8) = (7i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Quat{ x:x42, y:y42, z:z42, w:w42, } = e;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x42);
                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y42);
                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z42);
                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w42);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeString(e) => {
                          *((base + 16) as *mut u8) = (8i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let vec43 = e;
                              let ptr43 = vec43.as_ptr() as i32;
                              let len43 = vec43.len() as i32;
                              *((base + 32) as *mut i32) = len43;
                              *((base + 28) as *mut i32) = ptr43;
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeU32(e) => {
                          *((base + 16) as *mut u8) = (9i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeU64(e) => {
                          *((base + 16) as *mut u8) = (10i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeVec2(e) => {
                          *((base + 16) as *mut u8) = (11i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Vec2{ x:x44, y:y44, } = e;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x44);
                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y44);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeVec3(e) => {
                          *((base + 16) as *mut u8) = (12i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Vec3{ x:x45, y:y45, z:z45, } = e;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x45);
                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y45);
                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z45);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeVec4(e) => {
                          *((base + 16) as *mut u8) = (13i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Vec4{ x:x46, y:y46, z:z46, w:w46, } = e;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x46);
                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y46);
                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z46);
                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w46);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeUvec2(e) => {
                          *((base + 16) as *mut u8) = (14i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Uvec2{ x:x47, y:y47, } = e;
                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x47);
                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y47);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeUvec3(e) => {
                          *((base + 16) as *mut u8) = (15i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Uvec3{ x:x48, y:y48, z:z48, } = e;
                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x48);
                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y48);
                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z48);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        ComponentOptionTypeParam::TypeUvec4(e) => {
                          *((base + 16) as *mut u8) = (16i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Uvec4{ x:x49, y:y49, z:z49, w:w49, } = e;
                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x49);
                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y49);
                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z49);
                              *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w49);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                      };
                      
                    },
                  };
                  
                }}
                
                #[link(wasm_import_module = "component")]
                extern "C" {
                  #[cfg_attr(target_arch = "wasm32", link_name = "add-components")]
                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_add-components")]
                  fn wit_import(
                  _: i64, _: i64, _: i32, _: i32, );
                }
                wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result50 as i32, len50);
                if layout50.size() != 0 {
                  alloc::dealloc(result50, layout50);
                }
                for (ptr, layout) in cleanup_list {
                  
                  if layout.size() != 0 {
                    
                    alloc::dealloc(ptr, layout);
                    
                  }
                  
                }
              }
            }
            #[allow(clippy::all)]
            pub fn set_component(entity: EntityId,index: u32,value: ComponentTypeParam<'_,>,){
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
              unsafe {
                let mut cleanup_list = Vec::new();
                
                #[repr(align(8))]
                struct RetArea([u8; 112]);
                let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                let ptr0 = ret_area.as_mut_ptr() as i32;let super::types::EntityId{ id0:id01, id1:id11, } = entity;
                *((ptr0 + 0) as *mut i64) = wit_bindgen::rt::as_i64(id01);
                *((ptr0 + 8) as *mut i64) = wit_bindgen::rt::as_i64(id11);
                *((ptr0 + 16) as *mut i32) = wit_bindgen::rt::as_i32(index);
                match value {
                  ComponentTypeParam::TypeEmpty(e) => {
                    *((ptr0 + 24) as *mut u8) = (0i32) as u8;
                    let () = e;
                    
                  },
                  ComponentTypeParam::TypeBool(e) => {
                    *((ptr0 + 24) as *mut u8) = (1i32) as u8;
                    *((ptr0 + 32) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                    
                  },
                  ComponentTypeParam::TypeEntityId(e) => {
                    *((ptr0 + 24) as *mut u8) = (2i32) as u8;
                    let super::types::EntityId{ id0:id03, id1:id13, } = e;
                    *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(id03);
                    *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(id13);
                    
                  },
                  ComponentTypeParam::TypeF32(e) => {
                    *((ptr0 + 24) as *mut u8) = (3i32) as u8;
                    *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(e);
                    
                  },
                  ComponentTypeParam::TypeF64(e) => {
                    *((ptr0 + 24) as *mut u8) = (4i32) as u8;
                    *((ptr0 + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                    
                  },
                  ComponentTypeParam::TypeMat4(e) => {
                    *((ptr0 + 24) as *mut u8) = (5i32) as u8;
                    let super::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
                    let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
                    *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                    *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                    *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                    *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                    let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
                    *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                    *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                    *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                    *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                    let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
                    *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                    *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                    *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                    *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                    let super::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
                    *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                    *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                    *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                    *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                    
                  },
                  ComponentTypeParam::TypeI32(e) => {
                    *((ptr0 + 24) as *mut u8) = (6i32) as u8;
                    *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                    
                  },
                  ComponentTypeParam::TypeQuat(e) => {
                    *((ptr0 + 24) as *mut u8) = (7i32) as u8;
                    let super::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
                    *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                    *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                    *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                    *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                    
                  },
                  ComponentTypeParam::TypeString(e) => {
                    *((ptr0 + 24) as *mut u8) = (8i32) as u8;
                    let vec10 = e;
                    let ptr10 = vec10.as_ptr() as i32;
                    let len10 = vec10.len() as i32;
                    *((ptr0 + 36) as *mut i32) = len10;
                    *((ptr0 + 32) as *mut i32) = ptr10;
                    
                  },
                  ComponentTypeParam::TypeU32(e) => {
                    *((ptr0 + 24) as *mut u8) = (9i32) as u8;
                    *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                    
                  },
                  ComponentTypeParam::TypeU64(e) => {
                    *((ptr0 + 24) as *mut u8) = (10i32) as u8;
                    *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                    
                  },
                  ComponentTypeParam::TypeVec2(e) => {
                    *((ptr0 + 24) as *mut u8) = (11i32) as u8;
                    let super::types::Vec2{ x:x11, y:y11, } = e;
                    *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                    *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                    
                  },
                  ComponentTypeParam::TypeVec3(e) => {
                    *((ptr0 + 24) as *mut u8) = (12i32) as u8;
                    let super::types::Vec3{ x:x12, y:y12, z:z12, } = e;
                    *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                    *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                    *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                    
                  },
                  ComponentTypeParam::TypeVec4(e) => {
                    *((ptr0 + 24) as *mut u8) = (13i32) as u8;
                    let super::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
                    *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x13);
                    *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y13);
                    *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z13);
                    *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w13);
                    
                  },
                  ComponentTypeParam::TypeUvec2(e) => {
                    *((ptr0 + 24) as *mut u8) = (14i32) as u8;
                    let super::types::Uvec2{ x:x14, y:y14, } = e;
                    *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                    *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                    
                  },
                  ComponentTypeParam::TypeUvec3(e) => {
                    *((ptr0 + 24) as *mut u8) = (15i32) as u8;
                    let super::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
                    *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                    *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                    *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                    
                  },
                  ComponentTypeParam::TypeUvec4(e) => {
                    *((ptr0 + 24) as *mut u8) = (16i32) as u8;
                    let super::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
                    *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                    *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                    *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z16);
                    *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w16);
                    
                  },
                  ComponentTypeParam::TypeList(e) => {
                    *((ptr0 + 24) as *mut u8) = (17i32) as u8;
                    match e {
                      ComponentListTypeParam::TypeEmpty(e) => {
                        *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                        let vec17 = e;
                        let ptr17 = vec17.as_ptr() as i32;
                        let len17 = vec17.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len17;
                        *((ptr0 + 36) as *mut i32) = ptr17;
                        
                      },
                      ComponentListTypeParam::TypeBool(e) => {
                        *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                        let vec18 = e;
                        let len18 = vec18.len() as i32;
                        let layout18 = alloc::Layout::from_size_align_unchecked(vec18.len() * 1, 1);
                        let result18 = if layout18.size() != 0
                        {
                          let ptr = alloc::alloc(layout18);
                          if ptr.is_null()
                          {
                            alloc::handle_alloc_error(layout18);
                          }
                          ptr
                        }else {
                          core::ptr::null_mut()
                        };
                        for (i, e) in vec18.into_iter().enumerate() {
                          let base = result18 as i32 + (i as i32) * 1;
                          {
                            *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                            
                          }}
                          *((ptr0 + 40) as *mut i32) = len18;
                          *((ptr0 + 36) as *mut i32) = result18 as i32;
                          cleanup_list.extend_from_slice(&[(result18, layout18),]);
                          
                        },
                        ComponentListTypeParam::TypeEntityId(e) => {
                          *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                          let vec19 = e;
                          let ptr19 = vec19.as_ptr() as i32;
                          let len19 = vec19.len() as i32;
                          *((ptr0 + 40) as *mut i32) = len19;
                          *((ptr0 + 36) as *mut i32) = ptr19;
                          
                        },
                        ComponentListTypeParam::TypeF32(e) => {
                          *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                          let vec20 = e;
                          let ptr20 = vec20.as_ptr() as i32;
                          let len20 = vec20.len() as i32;
                          *((ptr0 + 40) as *mut i32) = len20;
                          *((ptr0 + 36) as *mut i32) = ptr20;
                          
                        },
                        ComponentListTypeParam::TypeF64(e) => {
                          *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                          let vec21 = e;
                          let ptr21 = vec21.as_ptr() as i32;
                          let len21 = vec21.len() as i32;
                          *((ptr0 + 40) as *mut i32) = len21;
                          *((ptr0 + 36) as *mut i32) = ptr21;
                          
                        },
                        ComponentListTypeParam::TypeMat4(e) => {
                          *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                          let vec22 = e;
                          let ptr22 = vec22.as_ptr() as i32;
                          let len22 = vec22.len() as i32;
                          *((ptr0 + 40) as *mut i32) = len22;
                          *((ptr0 + 36) as *mut i32) = ptr22;
                          
                        },
                        ComponentListTypeParam::TypeI32(e) => {
                          *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                          let vec23 = e;
                          let ptr23 = vec23.as_ptr() as i32;
                          let len23 = vec23.len() as i32;
                          *((ptr0 + 40) as *mut i32) = len23;
                          *((ptr0 + 36) as *mut i32) = ptr23;
                          
                        },
                        ComponentListTypeParam::TypeQuat(e) => {
                          *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                          let vec24 = e;
                          let ptr24 = vec24.as_ptr() as i32;
                          let len24 = vec24.len() as i32;
                          *((ptr0 + 40) as *mut i32) = len24;
                          *((ptr0 + 36) as *mut i32) = ptr24;
                          
                        },
                        ComponentListTypeParam::TypeString(e) => {
                          *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                          let vec26 = e;
                          let len26 = vec26.len() as i32;
                          let layout26 = alloc::Layout::from_size_align_unchecked(vec26.len() * 8, 4);
                          let result26 = if layout26.size() != 0
                          {
                            let ptr = alloc::alloc(layout26);
                            if ptr.is_null()
                            {
                              alloc::handle_alloc_error(layout26);
                            }
                            ptr
                          }else {
                            core::ptr::null_mut()
                          };
                          for (i, e) in vec26.into_iter().enumerate() {
                            let base = result26 as i32 + (i as i32) * 8;
                            {
                              let vec25 = e;
                              let ptr25 = vec25.as_ptr() as i32;
                              let len25 = vec25.len() as i32;
                              *((base + 4) as *mut i32) = len25;
                              *((base + 0) as *mut i32) = ptr25;
                              
                            }}
                            *((ptr0 + 40) as *mut i32) = len26;
                            *((ptr0 + 36) as *mut i32) = result26 as i32;
                            cleanup_list.extend_from_slice(&[(result26, layout26),]);
                            
                          },
                          ComponentListTypeParam::TypeU32(e) => {
                            *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                            let vec27 = e;
                            let ptr27 = vec27.as_ptr() as i32;
                            let len27 = vec27.len() as i32;
                            *((ptr0 + 40) as *mut i32) = len27;
                            *((ptr0 + 36) as *mut i32) = ptr27;
                            
                          },
                          ComponentListTypeParam::TypeU64(e) => {
                            *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                            let vec28 = e;
                            let ptr28 = vec28.as_ptr() as i32;
                            let len28 = vec28.len() as i32;
                            *((ptr0 + 40) as *mut i32) = len28;
                            *((ptr0 + 36) as *mut i32) = ptr28;
                            
                          },
                          ComponentListTypeParam::TypeVec2(e) => {
                            *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                            let vec29 = e;
                            let ptr29 = vec29.as_ptr() as i32;
                            let len29 = vec29.len() as i32;
                            *((ptr0 + 40) as *mut i32) = len29;
                            *((ptr0 + 36) as *mut i32) = ptr29;
                            
                          },
                          ComponentListTypeParam::TypeVec3(e) => {
                            *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                            let vec30 = e;
                            let ptr30 = vec30.as_ptr() as i32;
                            let len30 = vec30.len() as i32;
                            *((ptr0 + 40) as *mut i32) = len30;
                            *((ptr0 + 36) as *mut i32) = ptr30;
                            
                          },
                          ComponentListTypeParam::TypeVec4(e) => {
                            *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                            let vec31 = e;
                            let ptr31 = vec31.as_ptr() as i32;
                            let len31 = vec31.len() as i32;
                            *((ptr0 + 40) as *mut i32) = len31;
                            *((ptr0 + 36) as *mut i32) = ptr31;
                            
                          },
                          ComponentListTypeParam::TypeUvec2(e) => {
                            *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                            let vec32 = e;
                            let ptr32 = vec32.as_ptr() as i32;
                            let len32 = vec32.len() as i32;
                            *((ptr0 + 40) as *mut i32) = len32;
                            *((ptr0 + 36) as *mut i32) = ptr32;
                            
                          },
                          ComponentListTypeParam::TypeUvec3(e) => {
                            *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                            let vec33 = e;
                            let ptr33 = vec33.as_ptr() as i32;
                            let len33 = vec33.len() as i32;
                            *((ptr0 + 40) as *mut i32) = len33;
                            *((ptr0 + 36) as *mut i32) = ptr33;
                            
                          },
                          ComponentListTypeParam::TypeUvec4(e) => {
                            *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                            let vec34 = e;
                            let ptr34 = vec34.as_ptr() as i32;
                            let len34 = vec34.len() as i32;
                            *((ptr0 + 40) as *mut i32) = len34;
                            *((ptr0 + 36) as *mut i32) = ptr34;
                            
                          },
                        };
                        
                      },
                      ComponentTypeParam::TypeOption(e) => {
                        *((ptr0 + 24) as *mut u8) = (18i32) as u8;
                        match e {
                          ComponentOptionTypeParam::TypeEmpty(e) => {
                            *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                let () = e;
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeBool(e) => {
                            *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                *((ptr0 + 41) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeEntityId(e) => {
                            *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                let super::types::EntityId{ id0:id036, id1:id136, } = e;
                                *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(id036);
                                *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(id136);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeF32(e) => {
                            *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeF64(e) => {
                            *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                *((ptr0 + 48) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeMat4(e) => {
                            *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                let super::types::Mat4{ x:x37, y:y37, z:z37, w:w37, } = e;
                                let super::types::Vec4{ x:x38, y:y38, z:z38, w:w38, } = x37;
                                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x38);
                                *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y38);
                                *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z38);
                                *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w38);
                                let super::types::Vec4{ x:x39, y:y39, z:z39, w:w39, } = y37;
                                *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(x39);
                                *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(y39);
                                *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(z39);
                                *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(w39);
                                let super::types::Vec4{ x:x40, y:y40, z:z40, w:w40, } = z37;
                                *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(x40);
                                *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(y40);
                                *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(z40);
                                *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(w40);
                                let super::types::Vec4{ x:x41, y:y41, z:z41, w:w41, } = w37;
                                *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(x41);
                                *((ptr0 + 96) as *mut f32) = wit_bindgen::rt::as_f32(y41);
                                *((ptr0 + 100) as *mut f32) = wit_bindgen::rt::as_f32(z41);
                                *((ptr0 + 104) as *mut f32) = wit_bindgen::rt::as_f32(w41);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeI32(e) => {
                            *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeQuat(e) => {
                            *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                let super::types::Quat{ x:x42, y:y42, z:z42, w:w42, } = e;
                                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x42);
                                *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y42);
                                *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z42);
                                *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w42);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeString(e) => {
                            *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                let vec43 = e;
                                let ptr43 = vec43.as_ptr() as i32;
                                let len43 = vec43.len() as i32;
                                *((ptr0 + 48) as *mut i32) = len43;
                                *((ptr0 + 44) as *mut i32) = ptr43;
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeU32(e) => {
                            *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeU64(e) => {
                            *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeVec2(e) => {
                            *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                let super::types::Vec2{ x:x44, y:y44, } = e;
                                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x44);
                                *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y44);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeVec3(e) => {
                            *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                let super::types::Vec3{ x:x45, y:y45, z:z45, } = e;
                                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x45);
                                *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y45);
                                *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z45);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeVec4(e) => {
                            *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                let super::types::Vec4{ x:x46, y:y46, z:z46, w:w46, } = e;
                                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x46);
                                *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y46);
                                *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z46);
                                *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w46);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeUvec2(e) => {
                            *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                let super::types::Uvec2{ x:x47, y:y47, } = e;
                                *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x47);
                                *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y47);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeUvec3(e) => {
                            *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                let super::types::Uvec3{ x:x48, y:y48, z:z48, } = e;
                                *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x48);
                                *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y48);
                                *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z48);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                          ComponentOptionTypeParam::TypeUvec4(e) => {
                            *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                            match e {
                              Some(e) => {
                                *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                let super::types::Uvec4{ x:x49, y:y49, z:z49, w:w49, } = e;
                                *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x49);
                                *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y49);
                                *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z49);
                                *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w49);
                                
                              },
                              None => {
                                {
                                  *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                  
                                }
                              },
                            };
                          },
                        };
                        
                      },
                    };
                    
                    #[link(wasm_import_module = "component")]
                    extern "C" {
                      #[cfg_attr(target_arch = "wasm32", link_name = "set-component")]
                      #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_set-component")]
                      fn wit_import(
                      _: i32, );
                    }
                    wit_import(ptr0);
                    for (ptr, layout) in cleanup_list {
                      
                      if layout.size() != 0 {
                        
                        alloc::dealloc(ptr, layout);
                        
                      }
                      
                    }
                  }
                }
                #[allow(clippy::all)]
                pub fn set_components(entity: EntityId,data: Entity<'_,>,){
                  
                  #[allow(unused_imports)]
                  use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                  unsafe {
                    let mut cleanup_list = Vec::new();
                    let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                    let vec50 = data;
                    let len50 = vec50.len() as i32;
                    let layout50 = alloc::Layout::from_size_align_unchecked(vec50.len() * 96, 8);
                    let result50 = if layout50.size() != 0
                    {
                      let ptr = alloc::alloc(layout50);
                      if ptr.is_null()
                      {
                        alloc::handle_alloc_error(layout50);
                      }
                      ptr
                    }else {
                      core::ptr::null_mut()
                    };
                    for (i, e) in vec50.into_iter().enumerate() {
                      let base = result50 as i32 + (i as i32) * 96;
                      {
                        let (t1_0, t1_1, ) = e;
                        *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t1_0);
                        match t1_1 {
                          ComponentTypeParam::TypeEmpty(e) => {
                            *((base + 8) as *mut u8) = (0i32) as u8;
                            let () = e;
                            
                          },
                          ComponentTypeParam::TypeBool(e) => {
                            *((base + 8) as *mut u8) = (1i32) as u8;
                            *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                            
                          },
                          ComponentTypeParam::TypeEntityId(e) => {
                            *((base + 8) as *mut u8) = (2i32) as u8;
                            let super::types::EntityId{ id0:id03, id1:id13, } = e;
                            *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id03);
                            *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id13);
                            
                          },
                          ComponentTypeParam::TypeF32(e) => {
                            *((base + 8) as *mut u8) = (3i32) as u8;
                            *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                            
                          },
                          ComponentTypeParam::TypeF64(e) => {
                            *((base + 8) as *mut u8) = (4i32) as u8;
                            *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                            
                          },
                          ComponentTypeParam::TypeMat4(e) => {
                            *((base + 8) as *mut u8) = (5i32) as u8;
                            let super::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
                            let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
                            *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                            *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                            *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                            *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                            let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
                            *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                            *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                            *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                            *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                            let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
                            *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                            *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                            *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                            *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                            let super::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
                            *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                            *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                            *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                            *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                            
                          },
                          ComponentTypeParam::TypeI32(e) => {
                            *((base + 8) as *mut u8) = (6i32) as u8;
                            *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            
                          },
                          ComponentTypeParam::TypeQuat(e) => {
                            *((base + 8) as *mut u8) = (7i32) as u8;
                            let super::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
                            *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                            *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                            *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                            *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                            
                          },
                          ComponentTypeParam::TypeString(e) => {
                            *((base + 8) as *mut u8) = (8i32) as u8;
                            let vec10 = e;
                            let ptr10 = vec10.as_ptr() as i32;
                            let len10 = vec10.len() as i32;
                            *((base + 20) as *mut i32) = len10;
                            *((base + 16) as *mut i32) = ptr10;
                            
                          },
                          ComponentTypeParam::TypeU32(e) => {
                            *((base + 8) as *mut u8) = (9i32) as u8;
                            *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            
                          },
                          ComponentTypeParam::TypeU64(e) => {
                            *((base + 8) as *mut u8) = (10i32) as u8;
                            *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                            
                          },
                          ComponentTypeParam::TypeVec2(e) => {
                            *((base + 8) as *mut u8) = (11i32) as u8;
                            let super::types::Vec2{ x:x11, y:y11, } = e;
                            *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                            *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                            
                          },
                          ComponentTypeParam::TypeVec3(e) => {
                            *((base + 8) as *mut u8) = (12i32) as u8;
                            let super::types::Vec3{ x:x12, y:y12, z:z12, } = e;
                            *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                            *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                            *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                            
                          },
                          ComponentTypeParam::TypeVec4(e) => {
                            *((base + 8) as *mut u8) = (13i32) as u8;
                            let super::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
                            *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x13);
                            *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y13);
                            *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z13);
                            *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w13);
                            
                          },
                          ComponentTypeParam::TypeUvec2(e) => {
                            *((base + 8) as *mut u8) = (14i32) as u8;
                            let super::types::Uvec2{ x:x14, y:y14, } = e;
                            *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                            *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                            
                          },
                          ComponentTypeParam::TypeUvec3(e) => {
                            *((base + 8) as *mut u8) = (15i32) as u8;
                            let super::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
                            *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                            *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                            *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                            
                          },
                          ComponentTypeParam::TypeUvec4(e) => {
                            *((base + 8) as *mut u8) = (16i32) as u8;
                            let super::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
                            *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                            *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                            *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z16);
                            *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w16);
                            
                          },
                          ComponentTypeParam::TypeList(e) => {
                            *((base + 8) as *mut u8) = (17i32) as u8;
                            match e {
                              ComponentListTypeParam::TypeEmpty(e) => {
                                *((base + 16) as *mut u8) = (0i32) as u8;
                                let vec17 = e;
                                let ptr17 = vec17.as_ptr() as i32;
                                let len17 = vec17.len() as i32;
                                *((base + 24) as *mut i32) = len17;
                                *((base + 20) as *mut i32) = ptr17;
                                
                              },
                              ComponentListTypeParam::TypeBool(e) => {
                                *((base + 16) as *mut u8) = (1i32) as u8;
                                let vec18 = e;
                                let len18 = vec18.len() as i32;
                                let layout18 = alloc::Layout::from_size_align_unchecked(vec18.len() * 1, 1);
                                let result18 = if layout18.size() != 0
                                {
                                  let ptr = alloc::alloc(layout18);
                                  if ptr.is_null()
                                  {
                                    alloc::handle_alloc_error(layout18);
                                  }
                                  ptr
                                }else {
                                  core::ptr::null_mut()
                                };
                                for (i, e) in vec18.into_iter().enumerate() {
                                  let base = result18 as i32 + (i as i32) * 1;
                                  {
                                    *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                    
                                  }}
                                  *((base + 24) as *mut i32) = len18;
                                  *((base + 20) as *mut i32) = result18 as i32;
                                  cleanup_list.extend_from_slice(&[(result18, layout18),]);
                                  
                                },
                                ComponentListTypeParam::TypeEntityId(e) => {
                                  *((base + 16) as *mut u8) = (2i32) as u8;
                                  let vec19 = e;
                                  let ptr19 = vec19.as_ptr() as i32;
                                  let len19 = vec19.len() as i32;
                                  *((base + 24) as *mut i32) = len19;
                                  *((base + 20) as *mut i32) = ptr19;
                                  
                                },
                                ComponentListTypeParam::TypeF32(e) => {
                                  *((base + 16) as *mut u8) = (3i32) as u8;
                                  let vec20 = e;
                                  let ptr20 = vec20.as_ptr() as i32;
                                  let len20 = vec20.len() as i32;
                                  *((base + 24) as *mut i32) = len20;
                                  *((base + 20) as *mut i32) = ptr20;
                                  
                                },
                                ComponentListTypeParam::TypeF64(e) => {
                                  *((base + 16) as *mut u8) = (4i32) as u8;
                                  let vec21 = e;
                                  let ptr21 = vec21.as_ptr() as i32;
                                  let len21 = vec21.len() as i32;
                                  *((base + 24) as *mut i32) = len21;
                                  *((base + 20) as *mut i32) = ptr21;
                                  
                                },
                                ComponentListTypeParam::TypeMat4(e) => {
                                  *((base + 16) as *mut u8) = (5i32) as u8;
                                  let vec22 = e;
                                  let ptr22 = vec22.as_ptr() as i32;
                                  let len22 = vec22.len() as i32;
                                  *((base + 24) as *mut i32) = len22;
                                  *((base + 20) as *mut i32) = ptr22;
                                  
                                },
                                ComponentListTypeParam::TypeI32(e) => {
                                  *((base + 16) as *mut u8) = (6i32) as u8;
                                  let vec23 = e;
                                  let ptr23 = vec23.as_ptr() as i32;
                                  let len23 = vec23.len() as i32;
                                  *((base + 24) as *mut i32) = len23;
                                  *((base + 20) as *mut i32) = ptr23;
                                  
                                },
                                ComponentListTypeParam::TypeQuat(e) => {
                                  *((base + 16) as *mut u8) = (7i32) as u8;
                                  let vec24 = e;
                                  let ptr24 = vec24.as_ptr() as i32;
                                  let len24 = vec24.len() as i32;
                                  *((base + 24) as *mut i32) = len24;
                                  *((base + 20) as *mut i32) = ptr24;
                                  
                                },
                                ComponentListTypeParam::TypeString(e) => {
                                  *((base + 16) as *mut u8) = (8i32) as u8;
                                  let vec26 = e;
                                  let len26 = vec26.len() as i32;
                                  let layout26 = alloc::Layout::from_size_align_unchecked(vec26.len() * 8, 4);
                                  let result26 = if layout26.size() != 0
                                  {
                                    let ptr = alloc::alloc(layout26);
                                    if ptr.is_null()
                                    {
                                      alloc::handle_alloc_error(layout26);
                                    }
                                    ptr
                                  }else {
                                    core::ptr::null_mut()
                                  };
                                  for (i, e) in vec26.into_iter().enumerate() {
                                    let base = result26 as i32 + (i as i32) * 8;
                                    {
                                      let vec25 = e;
                                      let ptr25 = vec25.as_ptr() as i32;
                                      let len25 = vec25.len() as i32;
                                      *((base + 4) as *mut i32) = len25;
                                      *((base + 0) as *mut i32) = ptr25;
                                      
                                    }}
                                    *((base + 24) as *mut i32) = len26;
                                    *((base + 20) as *mut i32) = result26 as i32;
                                    cleanup_list.extend_from_slice(&[(result26, layout26),]);
                                    
                                  },
                                  ComponentListTypeParam::TypeU32(e) => {
                                    *((base + 16) as *mut u8) = (9i32) as u8;
                                    let vec27 = e;
                                    let ptr27 = vec27.as_ptr() as i32;
                                    let len27 = vec27.len() as i32;
                                    *((base + 24) as *mut i32) = len27;
                                    *((base + 20) as *mut i32) = ptr27;
                                    
                                  },
                                  ComponentListTypeParam::TypeU64(e) => {
                                    *((base + 16) as *mut u8) = (10i32) as u8;
                                    let vec28 = e;
                                    let ptr28 = vec28.as_ptr() as i32;
                                    let len28 = vec28.len() as i32;
                                    *((base + 24) as *mut i32) = len28;
                                    *((base + 20) as *mut i32) = ptr28;
                                    
                                  },
                                  ComponentListTypeParam::TypeVec2(e) => {
                                    *((base + 16) as *mut u8) = (11i32) as u8;
                                    let vec29 = e;
                                    let ptr29 = vec29.as_ptr() as i32;
                                    let len29 = vec29.len() as i32;
                                    *((base + 24) as *mut i32) = len29;
                                    *((base + 20) as *mut i32) = ptr29;
                                    
                                  },
                                  ComponentListTypeParam::TypeVec3(e) => {
                                    *((base + 16) as *mut u8) = (12i32) as u8;
                                    let vec30 = e;
                                    let ptr30 = vec30.as_ptr() as i32;
                                    let len30 = vec30.len() as i32;
                                    *((base + 24) as *mut i32) = len30;
                                    *((base + 20) as *mut i32) = ptr30;
                                    
                                  },
                                  ComponentListTypeParam::TypeVec4(e) => {
                                    *((base + 16) as *mut u8) = (13i32) as u8;
                                    let vec31 = e;
                                    let ptr31 = vec31.as_ptr() as i32;
                                    let len31 = vec31.len() as i32;
                                    *((base + 24) as *mut i32) = len31;
                                    *((base + 20) as *mut i32) = ptr31;
                                    
                                  },
                                  ComponentListTypeParam::TypeUvec2(e) => {
                                    *((base + 16) as *mut u8) = (14i32) as u8;
                                    let vec32 = e;
                                    let ptr32 = vec32.as_ptr() as i32;
                                    let len32 = vec32.len() as i32;
                                    *((base + 24) as *mut i32) = len32;
                                    *((base + 20) as *mut i32) = ptr32;
                                    
                                  },
                                  ComponentListTypeParam::TypeUvec3(e) => {
                                    *((base + 16) as *mut u8) = (15i32) as u8;
                                    let vec33 = e;
                                    let ptr33 = vec33.as_ptr() as i32;
                                    let len33 = vec33.len() as i32;
                                    *((base + 24) as *mut i32) = len33;
                                    *((base + 20) as *mut i32) = ptr33;
                                    
                                  },
                                  ComponentListTypeParam::TypeUvec4(e) => {
                                    *((base + 16) as *mut u8) = (16i32) as u8;
                                    let vec34 = e;
                                    let ptr34 = vec34.as_ptr() as i32;
                                    let len34 = vec34.len() as i32;
                                    *((base + 24) as *mut i32) = len34;
                                    *((base + 20) as *mut i32) = ptr34;
                                    
                                  },
                                };
                                
                              },
                              ComponentTypeParam::TypeOption(e) => {
                                *((base + 8) as *mut u8) = (18i32) as u8;
                                match e {
                                  ComponentOptionTypeParam::TypeEmpty(e) => {
                                    *((base + 16) as *mut u8) = (0i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let () = e;
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeBool(e) => {
                                    *((base + 16) as *mut u8) = (1i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeEntityId(e) => {
                                    *((base + 16) as *mut u8) = (2i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let super::types::EntityId{ id0:id036, id1:id136, } = e;
                                        *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id036);
                                        *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id136);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeF32(e) => {
                                    *((base + 16) as *mut u8) = (3i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeF64(e) => {
                                    *((base + 16) as *mut u8) = (4i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeMat4(e) => {
                                    *((base + 16) as *mut u8) = (5i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let super::types::Mat4{ x:x37, y:y37, z:z37, w:w37, } = e;
                                        let super::types::Vec4{ x:x38, y:y38, z:z38, w:w38, } = x37;
                                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x38);
                                        *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y38);
                                        *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z38);
                                        *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w38);
                                        let super::types::Vec4{ x:x39, y:y39, z:z39, w:w39, } = y37;
                                        *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x39);
                                        *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y39);
                                        *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z39);
                                        *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w39);
                                        let super::types::Vec4{ x:x40, y:y40, z:z40, w:w40, } = z37;
                                        *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x40);
                                        *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y40);
                                        *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z40);
                                        *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w40);
                                        let super::types::Vec4{ x:x41, y:y41, z:z41, w:w41, } = w37;
                                        *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x41);
                                        *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y41);
                                        *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z41);
                                        *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w41);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeI32(e) => {
                                    *((base + 16) as *mut u8) = (6i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeQuat(e) => {
                                    *((base + 16) as *mut u8) = (7i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let super::types::Quat{ x:x42, y:y42, z:z42, w:w42, } = e;
                                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x42);
                                        *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y42);
                                        *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z42);
                                        *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w42);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeString(e) => {
                                    *((base + 16) as *mut u8) = (8i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let vec43 = e;
                                        let ptr43 = vec43.as_ptr() as i32;
                                        let len43 = vec43.len() as i32;
                                        *((base + 32) as *mut i32) = len43;
                                        *((base + 28) as *mut i32) = ptr43;
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeU32(e) => {
                                    *((base + 16) as *mut u8) = (9i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeU64(e) => {
                                    *((base + 16) as *mut u8) = (10i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeVec2(e) => {
                                    *((base + 16) as *mut u8) = (11i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let super::types::Vec2{ x:x44, y:y44, } = e;
                                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x44);
                                        *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y44);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeVec3(e) => {
                                    *((base + 16) as *mut u8) = (12i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let super::types::Vec3{ x:x45, y:y45, z:z45, } = e;
                                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x45);
                                        *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y45);
                                        *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z45);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeVec4(e) => {
                                    *((base + 16) as *mut u8) = (13i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let super::types::Vec4{ x:x46, y:y46, z:z46, w:w46, } = e;
                                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x46);
                                        *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y46);
                                        *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z46);
                                        *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w46);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeUvec2(e) => {
                                    *((base + 16) as *mut u8) = (14i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let super::types::Uvec2{ x:x47, y:y47, } = e;
                                        *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x47);
                                        *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y47);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeUvec3(e) => {
                                    *((base + 16) as *mut u8) = (15i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let super::types::Uvec3{ x:x48, y:y48, z:z48, } = e;
                                        *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x48);
                                        *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y48);
                                        *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z48);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                  ComponentOptionTypeParam::TypeUvec4(e) => {
                                    *((base + 16) as *mut u8) = (16i32) as u8;
                                    match e {
                                      Some(e) => {
                                        *((base + 24) as *mut u8) = (1i32) as u8;
                                        let super::types::Uvec4{ x:x49, y:y49, z:z49, w:w49, } = e;
                                        *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x49);
                                        *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y49);
                                        *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z49);
                                        *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w49);
                                        
                                      },
                                      None => {
                                        {
                                          *((base + 24) as *mut u8) = (0i32) as u8;
                                          
                                        }
                                      },
                                    };
                                  },
                                };
                                
                              },
                            };
                            
                          }}
                          
                          #[link(wasm_import_module = "component")]
                          extern "C" {
                            #[cfg_attr(target_arch = "wasm32", link_name = "set-components")]
                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_set-components")]
                            fn wit_import(
                            _: i64, _: i64, _: i32, _: i32, );
                          }
                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result50 as i32, len50);
                          if layout50.size() != 0 {
                            alloc::dealloc(result50, layout50);
                          }
                          for (ptr, layout) in cleanup_list {
                            
                            if layout.size() != 0 {
                              
                              alloc::dealloc(ptr, layout);
                              
                            }
                            
                          }
                        }
                      }
                      #[allow(clippy::all)]
                      pub fn has_component(entity: EntityId,index: u32,) -> bool{
                        
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                        unsafe {
                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                          
                          #[link(wasm_import_module = "component")]
                          extern "C" {
                            #[cfg_attr(target_arch = "wasm32", link_name = "has-component")]
                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_has-component")]
                            fn wit_import(
                            _: i64, _: i64, _: i32, ) -> i32;
                          }
                          let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index));
                          {
                            #[cfg(not(debug_assertions))]
                            { core::mem::transmute::<u8, bool>(ret as u8) }
                            #[cfg(debug_assertions)]
                            {
                              match ret {
                                0 => false,
                                1 => true,
                                _ => panic!("invalid bool discriminant"),
                              }
                            }
                          }
                        }
                      }
                      #[allow(clippy::all)]
                      pub fn has_components(entity: EntityId,indices: &[u32],) -> bool{
                        
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                        unsafe {
                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                          let vec1 = indices;
                          let ptr1 = vec1.as_ptr() as i32;
                          let len1 = vec1.len() as i32;
                          
                          #[link(wasm_import_module = "component")]
                          extern "C" {
                            #[cfg_attr(target_arch = "wasm32", link_name = "has-components")]
                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_has-components")]
                            fn wit_import(
                            _: i64, _: i64, _: i32, _: i32, ) -> i32;
                          }
                          let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1, len1);
                          {
                            #[cfg(not(debug_assertions))]
                            { core::mem::transmute::<u8, bool>(ret as u8) }
                            #[cfg(debug_assertions)]
                            {
                              match ret {
                                0 => false,
                                1 => true,
                                _ => panic!("invalid bool discriminant"),
                              }
                            }
                          }
                        }
                      }
                      #[allow(clippy::all)]
                      pub fn remove_component(entity: EntityId,index: u32,){
                        
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                        unsafe {
                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                          
                          #[link(wasm_import_module = "component")]
                          extern "C" {
                            #[cfg_attr(target_arch = "wasm32", link_name = "remove-component")]
                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_remove-component")]
                            fn wit_import(
                            _: i64, _: i64, _: i32, );
                          }
                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index));
                        }
                      }
                      #[allow(clippy::all)]
                      pub fn remove_components(entity: EntityId,indices: &[u32],){
                        
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                        unsafe {
                          let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                          let vec1 = indices;
                          let ptr1 = vec1.as_ptr() as i32;
                          let len1 = vec1.len() as i32;
                          
                          #[link(wasm_import_module = "component")]
                          extern "C" {
                            #[cfg_attr(target_arch = "wasm32", link_name = "remove-components")]
                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_remove-components")]
                            fn wit_import(
                            _: i64, _: i64, _: i32, _: i32, );
                          }
                          wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1, len1);
                        }
                      }
                      #[allow(clippy::all)]
                      pub fn query(q: QueryBuild<'_,>,t: QueryEvent,) -> u64{
                        
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                        unsafe {
                          let QueryBuild{ components:components0, include:include0, exclude:exclude0, changed:changed0, } = q;
                          let vec1 = components0;
                          let ptr1 = vec1.as_ptr() as i32;
                          let len1 = vec1.len() as i32;
                          let vec2 = include0;
                          let ptr2 = vec2.as_ptr() as i32;
                          let len2 = vec2.len() as i32;
                          let vec3 = exclude0;
                          let ptr3 = vec3.as_ptr() as i32;
                          let len3 = vec3.len() as i32;
                          let vec4 = changed0;
                          let ptr4 = vec4.as_ptr() as i32;
                          let len4 = vec4.len() as i32;
                          
                          #[link(wasm_import_module = "component")]
                          extern "C" {
                            #[cfg_attr(target_arch = "wasm32", link_name = "query")]
                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_query")]
                            fn wit_import(
                            _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ) -> i64;
                          }
                          let ret = wit_import(ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4, match t {
                            QueryEvent::Frame => 0,
                            QueryEvent::Spawn => 1,
                            QueryEvent::Despawn => 2,
                          });
                          ret as u64
                        }
                      }
                      #[allow(clippy::all)]
                      pub fn query_eval(q: u64,) -> wit_bindgen::rt::vec::Vec::<(EntityId,wit_bindgen::rt::vec::Vec::<ComponentTypeResult>,)>{
                        
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                        unsafe {
                          
                          #[repr(align(4))]
                          struct RetArea([u8; 8]);
                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                          let ptr0 = ret_area.as_mut_ptr() as i32;
                          #[link(wasm_import_module = "component")]
                          extern "C" {
                            #[cfg_attr(target_arch = "wasm32", link_name = "query-eval")]
                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_query-eval")]
                            fn wit_import(
                            _: i64, _: i32, );
                          }
                          wit_import(wit_bindgen::rt::as_i64(q), ptr0);
                          let base22 = *((ptr0 + 0) as *const i32);
                          let len22 = *((ptr0 + 4) as *const i32);
                          let mut result22 = Vec::with_capacity(len22 as usize);
                          for i in 0..len22 {
                            let base = base22 + i *24;
                            result22.push({
                              let base21 = *((base + 16) as *const i32);
                              let len21 = *((base + 20) as *const i32);
                              let mut result21 = Vec::with_capacity(len21 as usize);
                              for i in 0..len21 {
                                let base = base21 + i *88;
                                result21.push({{match i32::from(*((base + 0) as *const u8)) {
                                  0 => ComponentTypeResult::TypeEmpty(()),
                                  1 => ComponentTypeResult::TypeBool({
                                    #[cfg(not(debug_assertions))]
                                    { core::mem::transmute::<u8, bool>(i32::from(*((base + 8) as *const u8)) as u8) }
                                    #[cfg(debug_assertions)]
                                    {
                                      match i32::from(*((base + 8) as *const u8)) {
                                        0 => false,
                                        1 => true,
                                        _ => panic!("invalid bool discriminant"),
                                      }
                                    }
                                  }),
                                  2 => ComponentTypeResult::TypeEntityId(super::types::EntityId{id0:*((base + 8) as *const i64) as u64, id1:*((base + 16) as *const i64) as u64, }),
                                  3 => ComponentTypeResult::TypeF32(*((base + 8) as *const f32)),
                                  4 => ComponentTypeResult::TypeF64(*((base + 8) as *const f64)),
                                  5 => ComponentTypeResult::TypeMat4(super::types::Mat4{x:super::types::Vec4{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }, y:super::types::Vec4{x:*((base + 24) as *const f32), y:*((base + 28) as *const f32), z:*((base + 32) as *const f32), w:*((base + 36) as *const f32), }, z:super::types::Vec4{x:*((base + 40) as *const f32), y:*((base + 44) as *const f32), z:*((base + 48) as *const f32), w:*((base + 52) as *const f32), }, w:super::types::Vec4{x:*((base + 56) as *const f32), y:*((base + 60) as *const f32), z:*((base + 64) as *const f32), w:*((base + 68) as *const f32), }, }),
                                  6 => ComponentTypeResult::TypeI32(*((base + 8) as *const i32)),
                                  7 => ComponentTypeResult::TypeQuat(super::types::Quat{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }),
                                  8 => ComponentTypeResult::TypeString({
                                    let len1 = *((base + 12) as *const i32) as usize;
                                    
                                    {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len1, len1)).unwrap()}}
                                  }),
                                  9 => ComponentTypeResult::TypeU32(*((base + 8) as *const i32) as u32),
                                  10 => ComponentTypeResult::TypeU64(*((base + 8) as *const i64) as u64),
                                  11 => ComponentTypeResult::TypeVec2(super::types::Vec2{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), }),
                                  12 => ComponentTypeResult::TypeVec3(super::types::Vec3{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), }),
                                  13 => ComponentTypeResult::TypeVec4(super::types::Vec4{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }),
                                  14 => ComponentTypeResult::TypeUvec2(super::types::Uvec2{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, }),
                                  15 => ComponentTypeResult::TypeUvec3(super::types::Uvec3{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, z:*((base + 16) as *const i32) as u32, }),
                                  16 => ComponentTypeResult::TypeUvec4(super::types::Uvec4{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, z:*((base + 16) as *const i32) as u32, w:*((base + 20) as *const i32) as u32, }),
                                  17 => ComponentTypeResult::TypeList({{match i32::from(*((base + 8) as *const u8)) {
                                    0 => ComponentListTypeResult::TypeEmpty({
                                      let len2 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len2, len2)
                                    }),
                                    1 => ComponentListTypeResult::TypeBool({
                                      let base3 = *((base + 12) as *const i32);
                                      let len3 = *((base + 16) as *const i32);
                                      let mut result3 = Vec::with_capacity(len3 as usize);
                                      for i in 0..len3 {
                                        let base = base3 + i *1;
                                        result3.push({
                                          #[cfg(not(debug_assertions))]
                                          { core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                                          #[cfg(debug_assertions)]
                                          {
                                            match i32::from(*((base + 0) as *const u8)) {
                                              0 => false,
                                              1 => true,
                                              _ => panic!("invalid bool discriminant"),
                                            }
                                          }
                                        });
                                      }
                                      wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                                      
                                      result3
                                    }),
                                    2 => ComponentListTypeResult::TypeEntityId({
                                      let len4 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len4, len4)
                                    }),
                                    3 => ComponentListTypeResult::TypeF32({
                                      let len5 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len5, len5)
                                    }),
                                    4 => ComponentListTypeResult::TypeF64({
                                      let len6 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len6, len6)
                                    }),
                                    5 => ComponentListTypeResult::TypeMat4({
                                      let len7 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len7, len7)
                                    }),
                                    6 => ComponentListTypeResult::TypeI32({
                                      let len8 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len8, len8)
                                    }),
                                    7 => ComponentListTypeResult::TypeQuat({
                                      let len9 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len9, len9)
                                    }),
                                    8 => ComponentListTypeResult::TypeString({
                                      let base11 = *((base + 12) as *const i32);
                                      let len11 = *((base + 16) as *const i32);
                                      let mut result11 = Vec::with_capacity(len11 as usize);
                                      for i in 0..len11 {
                                        let base = base11 + i *8;
                                        result11.push({
                                          let len10 = *((base + 4) as *const i32) as usize;
                                          
                                          {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10)).unwrap()}}
                                        });
                                      }
                                      wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                                      
                                      result11
                                    }),
                                    9 => ComponentListTypeResult::TypeU32({
                                      let len12 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len12, len12)
                                    }),
                                    10 => ComponentListTypeResult::TypeU64({
                                      let len13 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len13, len13)
                                    }),
                                    11 => ComponentListTypeResult::TypeVec2({
                                      let len14 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len14, len14)
                                    }),
                                    12 => ComponentListTypeResult::TypeVec3({
                                      let len15 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len15, len15)
                                    }),
                                    13 => ComponentListTypeResult::TypeVec4({
                                      let len16 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len16, len16)
                                    }),
                                    14 => ComponentListTypeResult::TypeUvec2({
                                      let len17 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len17, len17)
                                    }),
                                    15 => ComponentListTypeResult::TypeUvec3({
                                      let len18 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len18, len18)
                                    }),
                                    #[cfg(debug_assertions)]16 => ComponentListTypeResult::TypeUvec4({
                                      let len19 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len19, len19)
                                    }),
                                    #[cfg(not(debug_assertions))]_ => ComponentListTypeResult::TypeUvec4({
                                      let len19 = *((base + 16) as *const i32) as usize;
                                      
                                      Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len19, len19)
                                    }),
                                    #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                  }}}),
                                  #[cfg(debug_assertions)]18 => ComponentTypeResult::TypeOption({{match i32::from(*((base + 8) as *const u8)) {
                                    0 => ComponentOptionTypeResult::TypeEmpty(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(()),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    1 => ComponentOptionTypeResult::TypeBool(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some({
                                        #[cfg(not(debug_assertions))]
                                        { core::mem::transmute::<u8, bool>(i32::from(*((base + 17) as *const u8)) as u8) }
                                        #[cfg(debug_assertions)]
                                        {
                                          match i32::from(*((base + 17) as *const u8)) {
                                            0 => false,
                                            1 => true,
                                            _ => panic!("invalid bool discriminant"),
                                          }
                                        }
                                      }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    2 => ComponentOptionTypeResult::TypeEntityId(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::EntityId{id0:*((base + 24) as *const i64) as u64, id1:*((base + 32) as *const i64) as u64, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    3 => ComponentOptionTypeResult::TypeF32(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(*((base + 20) as *const f32)),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    4 => ComponentOptionTypeResult::TypeF64(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(*((base + 24) as *const f64)),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    5 => ComponentOptionTypeResult::TypeMat4(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }, y:super::types::Vec4{x:*((base + 36) as *const f32), y:*((base + 40) as *const f32), z:*((base + 44) as *const f32), w:*((base + 48) as *const f32), }, z:super::types::Vec4{x:*((base + 52) as *const f32), y:*((base + 56) as *const f32), z:*((base + 60) as *const f32), w:*((base + 64) as *const f32), }, w:super::types::Vec4{x:*((base + 68) as *const f32), y:*((base + 72) as *const f32), z:*((base + 76) as *const f32), w:*((base + 80) as *const f32), }, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    6 => ComponentOptionTypeResult::TypeI32(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(*((base + 20) as *const i32)),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    7 => ComponentOptionTypeResult::TypeQuat(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Quat{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    8 => ComponentOptionTypeResult::TypeString(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some({
                                        let len20 = *((base + 24) as *const i32) as usize;
                                        
                                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len20, len20))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len20, len20)).unwrap()}}
                                      }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    9 => ComponentOptionTypeResult::TypeU32(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(*((base + 20) as *const i32) as u32),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    10 => ComponentOptionTypeResult::TypeU64(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(*((base + 24) as *const i64) as u64),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    11 => ComponentOptionTypeResult::TypeVec2(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Vec2{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    12 => ComponentOptionTypeResult::TypeVec3(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Vec3{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    13 => ComponentOptionTypeResult::TypeVec4(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    14 => ComponentOptionTypeResult::TypeUvec2(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Uvec2{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    15 => ComponentOptionTypeResult::TypeUvec3(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Uvec3{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    #[cfg(debug_assertions)]16 => ComponentOptionTypeResult::TypeUvec4(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Uvec4{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, w:*((base + 32) as *const i32) as u32, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    #[cfg(not(debug_assertions))]_ => ComponentOptionTypeResult::TypeUvec4(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Uvec4{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, w:*((base + 32) as *const i32) as u32, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                  }}}),
                                  #[cfg(not(debug_assertions))]_ => ComponentTypeResult::TypeOption({{match i32::from(*((base + 8) as *const u8)) {
                                    0 => ComponentOptionTypeResult::TypeEmpty(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(()),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    1 => ComponentOptionTypeResult::TypeBool(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some({
                                        #[cfg(not(debug_assertions))]
                                        { core::mem::transmute::<u8, bool>(i32::from(*((base + 17) as *const u8)) as u8) }
                                        #[cfg(debug_assertions)]
                                        {
                                          match i32::from(*((base + 17) as *const u8)) {
                                            0 => false,
                                            1 => true,
                                            _ => panic!("invalid bool discriminant"),
                                          }
                                        }
                                      }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    2 => ComponentOptionTypeResult::TypeEntityId(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::EntityId{id0:*((base + 24) as *const i64) as u64, id1:*((base + 32) as *const i64) as u64, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    3 => ComponentOptionTypeResult::TypeF32(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(*((base + 20) as *const f32)),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    4 => ComponentOptionTypeResult::TypeF64(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(*((base + 24) as *const f64)),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    5 => ComponentOptionTypeResult::TypeMat4(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }, y:super::types::Vec4{x:*((base + 36) as *const f32), y:*((base + 40) as *const f32), z:*((base + 44) as *const f32), w:*((base + 48) as *const f32), }, z:super::types::Vec4{x:*((base + 52) as *const f32), y:*((base + 56) as *const f32), z:*((base + 60) as *const f32), w:*((base + 64) as *const f32), }, w:super::types::Vec4{x:*((base + 68) as *const f32), y:*((base + 72) as *const f32), z:*((base + 76) as *const f32), w:*((base + 80) as *const f32), }, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    6 => ComponentOptionTypeResult::TypeI32(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(*((base + 20) as *const i32)),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    7 => ComponentOptionTypeResult::TypeQuat(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Quat{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    8 => ComponentOptionTypeResult::TypeString(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some({
                                        let len20 = *((base + 24) as *const i32) as usize;
                                        
                                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len20, len20))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len20, len20)).unwrap()}}
                                      }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    9 => ComponentOptionTypeResult::TypeU32(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(*((base + 20) as *const i32) as u32),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    10 => ComponentOptionTypeResult::TypeU64(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(*((base + 24) as *const i64) as u64),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    11 => ComponentOptionTypeResult::TypeVec2(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Vec2{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    12 => ComponentOptionTypeResult::TypeVec3(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Vec3{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    13 => ComponentOptionTypeResult::TypeVec4(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    14 => ComponentOptionTypeResult::TypeUvec2(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Uvec2{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    15 => ComponentOptionTypeResult::TypeUvec3(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Uvec3{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    #[cfg(debug_assertions)]16 => ComponentOptionTypeResult::TypeUvec4(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Uvec4{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, w:*((base + 32) as *const i32) as u32, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    #[cfg(not(debug_assertions))]_ => ComponentOptionTypeResult::TypeUvec4(match i32::from(*((base + 16) as *const u8)) {
                                      0 => None,
                                      1 => Some(super::types::Uvec4{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, w:*((base + 32) as *const i32) as u32, }),
                                      #[cfg(not(debug_assertions))]
                                      _ => core::hint::unreachable_unchecked(),
                                      #[cfg(debug_assertions)]
                                      _ => panic!("invalid enum discriminant"),
                                    }),
                                    #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                  }}}),
                                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                }}});
                              }
                              wit_bindgen::rt::dealloc(base21, (len21 as usize) * 88, 8);
                              
                              (super::types::EntityId{id0:*((base + 0) as *const i64) as u64, id1:*((base + 8) as *const i64) as u64, }, result21)
                            });
                          }
                          wit_bindgen::rt::dealloc(base22, (len22 as usize) * 24, 8);
                          result22
                        }
                      }
                      
                    }
                    
                    
                    #[allow(clippy::all)]
                    pub mod entity{ use super::wit_bindgen;
                      pub type EntityId = super::types::EntityId;
                      pub type Vec3 = super::types::Vec3;
                      pub type EntityData<'a,> = super::component::Entity<'a,>;
                      /// An action in an animation.
                      #[derive(Clone)]
                      pub struct AnimationAction<'a,> {
                        /// The animation clip URL to play.
                        pub clip_url: &'a str,
                        /// Whether or not this action should loop
                        pub looping: bool,
                        /// How strongly this action applies to the final blend [0-1]
                        pub weight: f32,
                      }
                      impl<'a,> core::fmt::Debug for AnimationAction<'a,> {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                          f.debug_struct("AnimationAction").field("clip-url", &self.clip_url).field("looping", &self.looping).field("weight", &self.weight).finish()
                        }
                      }
                      /// Controls the animations for an entity.
                      #[derive(Clone)]
                      pub struct AnimationController<'a,> {
                        /// All of the actions that contribute to this animation.
                        /// Will be blended together.
                        pub actions: &'a [AnimationAction<'a,>],
                        /// Whether or not the first action's pose should be used as a base pose.
                        pub apply_base_pose: bool,
                      }
                      impl<'a,> core::fmt::Debug for AnimationController<'a,> {
                        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                          f.debug_struct("AnimationController").field("actions", &self.actions).field("apply-base-pose", &self.apply_base_pose).finish()
                        }
                      }
                      #[allow(clippy::all)]
                      pub fn spawn(data: EntityData<'_,>,) -> EntityId{
                        
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                        unsafe {
                          let mut cleanup_list = Vec::new();
                          
                          #[repr(align(8))]
                          struct RetArea([u8; 16]);
                          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                          let vec49 = data;
                          let len49 = vec49.len() as i32;
                          let layout49 = alloc::Layout::from_size_align_unchecked(vec49.len() * 96, 8);
                          let result49 = if layout49.size() != 0
                          {
                            let ptr = alloc::alloc(layout49);
                            if ptr.is_null()
                            {
                              alloc::handle_alloc_error(layout49);
                            }
                            ptr
                          }else {
                            core::ptr::null_mut()
                          };
                          for (i, e) in vec49.into_iter().enumerate() {
                            let base = result49 as i32 + (i as i32) * 96;
                            {
                              let (t0_0, t0_1, ) = e;
                              *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t0_0);
                              match t0_1 {
                                super::component::ComponentTypeParam::TypeEmpty(e) => {
                                  *((base + 8) as *mut u8) = (0i32) as u8;
                                  let () = e;
                                  
                                },
                                super::component::ComponentTypeParam::TypeBool(e) => {
                                  *((base + 8) as *mut u8) = (1i32) as u8;
                                  *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                  
                                },
                                super::component::ComponentTypeParam::TypeEntityId(e) => {
                                  *((base + 8) as *mut u8) = (2i32) as u8;
                                  let super::types::EntityId{ id0:id02, id1:id12, } = e;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id02);
                                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id12);
                                  
                                },
                                super::component::ComponentTypeParam::TypeF32(e) => {
                                  *((base + 8) as *mut u8) = (3i32) as u8;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                  
                                },
                                super::component::ComponentTypeParam::TypeF64(e) => {
                                  *((base + 8) as *mut u8) = (4i32) as u8;
                                  *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                  
                                },
                                super::component::ComponentTypeParam::TypeMat4(e) => {
                                  *((base + 8) as *mut u8) = (5i32) as u8;
                                  let super::types::Mat4{ x:x3, y:y3, z:z3, w:w3, } = e;
                                  let super::types::Vec4{ x:x4, y:y4, z:z4, w:w4, } = x3;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x4);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y4);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z4);
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w4);
                                  let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = y3;
                                  *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                                  *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                                  *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                                  *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                                  let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = z3;
                                  *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                                  *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                                  *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                                  *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                                  let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = w3;
                                  *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                                  *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                                  *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                                  *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                                  
                                },
                                super::component::ComponentTypeParam::TypeI32(e) => {
                                  *((base + 8) as *mut u8) = (6i32) as u8;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                  
                                },
                                super::component::ComponentTypeParam::TypeQuat(e) => {
                                  *((base + 8) as *mut u8) = (7i32) as u8;
                                  let super::types::Quat{ x:x8, y:y8, z:z8, w:w8, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                                  
                                },
                                super::component::ComponentTypeParam::TypeString(e) => {
                                  *((base + 8) as *mut u8) = (8i32) as u8;
                                  let vec9 = e;
                                  let ptr9 = vec9.as_ptr() as i32;
                                  let len9 = vec9.len() as i32;
                                  *((base + 20) as *mut i32) = len9;
                                  *((base + 16) as *mut i32) = ptr9;
                                  
                                },
                                super::component::ComponentTypeParam::TypeU32(e) => {
                                  *((base + 8) as *mut u8) = (9i32) as u8;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                  
                                },
                                super::component::ComponentTypeParam::TypeU64(e) => {
                                  *((base + 8) as *mut u8) = (10i32) as u8;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                  
                                },
                                super::component::ComponentTypeParam::TypeVec2(e) => {
                                  *((base + 8) as *mut u8) = (11i32) as u8;
                                  let super::types::Vec2{ x:x10, y:y10, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x10);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y10);
                                  
                                },
                                super::component::ComponentTypeParam::TypeVec3(e) => {
                                  *((base + 8) as *mut u8) = (12i32) as u8;
                                  let super::types::Vec3{ x:x11, y:y11, z:z11, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z11);
                                  
                                },
                                super::component::ComponentTypeParam::TypeVec4(e) => {
                                  *((base + 8) as *mut u8) = (13i32) as u8;
                                  let super::types::Vec4{ x:x12, y:y12, z:z12, w:w12, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w12);
                                  
                                },
                                super::component::ComponentTypeParam::TypeUvec2(e) => {
                                  *((base + 8) as *mut u8) = (14i32) as u8;
                                  let super::types::Uvec2{ x:x13, y:y13, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x13);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y13);
                                  
                                },
                                super::component::ComponentTypeParam::TypeUvec3(e) => {
                                  *((base + 8) as *mut u8) = (15i32) as u8;
                                  let super::types::Uvec3{ x:x14, y:y14, z:z14, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z14);
                                  
                                },
                                super::component::ComponentTypeParam::TypeUvec4(e) => {
                                  *((base + 8) as *mut u8) = (16i32) as u8;
                                  let super::types::Uvec4{ x:x15, y:y15, z:z15, w:w15, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                                  *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w15);
                                  
                                },
                                super::component::ComponentTypeParam::TypeList(e) => {
                                  *((base + 8) as *mut u8) = (17i32) as u8;
                                  match e {
                                    super::component::ComponentListTypeParam::TypeEmpty(e) => {
                                      *((base + 16) as *mut u8) = (0i32) as u8;
                                      let vec16 = e;
                                      let ptr16 = vec16.as_ptr() as i32;
                                      let len16 = vec16.len() as i32;
                                      *((base + 24) as *mut i32) = len16;
                                      *((base + 20) as *mut i32) = ptr16;
                                      
                                    },
                                    super::component::ComponentListTypeParam::TypeBool(e) => {
                                      *((base + 16) as *mut u8) = (1i32) as u8;
                                      let vec17 = e;
                                      let len17 = vec17.len() as i32;
                                      let layout17 = alloc::Layout::from_size_align_unchecked(vec17.len() * 1, 1);
                                      let result17 = if layout17.size() != 0
                                      {
                                        let ptr = alloc::alloc(layout17);
                                        if ptr.is_null()
                                        {
                                          alloc::handle_alloc_error(layout17);
                                        }
                                        ptr
                                      }else {
                                        core::ptr::null_mut()
                                      };
                                      for (i, e) in vec17.into_iter().enumerate() {
                                        let base = result17 as i32 + (i as i32) * 1;
                                        {
                                          *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                          
                                        }}
                                        *((base + 24) as *mut i32) = len17;
                                        *((base + 20) as *mut i32) = result17 as i32;
                                        cleanup_list.extend_from_slice(&[(result17, layout17),]);
                                        
                                      },
                                      super::component::ComponentListTypeParam::TypeEntityId(e) => {
                                        *((base + 16) as *mut u8) = (2i32) as u8;
                                        let vec18 = e;
                                        let ptr18 = vec18.as_ptr() as i32;
                                        let len18 = vec18.len() as i32;
                                        *((base + 24) as *mut i32) = len18;
                                        *((base + 20) as *mut i32) = ptr18;
                                        
                                      },
                                      super::component::ComponentListTypeParam::TypeF32(e) => {
                                        *((base + 16) as *mut u8) = (3i32) as u8;
                                        let vec19 = e;
                                        let ptr19 = vec19.as_ptr() as i32;
                                        let len19 = vec19.len() as i32;
                                        *((base + 24) as *mut i32) = len19;
                                        *((base + 20) as *mut i32) = ptr19;
                                        
                                      },
                                      super::component::ComponentListTypeParam::TypeF64(e) => {
                                        *((base + 16) as *mut u8) = (4i32) as u8;
                                        let vec20 = e;
                                        let ptr20 = vec20.as_ptr() as i32;
                                        let len20 = vec20.len() as i32;
                                        *((base + 24) as *mut i32) = len20;
                                        *((base + 20) as *mut i32) = ptr20;
                                        
                                      },
                                      super::component::ComponentListTypeParam::TypeMat4(e) => {
                                        *((base + 16) as *mut u8) = (5i32) as u8;
                                        let vec21 = e;
                                        let ptr21 = vec21.as_ptr() as i32;
                                        let len21 = vec21.len() as i32;
                                        *((base + 24) as *mut i32) = len21;
                                        *((base + 20) as *mut i32) = ptr21;
                                        
                                      },
                                      super::component::ComponentListTypeParam::TypeI32(e) => {
                                        *((base + 16) as *mut u8) = (6i32) as u8;
                                        let vec22 = e;
                                        let ptr22 = vec22.as_ptr() as i32;
                                        let len22 = vec22.len() as i32;
                                        *((base + 24) as *mut i32) = len22;
                                        *((base + 20) as *mut i32) = ptr22;
                                        
                                      },
                                      super::component::ComponentListTypeParam::TypeQuat(e) => {
                                        *((base + 16) as *mut u8) = (7i32) as u8;
                                        let vec23 = e;
                                        let ptr23 = vec23.as_ptr() as i32;
                                        let len23 = vec23.len() as i32;
                                        *((base + 24) as *mut i32) = len23;
                                        *((base + 20) as *mut i32) = ptr23;
                                        
                                      },
                                      super::component::ComponentListTypeParam::TypeString(e) => {
                                        *((base + 16) as *mut u8) = (8i32) as u8;
                                        let vec25 = e;
                                        let len25 = vec25.len() as i32;
                                        let layout25 = alloc::Layout::from_size_align_unchecked(vec25.len() * 8, 4);
                                        let result25 = if layout25.size() != 0
                                        {
                                          let ptr = alloc::alloc(layout25);
                                          if ptr.is_null()
                                          {
                                            alloc::handle_alloc_error(layout25);
                                          }
                                          ptr
                                        }else {
                                          core::ptr::null_mut()
                                        };
                                        for (i, e) in vec25.into_iter().enumerate() {
                                          let base = result25 as i32 + (i as i32) * 8;
                                          {
                                            let vec24 = e;
                                            let ptr24 = vec24.as_ptr() as i32;
                                            let len24 = vec24.len() as i32;
                                            *((base + 4) as *mut i32) = len24;
                                            *((base + 0) as *mut i32) = ptr24;
                                            
                                          }}
                                          *((base + 24) as *mut i32) = len25;
                                          *((base + 20) as *mut i32) = result25 as i32;
                                          cleanup_list.extend_from_slice(&[(result25, layout25),]);
                                          
                                        },
                                        super::component::ComponentListTypeParam::TypeU32(e) => {
                                          *((base + 16) as *mut u8) = (9i32) as u8;
                                          let vec26 = e;
                                          let ptr26 = vec26.as_ptr() as i32;
                                          let len26 = vec26.len() as i32;
                                          *((base + 24) as *mut i32) = len26;
                                          *((base + 20) as *mut i32) = ptr26;
                                          
                                        },
                                        super::component::ComponentListTypeParam::TypeU64(e) => {
                                          *((base + 16) as *mut u8) = (10i32) as u8;
                                          let vec27 = e;
                                          let ptr27 = vec27.as_ptr() as i32;
                                          let len27 = vec27.len() as i32;
                                          *((base + 24) as *mut i32) = len27;
                                          *((base + 20) as *mut i32) = ptr27;
                                          
                                        },
                                        super::component::ComponentListTypeParam::TypeVec2(e) => {
                                          *((base + 16) as *mut u8) = (11i32) as u8;
                                          let vec28 = e;
                                          let ptr28 = vec28.as_ptr() as i32;
                                          let len28 = vec28.len() as i32;
                                          *((base + 24) as *mut i32) = len28;
                                          *((base + 20) as *mut i32) = ptr28;
                                          
                                        },
                                        super::component::ComponentListTypeParam::TypeVec3(e) => {
                                          *((base + 16) as *mut u8) = (12i32) as u8;
                                          let vec29 = e;
                                          let ptr29 = vec29.as_ptr() as i32;
                                          let len29 = vec29.len() as i32;
                                          *((base + 24) as *mut i32) = len29;
                                          *((base + 20) as *mut i32) = ptr29;
                                          
                                        },
                                        super::component::ComponentListTypeParam::TypeVec4(e) => {
                                          *((base + 16) as *mut u8) = (13i32) as u8;
                                          let vec30 = e;
                                          let ptr30 = vec30.as_ptr() as i32;
                                          let len30 = vec30.len() as i32;
                                          *((base + 24) as *mut i32) = len30;
                                          *((base + 20) as *mut i32) = ptr30;
                                          
                                        },
                                        super::component::ComponentListTypeParam::TypeUvec2(e) => {
                                          *((base + 16) as *mut u8) = (14i32) as u8;
                                          let vec31 = e;
                                          let ptr31 = vec31.as_ptr() as i32;
                                          let len31 = vec31.len() as i32;
                                          *((base + 24) as *mut i32) = len31;
                                          *((base + 20) as *mut i32) = ptr31;
                                          
                                        },
                                        super::component::ComponentListTypeParam::TypeUvec3(e) => {
                                          *((base + 16) as *mut u8) = (15i32) as u8;
                                          let vec32 = e;
                                          let ptr32 = vec32.as_ptr() as i32;
                                          let len32 = vec32.len() as i32;
                                          *((base + 24) as *mut i32) = len32;
                                          *((base + 20) as *mut i32) = ptr32;
                                          
                                        },
                                        super::component::ComponentListTypeParam::TypeUvec4(e) => {
                                          *((base + 16) as *mut u8) = (16i32) as u8;
                                          let vec33 = e;
                                          let ptr33 = vec33.as_ptr() as i32;
                                          let len33 = vec33.len() as i32;
                                          *((base + 24) as *mut i32) = len33;
                                          *((base + 20) as *mut i32) = ptr33;
                                          
                                        },
                                      };
                                      
                                    },
                                    super::component::ComponentTypeParam::TypeOption(e) => {
                                      *((base + 8) as *mut u8) = (18i32) as u8;
                                      match e {
                                        super::component::ComponentOptionTypeParam::TypeEmpty(e) => {
                                          *((base + 16) as *mut u8) = (0i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let () = e;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeBool(e) => {
                                          *((base + 16) as *mut u8) = (1i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeEntityId(e) => {
                                          *((base + 16) as *mut u8) = (2i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::types::EntityId{ id0:id035, id1:id135, } = e;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id035);
                                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id135);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeF32(e) => {
                                          *((base + 16) as *mut u8) = (3i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeF64(e) => {
                                          *((base + 16) as *mut u8) = (4i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeMat4(e) => {
                                          *((base + 16) as *mut u8) = (5i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::types::Mat4{ x:x36, y:y36, z:z36, w:w36, } = e;
                                              let super::types::Vec4{ x:x37, y:y37, z:z37, w:w37, } = x36;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x37);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y37);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z37);
                                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w37);
                                              let super::types::Vec4{ x:x38, y:y38, z:z38, w:w38, } = y36;
                                              *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x38);
                                              *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y38);
                                              *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z38);
                                              *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w38);
                                              let super::types::Vec4{ x:x39, y:y39, z:z39, w:w39, } = z36;
                                              *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x39);
                                              *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y39);
                                              *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z39);
                                              *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w39);
                                              let super::types::Vec4{ x:x40, y:y40, z:z40, w:w40, } = w36;
                                              *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x40);
                                              *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y40);
                                              *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z40);
                                              *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w40);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeI32(e) => {
                                          *((base + 16) as *mut u8) = (6i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeQuat(e) => {
                                          *((base + 16) as *mut u8) = (7i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::types::Quat{ x:x41, y:y41, z:z41, w:w41, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x41);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y41);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z41);
                                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w41);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeString(e) => {
                                          *((base + 16) as *mut u8) = (8i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let vec42 = e;
                                              let ptr42 = vec42.as_ptr() as i32;
                                              let len42 = vec42.len() as i32;
                                              *((base + 32) as *mut i32) = len42;
                                              *((base + 28) as *mut i32) = ptr42;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeU32(e) => {
                                          *((base + 16) as *mut u8) = (9i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeU64(e) => {
                                          *((base + 16) as *mut u8) = (10i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeVec2(e) => {
                                          *((base + 16) as *mut u8) = (11i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::types::Vec2{ x:x43, y:y43, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x43);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y43);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeVec3(e) => {
                                          *((base + 16) as *mut u8) = (12i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::types::Vec3{ x:x44, y:y44, z:z44, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x44);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y44);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z44);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeVec4(e) => {
                                          *((base + 16) as *mut u8) = (13i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::types::Vec4{ x:x45, y:y45, z:z45, w:w45, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x45);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y45);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z45);
                                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w45);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeUvec2(e) => {
                                          *((base + 16) as *mut u8) = (14i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::types::Uvec2{ x:x46, y:y46, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x46);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y46);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeUvec3(e) => {
                                          *((base + 16) as *mut u8) = (15i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::types::Uvec3{ x:x47, y:y47, z:z47, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x47);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y47);
                                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z47);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        super::component::ComponentOptionTypeParam::TypeUvec4(e) => {
                                          *((base + 16) as *mut u8) = (16i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::types::Uvec4{ x:x48, y:y48, z:z48, w:w48, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x48);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y48);
                                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z48);
                                              *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w48);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                      };
                                      
                                    },
                                  };
                                  
                                }}
                                let ptr50 = ret_area.as_mut_ptr() as i32;
                                #[link(wasm_import_module = "entity")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "spawn")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_spawn")]
                                  fn wit_import(
                                  _: i32, _: i32, _: i32, );
                                }
                                wit_import(result49 as i32, len49, ptr50);
                                if layout49.size() != 0 {
                                  alloc::dealloc(result49, layout49);
                                }
                                for (ptr, layout) in cleanup_list {
                                  
                                  if layout.size() != 0 {
                                    
                                    alloc::dealloc(ptr, layout);
                                    
                                  }
                                  
                                }
                                super::types::EntityId{id0:*((ptr50 + 0) as *const i64) as u64, id1:*((ptr50 + 8) as *const i64) as u64, }
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn despawn(entity: EntityId,) -> bool{
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                              unsafe {
                                let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                
                                #[link(wasm_import_module = "entity")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "despawn")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_despawn")]
                                  fn wit_import(
                                  _: i64, _: i64, ) -> i32;
                                }
                                let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                {
                                  #[cfg(not(debug_assertions))]
                                  { core::mem::transmute::<u8, bool>(ret as u8) }
                                  #[cfg(debug_assertions)]
                                  {
                                    match ret {
                                      0 => false,
                                      1 => true,
                                      _ => panic!("invalid bool discriminant"),
                                    }
                                  }
                                }
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn set_animation_controller(entity: EntityId,animation_controller: AnimationController<'_,>,){
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                              unsafe {
                                let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                let AnimationController{ actions:actions1, apply_base_pose:apply_base_pose1, } = animation_controller;
                                let vec4 = actions1;
                                let len4 = vec4.len() as i32;
                                let layout4 = alloc::Layout::from_size_align_unchecked(vec4.len() * 16, 4);
                                let result4 = if layout4.size() != 0
                                {
                                  let ptr = alloc::alloc(layout4);
                                  if ptr.is_null()
                                  {
                                    alloc::handle_alloc_error(layout4);
                                  }
                                  ptr
                                }else {
                                  core::ptr::null_mut()
                                };
                                for (i, e) in vec4.into_iter().enumerate() {
                                  let base = result4 as i32 + (i as i32) * 16;
                                  {
                                    let AnimationAction{ clip_url:clip_url2, looping:looping2, weight:weight2, } = e;
                                    let vec3 = clip_url2;
                                    let ptr3 = vec3.as_ptr() as i32;
                                    let len3 = vec3.len() as i32;
                                    *((base + 4) as *mut i32) = len3;
                                    *((base + 0) as *mut i32) = ptr3;
                                    *((base + 8) as *mut u8) = (match looping2 { true => 1, false => 0 }) as u8;
                                    *((base + 12) as *mut f32) = wit_bindgen::rt::as_f32(weight2);
                                    
                                  }}
                                  
                                  #[link(wasm_import_module = "entity")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "set-animation-controller")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_set-animation-controller")]
                                    fn wit_import(
                                    _: i64, _: i64, _: i32, _: i32, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result4 as i32, len4, match apply_base_pose1 { true => 1, false => 0 });
                                  if layout4.size() != 0 {
                                    alloc::dealloc(result4, layout4);
                                  }
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn in_area(position: Vec3,radius: f32,) -> wit_bindgen::rt::vec::Vec::<EntityId>{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  
                                  #[repr(align(4))]
                                  struct RetArea([u8; 8]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let super::types::Vec3{ x:x0, y:y0, z:z0, } = position;
                                  let ptr1 = ret_area.as_mut_ptr() as i32;
                                  #[link(wasm_import_module = "entity")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "in-area")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_in-area")]
                                    fn wit_import(
                                    _: f32, _: f32, _: f32, _: f32, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(radius), ptr1);
                                  let len2 = *((ptr1 + 4) as *const i32) as usize;
                                  Vec::from_raw_parts(*((ptr1 + 0) as *const i32) as *mut _, len2, len2)
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn exists(entity: EntityId,) -> bool{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                  
                                  #[link(wasm_import_module = "entity")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "exists")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_exists")]
                                    fn wit_import(
                                    _: i64, _: i64, ) -> i32;
                                  }
                                  let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                  {
                                    #[cfg(not(debug_assertions))]
                                    { core::mem::transmute::<u8, bool>(ret as u8) }
                                    #[cfg(debug_assertions)]
                                    {
                                      match ret {
                                        0 => false,
                                        1 => true,
                                        _ => panic!("invalid bool discriminant"),
                                      }
                                    }
                                  }
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn get_all(index: u32,) -> wit_bindgen::rt::vec::Vec::<EntityId>{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  
                                  #[repr(align(4))]
                                  struct RetArea([u8; 8]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let ptr0 = ret_area.as_mut_ptr() as i32;
                                  #[link(wasm_import_module = "entity")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "get-all")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_get-all")]
                                    fn wit_import(
                                    _: i32, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i32(index), ptr0);
                                  let len1 = *((ptr0 + 4) as *const i32) as usize;
                                  Vec::from_raw_parts(*((ptr0 + 0) as *const i32) as *mut _, len1, len1)
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn resources() -> EntityId{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  
                                  #[repr(align(8))]
                                  struct RetArea([u8; 16]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let ptr0 = ret_area.as_mut_ptr() as i32;
                                  #[link(wasm_import_module = "entity")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "resources")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_resources")]
                                    fn wit_import(
                                    _: i32, );
                                  }
                                  wit_import(ptr0);
                                  super::types::EntityId{id0:*((ptr0 + 0) as *const i64) as u64, id1:*((ptr0 + 8) as *const i64) as u64, }
                                }
                              }
                              
                            }
                            
                            
                            #[allow(clippy::all)]
                            pub mod player{ use super::wit_bindgen;
                              pub type Vec2 = super::types::Vec2;
                              pub type EntityId = super::types::EntityId;
                              #[repr(u8)]
                              #[derive(Clone, Copy, PartialEq, Eq)]
                              pub enum VirtualKeyCode {
                                /// The '1' key over the letters.
                                Key1,
                                /// The '2' key over the letters.
                                Key2,
                                /// The '3' key over the letters.
                                Key3,
                                /// The '4' key over the letters.
                                Key4,
                                /// The '5' key over the letters.
                                Key5,
                                /// The '6' key over the letters.
                                Key6,
                                /// The '7' key over the letters.
                                Key7,
                                /// The '8' key over the letters.
                                Key8,
                                /// The '9' key over the letters.
                                Key9,
                                /// The '0' key over the 'O' and 'P' keys.
                                Key0,
                                A,
                                B,
                                C,
                                D,
                                E,
                                F,
                                G,
                                H,
                                I,
                                J,
                                K,
                                L,
                                M,
                                N,
                                O,
                                P,
                                Q,
                                R,
                                S,
                                T,
                                U,
                                V,
                                W,
                                X,
                                Y,
                                Z,
                                /// The Escape key, next to F1.
                                Escape,
                                F1,
                                F2,
                                F3,
                                F4,
                                F5,
                                F6,
                                F7,
                                F8,
                                F9,
                                F10,
                                F11,
                                F12,
                                F13,
                                F14,
                                F15,
                                F16,
                                F17,
                                F18,
                                F19,
                                F20,
                                F21,
                                F22,
                                F23,
                                F24,
                                /// Print Screen/SysRq.
                                Snapshot,
                                /// Scroll Lock.
                                Scroll,
                                /// Pause/Break key, next to Scroll lock.
                                Pause,
                                /// `Insert`, next to Backspace.
                                Insert,
                                Home,
                                Delete,
                                End,
                                PageDown,
                                PageUp,
                                Left,
                                Up,
                                Right,
                                Down,
                                /// The Backspace key, right over Enter.
                                Back,
                                /// The Enter key.
                                Return,
                                /// The space bar.
                                Space,
                                /// The "Compose" key on Linux.
                                Compose,
                                Caret,
                                Numlock,
                                Numpad0,
                                Numpad1,
                                Numpad2,
                                Numpad3,
                                Numpad4,
                                Numpad5,
                                Numpad6,
                                Numpad7,
                                Numpad8,
                                Numpad9,
                                NumpadAdd,
                                NumpadDivide,
                                NumpadDecimal,
                                NumpadComma,
                                NumpadEnter,
                                NumpadEquals,
                                NumpadMultiply,
                                NumpadSubtract,
                                AbntC1,
                                AbntC2,
                                Apostrophe,
                                Apps,
                                Asterisk,
                                At,
                                Ax,
                                Backslash,
                                Calculator,
                                Capital,
                                Colon,
                                Comma,
                                Convert,
                                Equals,
                                Grave,
                                Kana,
                                Kanji,
                                LAlt,
                                LBracket,
                                LControl,
                                LShift,
                                LWin,
                                Mail,
                                MediaSelect,
                                MediaStop,
                                Minus,
                                Mute,
                                MyComputer,
                                NavigateForward,
                                NavigateBackward,
                                NextTrack,
                                NoConvert,
                                Oem102,
                                Period,
                                PlayPause,
                                Plus,
                                Power,
                                PrevTrack,
                                RAlt,
                                RBracket,
                                RControl,
                                RShift,
                                RWin,
                                Semicolon,
                                Slash,
                                Sleep,
                                Stop,
                                Sysrq,
                                Tab,
                                Underline,
                                Unlabeled,
                                VolumeDown,
                                VolumeUp,
                                Wake,
                                WebBack,
                                WebFavorites,
                                WebForward,
                                WebHome,
                                WebRefresh,
                                WebSearch,
                                WebStop,
                                Yen,
                                Copy,
                                Paste,
                                Cut,
                              }
                              impl core::fmt::Debug for VirtualKeyCode {
                                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                  match self {
                                    VirtualKeyCode::Key1 => {
                                      f.debug_tuple("VirtualKeyCode::Key1").finish()
                                    }
                                    VirtualKeyCode::Key2 => {
                                      f.debug_tuple("VirtualKeyCode::Key2").finish()
                                    }
                                    VirtualKeyCode::Key3 => {
                                      f.debug_tuple("VirtualKeyCode::Key3").finish()
                                    }
                                    VirtualKeyCode::Key4 => {
                                      f.debug_tuple("VirtualKeyCode::Key4").finish()
                                    }
                                    VirtualKeyCode::Key5 => {
                                      f.debug_tuple("VirtualKeyCode::Key5").finish()
                                    }
                                    VirtualKeyCode::Key6 => {
                                      f.debug_tuple("VirtualKeyCode::Key6").finish()
                                    }
                                    VirtualKeyCode::Key7 => {
                                      f.debug_tuple("VirtualKeyCode::Key7").finish()
                                    }
                                    VirtualKeyCode::Key8 => {
                                      f.debug_tuple("VirtualKeyCode::Key8").finish()
                                    }
                                    VirtualKeyCode::Key9 => {
                                      f.debug_tuple("VirtualKeyCode::Key9").finish()
                                    }
                                    VirtualKeyCode::Key0 => {
                                      f.debug_tuple("VirtualKeyCode::Key0").finish()
                                    }
                                    VirtualKeyCode::A => {
                                      f.debug_tuple("VirtualKeyCode::A").finish()
                                    }
                                    VirtualKeyCode::B => {
                                      f.debug_tuple("VirtualKeyCode::B").finish()
                                    }
                                    VirtualKeyCode::C => {
                                      f.debug_tuple("VirtualKeyCode::C").finish()
                                    }
                                    VirtualKeyCode::D => {
                                      f.debug_tuple("VirtualKeyCode::D").finish()
                                    }
                                    VirtualKeyCode::E => {
                                      f.debug_tuple("VirtualKeyCode::E").finish()
                                    }
                                    VirtualKeyCode::F => {
                                      f.debug_tuple("VirtualKeyCode::F").finish()
                                    }
                                    VirtualKeyCode::G => {
                                      f.debug_tuple("VirtualKeyCode::G").finish()
                                    }
                                    VirtualKeyCode::H => {
                                      f.debug_tuple("VirtualKeyCode::H").finish()
                                    }
                                    VirtualKeyCode::I => {
                                      f.debug_tuple("VirtualKeyCode::I").finish()
                                    }
                                    VirtualKeyCode::J => {
                                      f.debug_tuple("VirtualKeyCode::J").finish()
                                    }
                                    VirtualKeyCode::K => {
                                      f.debug_tuple("VirtualKeyCode::K").finish()
                                    }
                                    VirtualKeyCode::L => {
                                      f.debug_tuple("VirtualKeyCode::L").finish()
                                    }
                                    VirtualKeyCode::M => {
                                      f.debug_tuple("VirtualKeyCode::M").finish()
                                    }
                                    VirtualKeyCode::N => {
                                      f.debug_tuple("VirtualKeyCode::N").finish()
                                    }
                                    VirtualKeyCode::O => {
                                      f.debug_tuple("VirtualKeyCode::O").finish()
                                    }
                                    VirtualKeyCode::P => {
                                      f.debug_tuple("VirtualKeyCode::P").finish()
                                    }
                                    VirtualKeyCode::Q => {
                                      f.debug_tuple("VirtualKeyCode::Q").finish()
                                    }
                                    VirtualKeyCode::R => {
                                      f.debug_tuple("VirtualKeyCode::R").finish()
                                    }
                                    VirtualKeyCode::S => {
                                      f.debug_tuple("VirtualKeyCode::S").finish()
                                    }
                                    VirtualKeyCode::T => {
                                      f.debug_tuple("VirtualKeyCode::T").finish()
                                    }
                                    VirtualKeyCode::U => {
                                      f.debug_tuple("VirtualKeyCode::U").finish()
                                    }
                                    VirtualKeyCode::V => {
                                      f.debug_tuple("VirtualKeyCode::V").finish()
                                    }
                                    VirtualKeyCode::W => {
                                      f.debug_tuple("VirtualKeyCode::W").finish()
                                    }
                                    VirtualKeyCode::X => {
                                      f.debug_tuple("VirtualKeyCode::X").finish()
                                    }
                                    VirtualKeyCode::Y => {
                                      f.debug_tuple("VirtualKeyCode::Y").finish()
                                    }
                                    VirtualKeyCode::Z => {
                                      f.debug_tuple("VirtualKeyCode::Z").finish()
                                    }
                                    VirtualKeyCode::Escape => {
                                      f.debug_tuple("VirtualKeyCode::Escape").finish()
                                    }
                                    VirtualKeyCode::F1 => {
                                      f.debug_tuple("VirtualKeyCode::F1").finish()
                                    }
                                    VirtualKeyCode::F2 => {
                                      f.debug_tuple("VirtualKeyCode::F2").finish()
                                    }
                                    VirtualKeyCode::F3 => {
                                      f.debug_tuple("VirtualKeyCode::F3").finish()
                                    }
                                    VirtualKeyCode::F4 => {
                                      f.debug_tuple("VirtualKeyCode::F4").finish()
                                    }
                                    VirtualKeyCode::F5 => {
                                      f.debug_tuple("VirtualKeyCode::F5").finish()
                                    }
                                    VirtualKeyCode::F6 => {
                                      f.debug_tuple("VirtualKeyCode::F6").finish()
                                    }
                                    VirtualKeyCode::F7 => {
                                      f.debug_tuple("VirtualKeyCode::F7").finish()
                                    }
                                    VirtualKeyCode::F8 => {
                                      f.debug_tuple("VirtualKeyCode::F8").finish()
                                    }
                                    VirtualKeyCode::F9 => {
                                      f.debug_tuple("VirtualKeyCode::F9").finish()
                                    }
                                    VirtualKeyCode::F10 => {
                                      f.debug_tuple("VirtualKeyCode::F10").finish()
                                    }
                                    VirtualKeyCode::F11 => {
                                      f.debug_tuple("VirtualKeyCode::F11").finish()
                                    }
                                    VirtualKeyCode::F12 => {
                                      f.debug_tuple("VirtualKeyCode::F12").finish()
                                    }
                                    VirtualKeyCode::F13 => {
                                      f.debug_tuple("VirtualKeyCode::F13").finish()
                                    }
                                    VirtualKeyCode::F14 => {
                                      f.debug_tuple("VirtualKeyCode::F14").finish()
                                    }
                                    VirtualKeyCode::F15 => {
                                      f.debug_tuple("VirtualKeyCode::F15").finish()
                                    }
                                    VirtualKeyCode::F16 => {
                                      f.debug_tuple("VirtualKeyCode::F16").finish()
                                    }
                                    VirtualKeyCode::F17 => {
                                      f.debug_tuple("VirtualKeyCode::F17").finish()
                                    }
                                    VirtualKeyCode::F18 => {
                                      f.debug_tuple("VirtualKeyCode::F18").finish()
                                    }
                                    VirtualKeyCode::F19 => {
                                      f.debug_tuple("VirtualKeyCode::F19").finish()
                                    }
                                    VirtualKeyCode::F20 => {
                                      f.debug_tuple("VirtualKeyCode::F20").finish()
                                    }
                                    VirtualKeyCode::F21 => {
                                      f.debug_tuple("VirtualKeyCode::F21").finish()
                                    }
                                    VirtualKeyCode::F22 => {
                                      f.debug_tuple("VirtualKeyCode::F22").finish()
                                    }
                                    VirtualKeyCode::F23 => {
                                      f.debug_tuple("VirtualKeyCode::F23").finish()
                                    }
                                    VirtualKeyCode::F24 => {
                                      f.debug_tuple("VirtualKeyCode::F24").finish()
                                    }
                                    VirtualKeyCode::Snapshot => {
                                      f.debug_tuple("VirtualKeyCode::Snapshot").finish()
                                    }
                                    VirtualKeyCode::Scroll => {
                                      f.debug_tuple("VirtualKeyCode::Scroll").finish()
                                    }
                                    VirtualKeyCode::Pause => {
                                      f.debug_tuple("VirtualKeyCode::Pause").finish()
                                    }
                                    VirtualKeyCode::Insert => {
                                      f.debug_tuple("VirtualKeyCode::Insert").finish()
                                    }
                                    VirtualKeyCode::Home => {
                                      f.debug_tuple("VirtualKeyCode::Home").finish()
                                    }
                                    VirtualKeyCode::Delete => {
                                      f.debug_tuple("VirtualKeyCode::Delete").finish()
                                    }
                                    VirtualKeyCode::End => {
                                      f.debug_tuple("VirtualKeyCode::End").finish()
                                    }
                                    VirtualKeyCode::PageDown => {
                                      f.debug_tuple("VirtualKeyCode::PageDown").finish()
                                    }
                                    VirtualKeyCode::PageUp => {
                                      f.debug_tuple("VirtualKeyCode::PageUp").finish()
                                    }
                                    VirtualKeyCode::Left => {
                                      f.debug_tuple("VirtualKeyCode::Left").finish()
                                    }
                                    VirtualKeyCode::Up => {
                                      f.debug_tuple("VirtualKeyCode::Up").finish()
                                    }
                                    VirtualKeyCode::Right => {
                                      f.debug_tuple("VirtualKeyCode::Right").finish()
                                    }
                                    VirtualKeyCode::Down => {
                                      f.debug_tuple("VirtualKeyCode::Down").finish()
                                    }
                                    VirtualKeyCode::Back => {
                                      f.debug_tuple("VirtualKeyCode::Back").finish()
                                    }
                                    VirtualKeyCode::Return => {
                                      f.debug_tuple("VirtualKeyCode::Return").finish()
                                    }
                                    VirtualKeyCode::Space => {
                                      f.debug_tuple("VirtualKeyCode::Space").finish()
                                    }
                                    VirtualKeyCode::Compose => {
                                      f.debug_tuple("VirtualKeyCode::Compose").finish()
                                    }
                                    VirtualKeyCode::Caret => {
                                      f.debug_tuple("VirtualKeyCode::Caret").finish()
                                    }
                                    VirtualKeyCode::Numlock => {
                                      f.debug_tuple("VirtualKeyCode::Numlock").finish()
                                    }
                                    VirtualKeyCode::Numpad0 => {
                                      f.debug_tuple("VirtualKeyCode::Numpad0").finish()
                                    }
                                    VirtualKeyCode::Numpad1 => {
                                      f.debug_tuple("VirtualKeyCode::Numpad1").finish()
                                    }
                                    VirtualKeyCode::Numpad2 => {
                                      f.debug_tuple("VirtualKeyCode::Numpad2").finish()
                                    }
                                    VirtualKeyCode::Numpad3 => {
                                      f.debug_tuple("VirtualKeyCode::Numpad3").finish()
                                    }
                                    VirtualKeyCode::Numpad4 => {
                                      f.debug_tuple("VirtualKeyCode::Numpad4").finish()
                                    }
                                    VirtualKeyCode::Numpad5 => {
                                      f.debug_tuple("VirtualKeyCode::Numpad5").finish()
                                    }
                                    VirtualKeyCode::Numpad6 => {
                                      f.debug_tuple("VirtualKeyCode::Numpad6").finish()
                                    }
                                    VirtualKeyCode::Numpad7 => {
                                      f.debug_tuple("VirtualKeyCode::Numpad7").finish()
                                    }
                                    VirtualKeyCode::Numpad8 => {
                                      f.debug_tuple("VirtualKeyCode::Numpad8").finish()
                                    }
                                    VirtualKeyCode::Numpad9 => {
                                      f.debug_tuple("VirtualKeyCode::Numpad9").finish()
                                    }
                                    VirtualKeyCode::NumpadAdd => {
                                      f.debug_tuple("VirtualKeyCode::NumpadAdd").finish()
                                    }
                                    VirtualKeyCode::NumpadDivide => {
                                      f.debug_tuple("VirtualKeyCode::NumpadDivide").finish()
                                    }
                                    VirtualKeyCode::NumpadDecimal => {
                                      f.debug_tuple("VirtualKeyCode::NumpadDecimal").finish()
                                    }
                                    VirtualKeyCode::NumpadComma => {
                                      f.debug_tuple("VirtualKeyCode::NumpadComma").finish()
                                    }
                                    VirtualKeyCode::NumpadEnter => {
                                      f.debug_tuple("VirtualKeyCode::NumpadEnter").finish()
                                    }
                                    VirtualKeyCode::NumpadEquals => {
                                      f.debug_tuple("VirtualKeyCode::NumpadEquals").finish()
                                    }
                                    VirtualKeyCode::NumpadMultiply => {
                                      f.debug_tuple("VirtualKeyCode::NumpadMultiply").finish()
                                    }
                                    VirtualKeyCode::NumpadSubtract => {
                                      f.debug_tuple("VirtualKeyCode::NumpadSubtract").finish()
                                    }
                                    VirtualKeyCode::AbntC1 => {
                                      f.debug_tuple("VirtualKeyCode::AbntC1").finish()
                                    }
                                    VirtualKeyCode::AbntC2 => {
                                      f.debug_tuple("VirtualKeyCode::AbntC2").finish()
                                    }
                                    VirtualKeyCode::Apostrophe => {
                                      f.debug_tuple("VirtualKeyCode::Apostrophe").finish()
                                    }
                                    VirtualKeyCode::Apps => {
                                      f.debug_tuple("VirtualKeyCode::Apps").finish()
                                    }
                                    VirtualKeyCode::Asterisk => {
                                      f.debug_tuple("VirtualKeyCode::Asterisk").finish()
                                    }
                                    VirtualKeyCode::At => {
                                      f.debug_tuple("VirtualKeyCode::At").finish()
                                    }
                                    VirtualKeyCode::Ax => {
                                      f.debug_tuple("VirtualKeyCode::Ax").finish()
                                    }
                                    VirtualKeyCode::Backslash => {
                                      f.debug_tuple("VirtualKeyCode::Backslash").finish()
                                    }
                                    VirtualKeyCode::Calculator => {
                                      f.debug_tuple("VirtualKeyCode::Calculator").finish()
                                    }
                                    VirtualKeyCode::Capital => {
                                      f.debug_tuple("VirtualKeyCode::Capital").finish()
                                    }
                                    VirtualKeyCode::Colon => {
                                      f.debug_tuple("VirtualKeyCode::Colon").finish()
                                    }
                                    VirtualKeyCode::Comma => {
                                      f.debug_tuple("VirtualKeyCode::Comma").finish()
                                    }
                                    VirtualKeyCode::Convert => {
                                      f.debug_tuple("VirtualKeyCode::Convert").finish()
                                    }
                                    VirtualKeyCode::Equals => {
                                      f.debug_tuple("VirtualKeyCode::Equals").finish()
                                    }
                                    VirtualKeyCode::Grave => {
                                      f.debug_tuple("VirtualKeyCode::Grave").finish()
                                    }
                                    VirtualKeyCode::Kana => {
                                      f.debug_tuple("VirtualKeyCode::Kana").finish()
                                    }
                                    VirtualKeyCode::Kanji => {
                                      f.debug_tuple("VirtualKeyCode::Kanji").finish()
                                    }
                                    VirtualKeyCode::LAlt => {
                                      f.debug_tuple("VirtualKeyCode::LAlt").finish()
                                    }
                                    VirtualKeyCode::LBracket => {
                                      f.debug_tuple("VirtualKeyCode::LBracket").finish()
                                    }
                                    VirtualKeyCode::LControl => {
                                      f.debug_tuple("VirtualKeyCode::LControl").finish()
                                    }
                                    VirtualKeyCode::LShift => {
                                      f.debug_tuple("VirtualKeyCode::LShift").finish()
                                    }
                                    VirtualKeyCode::LWin => {
                                      f.debug_tuple("VirtualKeyCode::LWin").finish()
                                    }
                                    VirtualKeyCode::Mail => {
                                      f.debug_tuple("VirtualKeyCode::Mail").finish()
                                    }
                                    VirtualKeyCode::MediaSelect => {
                                      f.debug_tuple("VirtualKeyCode::MediaSelect").finish()
                                    }
                                    VirtualKeyCode::MediaStop => {
                                      f.debug_tuple("VirtualKeyCode::MediaStop").finish()
                                    }
                                    VirtualKeyCode::Minus => {
                                      f.debug_tuple("VirtualKeyCode::Minus").finish()
                                    }
                                    VirtualKeyCode::Mute => {
                                      f.debug_tuple("VirtualKeyCode::Mute").finish()
                                    }
                                    VirtualKeyCode::MyComputer => {
                                      f.debug_tuple("VirtualKeyCode::MyComputer").finish()
                                    }
                                    VirtualKeyCode::NavigateForward => {
                                      f.debug_tuple("VirtualKeyCode::NavigateForward").finish()
                                    }
                                    VirtualKeyCode::NavigateBackward => {
                                      f.debug_tuple("VirtualKeyCode::NavigateBackward").finish()
                                    }
                                    VirtualKeyCode::NextTrack => {
                                      f.debug_tuple("VirtualKeyCode::NextTrack").finish()
                                    }
                                    VirtualKeyCode::NoConvert => {
                                      f.debug_tuple("VirtualKeyCode::NoConvert").finish()
                                    }
                                    VirtualKeyCode::Oem102 => {
                                      f.debug_tuple("VirtualKeyCode::Oem102").finish()
                                    }
                                    VirtualKeyCode::Period => {
                                      f.debug_tuple("VirtualKeyCode::Period").finish()
                                    }
                                    VirtualKeyCode::PlayPause => {
                                      f.debug_tuple("VirtualKeyCode::PlayPause").finish()
                                    }
                                    VirtualKeyCode::Plus => {
                                      f.debug_tuple("VirtualKeyCode::Plus").finish()
                                    }
                                    VirtualKeyCode::Power => {
                                      f.debug_tuple("VirtualKeyCode::Power").finish()
                                    }
                                    VirtualKeyCode::PrevTrack => {
                                      f.debug_tuple("VirtualKeyCode::PrevTrack").finish()
                                    }
                                    VirtualKeyCode::RAlt => {
                                      f.debug_tuple("VirtualKeyCode::RAlt").finish()
                                    }
                                    VirtualKeyCode::RBracket => {
                                      f.debug_tuple("VirtualKeyCode::RBracket").finish()
                                    }
                                    VirtualKeyCode::RControl => {
                                      f.debug_tuple("VirtualKeyCode::RControl").finish()
                                    }
                                    VirtualKeyCode::RShift => {
                                      f.debug_tuple("VirtualKeyCode::RShift").finish()
                                    }
                                    VirtualKeyCode::RWin => {
                                      f.debug_tuple("VirtualKeyCode::RWin").finish()
                                    }
                                    VirtualKeyCode::Semicolon => {
                                      f.debug_tuple("VirtualKeyCode::Semicolon").finish()
                                    }
                                    VirtualKeyCode::Slash => {
                                      f.debug_tuple("VirtualKeyCode::Slash").finish()
                                    }
                                    VirtualKeyCode::Sleep => {
                                      f.debug_tuple("VirtualKeyCode::Sleep").finish()
                                    }
                                    VirtualKeyCode::Stop => {
                                      f.debug_tuple("VirtualKeyCode::Stop").finish()
                                    }
                                    VirtualKeyCode::Sysrq => {
                                      f.debug_tuple("VirtualKeyCode::Sysrq").finish()
                                    }
                                    VirtualKeyCode::Tab => {
                                      f.debug_tuple("VirtualKeyCode::Tab").finish()
                                    }
                                    VirtualKeyCode::Underline => {
                                      f.debug_tuple("VirtualKeyCode::Underline").finish()
                                    }
                                    VirtualKeyCode::Unlabeled => {
                                      f.debug_tuple("VirtualKeyCode::Unlabeled").finish()
                                    }
                                    VirtualKeyCode::VolumeDown => {
                                      f.debug_tuple("VirtualKeyCode::VolumeDown").finish()
                                    }
                                    VirtualKeyCode::VolumeUp => {
                                      f.debug_tuple("VirtualKeyCode::VolumeUp").finish()
                                    }
                                    VirtualKeyCode::Wake => {
                                      f.debug_tuple("VirtualKeyCode::Wake").finish()
                                    }
                                    VirtualKeyCode::WebBack => {
                                      f.debug_tuple("VirtualKeyCode::WebBack").finish()
                                    }
                                    VirtualKeyCode::WebFavorites => {
                                      f.debug_tuple("VirtualKeyCode::WebFavorites").finish()
                                    }
                                    VirtualKeyCode::WebForward => {
                                      f.debug_tuple("VirtualKeyCode::WebForward").finish()
                                    }
                                    VirtualKeyCode::WebHome => {
                                      f.debug_tuple("VirtualKeyCode::WebHome").finish()
                                    }
                                    VirtualKeyCode::WebRefresh => {
                                      f.debug_tuple("VirtualKeyCode::WebRefresh").finish()
                                    }
                                    VirtualKeyCode::WebSearch => {
                                      f.debug_tuple("VirtualKeyCode::WebSearch").finish()
                                    }
                                    VirtualKeyCode::WebStop => {
                                      f.debug_tuple("VirtualKeyCode::WebStop").finish()
                                    }
                                    VirtualKeyCode::Yen => {
                                      f.debug_tuple("VirtualKeyCode::Yen").finish()
                                    }
                                    VirtualKeyCode::Copy => {
                                      f.debug_tuple("VirtualKeyCode::Copy").finish()
                                    }
                                    VirtualKeyCode::Paste => {
                                      f.debug_tuple("VirtualKeyCode::Paste").finish()
                                    }
                                    VirtualKeyCode::Cut => {
                                      f.debug_tuple("VirtualKeyCode::Cut").finish()
                                    }
                                  }
                                }
                              }
                              #[derive(Clone, Copy)]
                              pub enum MouseButton{
                                Left,
                                Right,
                                Middle,
                                Other(u16),
                              }
                              impl core::fmt::Debug for MouseButton {
                                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                  match self {
                                    MouseButton::Left => {
                                      f.debug_tuple("MouseButton::Left").finish()
                                    }
                                    MouseButton::Right => {
                                      f.debug_tuple("MouseButton::Right").finish()
                                    }
                                    MouseButton::Middle => {
                                      f.debug_tuple("MouseButton::Middle").finish()
                                    }
                                    MouseButton::Other(e) => {
                                      f.debug_tuple("MouseButton::Other").field(e).finish()
                                    }
                                  }
                                }
                              }
                              #[derive(Clone)]
                              pub struct RawInput {
                                pub keys: wit_bindgen::rt::vec::Vec::<VirtualKeyCode>,
                                pub mouse_position: Vec2,
                                pub cursor_position: Vec2,
                                pub mouse_wheel: f32,
                                pub mouse_buttons: wit_bindgen::rt::vec::Vec::<MouseButton>,
                              }
                              impl core::fmt::Debug for RawInput {
                                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                  f.debug_struct("RawInput").field("keys", &self.keys).field("mouse-position", &self.mouse_position).field("cursor-position", &self.cursor_position).field("mouse-wheel", &self.mouse_wheel).field("mouse-buttons", &self.mouse_buttons).finish()
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn get_raw_input(player: EntityId,) -> Option<RawInput>{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  
                                  #[repr(align(4))]
                                  struct RetArea([u8; 40]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let super::types::EntityId{ id0:id00, id1:id10, } = player;
                                  let ptr1 = ret_area.as_mut_ptr() as i32;
                                  #[link(wasm_import_module = "player")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "get-raw-input")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "player_get-raw-input")]
                                    fn wit_import(
                                    _: i64, _: i64, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1);
                                  match i32::from(*((ptr1 + 0) as *const u8)) {
                                    0 => None,
                                    1 => Some({
                                      let base2 = *((ptr1 + 4) as *const i32);
                                      let len2 = *((ptr1 + 8) as *const i32);
                                      let mut result2 = Vec::with_capacity(len2 as usize);
                                      for i in 0..len2 {
                                        let base = base2 + i *1;
                                        result2.push({#[cfg(debug_assertions)]{match i32::from(*((base + 0) as *const u8)) {
                                          0 => VirtualKeyCode::Key1,
                                          1 => VirtualKeyCode::Key2,
                                          2 => VirtualKeyCode::Key3,
                                          3 => VirtualKeyCode::Key4,
                                          4 => VirtualKeyCode::Key5,
                                          5 => VirtualKeyCode::Key6,
                                          6 => VirtualKeyCode::Key7,
                                          7 => VirtualKeyCode::Key8,
                                          8 => VirtualKeyCode::Key9,
                                          9 => VirtualKeyCode::Key0,
                                          10 => VirtualKeyCode::A,
                                          11 => VirtualKeyCode::B,
                                          12 => VirtualKeyCode::C,
                                          13 => VirtualKeyCode::D,
                                          14 => VirtualKeyCode::E,
                                          15 => VirtualKeyCode::F,
                                          16 => VirtualKeyCode::G,
                                          17 => VirtualKeyCode::H,
                                          18 => VirtualKeyCode::I,
                                          19 => VirtualKeyCode::J,
                                          20 => VirtualKeyCode::K,
                                          21 => VirtualKeyCode::L,
                                          22 => VirtualKeyCode::M,
                                          23 => VirtualKeyCode::N,
                                          24 => VirtualKeyCode::O,
                                          25 => VirtualKeyCode::P,
                                          26 => VirtualKeyCode::Q,
                                          27 => VirtualKeyCode::R,
                                          28 => VirtualKeyCode::S,
                                          29 => VirtualKeyCode::T,
                                          30 => VirtualKeyCode::U,
                                          31 => VirtualKeyCode::V,
                                          32 => VirtualKeyCode::W,
                                          33 => VirtualKeyCode::X,
                                          34 => VirtualKeyCode::Y,
                                          35 => VirtualKeyCode::Z,
                                          36 => VirtualKeyCode::Escape,
                                          37 => VirtualKeyCode::F1,
                                          38 => VirtualKeyCode::F2,
                                          39 => VirtualKeyCode::F3,
                                          40 => VirtualKeyCode::F4,
                                          41 => VirtualKeyCode::F5,
                                          42 => VirtualKeyCode::F6,
                                          43 => VirtualKeyCode::F7,
                                          44 => VirtualKeyCode::F8,
                                          45 => VirtualKeyCode::F9,
                                          46 => VirtualKeyCode::F10,
                                          47 => VirtualKeyCode::F11,
                                          48 => VirtualKeyCode::F12,
                                          49 => VirtualKeyCode::F13,
                                          50 => VirtualKeyCode::F14,
                                          51 => VirtualKeyCode::F15,
                                          52 => VirtualKeyCode::F16,
                                          53 => VirtualKeyCode::F17,
                                          54 => VirtualKeyCode::F18,
                                          55 => VirtualKeyCode::F19,
                                          56 => VirtualKeyCode::F20,
                                          57 => VirtualKeyCode::F21,
                                          58 => VirtualKeyCode::F22,
                                          59 => VirtualKeyCode::F23,
                                          60 => VirtualKeyCode::F24,
                                          61 => VirtualKeyCode::Snapshot,
                                          62 => VirtualKeyCode::Scroll,
                                          63 => VirtualKeyCode::Pause,
                                          64 => VirtualKeyCode::Insert,
                                          65 => VirtualKeyCode::Home,
                                          66 => VirtualKeyCode::Delete,
                                          67 => VirtualKeyCode::End,
                                          68 => VirtualKeyCode::PageDown,
                                          69 => VirtualKeyCode::PageUp,
                                          70 => VirtualKeyCode::Left,
                                          71 => VirtualKeyCode::Up,
                                          72 => VirtualKeyCode::Right,
                                          73 => VirtualKeyCode::Down,
                                          74 => VirtualKeyCode::Back,
                                          75 => VirtualKeyCode::Return,
                                          76 => VirtualKeyCode::Space,
                                          77 => VirtualKeyCode::Compose,
                                          78 => VirtualKeyCode::Caret,
                                          79 => VirtualKeyCode::Numlock,
                                          80 => VirtualKeyCode::Numpad0,
                                          81 => VirtualKeyCode::Numpad1,
                                          82 => VirtualKeyCode::Numpad2,
                                          83 => VirtualKeyCode::Numpad3,
                                          84 => VirtualKeyCode::Numpad4,
                                          85 => VirtualKeyCode::Numpad5,
                                          86 => VirtualKeyCode::Numpad6,
                                          87 => VirtualKeyCode::Numpad7,
                                          88 => VirtualKeyCode::Numpad8,
                                          89 => VirtualKeyCode::Numpad9,
                                          90 => VirtualKeyCode::NumpadAdd,
                                          91 => VirtualKeyCode::NumpadDivide,
                                          92 => VirtualKeyCode::NumpadDecimal,
                                          93 => VirtualKeyCode::NumpadComma,
                                          94 => VirtualKeyCode::NumpadEnter,
                                          95 => VirtualKeyCode::NumpadEquals,
                                          96 => VirtualKeyCode::NumpadMultiply,
                                          97 => VirtualKeyCode::NumpadSubtract,
                                          98 => VirtualKeyCode::AbntC1,
                                          99 => VirtualKeyCode::AbntC2,
                                          100 => VirtualKeyCode::Apostrophe,
                                          101 => VirtualKeyCode::Apps,
                                          102 => VirtualKeyCode::Asterisk,
                                          103 => VirtualKeyCode::At,
                                          104 => VirtualKeyCode::Ax,
                                          105 => VirtualKeyCode::Backslash,
                                          106 => VirtualKeyCode::Calculator,
                                          107 => VirtualKeyCode::Capital,
                                          108 => VirtualKeyCode::Colon,
                                          109 => VirtualKeyCode::Comma,
                                          110 => VirtualKeyCode::Convert,
                                          111 => VirtualKeyCode::Equals,
                                          112 => VirtualKeyCode::Grave,
                                          113 => VirtualKeyCode::Kana,
                                          114 => VirtualKeyCode::Kanji,
                                          115 => VirtualKeyCode::LAlt,
                                          116 => VirtualKeyCode::LBracket,
                                          117 => VirtualKeyCode::LControl,
                                          118 => VirtualKeyCode::LShift,
                                          119 => VirtualKeyCode::LWin,
                                          120 => VirtualKeyCode::Mail,
                                          121 => VirtualKeyCode::MediaSelect,
                                          122 => VirtualKeyCode::MediaStop,
                                          123 => VirtualKeyCode::Minus,
                                          124 => VirtualKeyCode::Mute,
                                          125 => VirtualKeyCode::MyComputer,
                                          126 => VirtualKeyCode::NavigateForward,
                                          127 => VirtualKeyCode::NavigateBackward,
                                          128 => VirtualKeyCode::NextTrack,
                                          129 => VirtualKeyCode::NoConvert,
                                          130 => VirtualKeyCode::Oem102,
                                          131 => VirtualKeyCode::Period,
                                          132 => VirtualKeyCode::PlayPause,
                                          133 => VirtualKeyCode::Plus,
                                          134 => VirtualKeyCode::Power,
                                          135 => VirtualKeyCode::PrevTrack,
                                          136 => VirtualKeyCode::RAlt,
                                          137 => VirtualKeyCode::RBracket,
                                          138 => VirtualKeyCode::RControl,
                                          139 => VirtualKeyCode::RShift,
                                          140 => VirtualKeyCode::RWin,
                                          141 => VirtualKeyCode::Semicolon,
                                          142 => VirtualKeyCode::Slash,
                                          143 => VirtualKeyCode::Sleep,
                                          144 => VirtualKeyCode::Stop,
                                          145 => VirtualKeyCode::Sysrq,
                                          146 => VirtualKeyCode::Tab,
                                          147 => VirtualKeyCode::Underline,
                                          148 => VirtualKeyCode::Unlabeled,
                                          149 => VirtualKeyCode::VolumeDown,
                                          150 => VirtualKeyCode::VolumeUp,
                                          151 => VirtualKeyCode::Wake,
                                          152 => VirtualKeyCode::WebBack,
                                          153 => VirtualKeyCode::WebFavorites,
                                          154 => VirtualKeyCode::WebForward,
                                          155 => VirtualKeyCode::WebHome,
                                          156 => VirtualKeyCode::WebRefresh,
                                          157 => VirtualKeyCode::WebSearch,
                                          158 => VirtualKeyCode::WebStop,
                                          159 => VirtualKeyCode::Yen,
                                          160 => VirtualKeyCode::Copy,
                                          161 => VirtualKeyCode::Paste,
                                          162 => VirtualKeyCode::Cut,
                                          _ => panic!("invalid enum discriminant"),
                                        }}#[cfg(not(debug_assertions))]{core::mem::transmute::<_, VirtualKeyCode>(i32::from(*((base + 0) as *const u8)) as u8)}});
                                      }
                                      wit_bindgen::rt::dealloc(base2, (len2 as usize) * 1, 1);
                                      let base3 = *((ptr1 + 32) as *const i32);
                                      let len3 = *((ptr1 + 36) as *const i32);
                                      let mut result3 = Vec::with_capacity(len3 as usize);
                                      for i in 0..len3 {
                                        let base = base3 + i *4;
                                        result3.push({{match i32::from(*((base + 0) as *const u8)) {
                                          0 => MouseButton::Left,
                                          1 => MouseButton::Right,
                                          2 => MouseButton::Middle,
                                          #[cfg(debug_assertions)]3 => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                          #[cfg(not(debug_assertions))]_ => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}});
                                      }
                                      wit_bindgen::rt::dealloc(base3, (len3 as usize) * 4, 2);
                                      
                                      RawInput{keys:result2, mouse_position:super::types::Vec2{x:*((ptr1 + 12) as *const f32), y:*((ptr1 + 16) as *const f32), }, cursor_position:super::types::Vec2{x:*((ptr1 + 20) as *const f32), y:*((ptr1 + 24) as *const f32), }, mouse_wheel:*((ptr1 + 28) as *const f32), mouse_buttons:result3, }
                                    }),
                                    #[cfg(not(debug_assertions))]
                                    _ => core::hint::unreachable_unchecked(),
                                    #[cfg(debug_assertions)]
                                    _ => panic!("invalid enum discriminant"),
                                  }
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn get_prev_raw_input(player: EntityId,) -> Option<RawInput>{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  
                                  #[repr(align(4))]
                                  struct RetArea([u8; 40]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let super::types::EntityId{ id0:id00, id1:id10, } = player;
                                  let ptr1 = ret_area.as_mut_ptr() as i32;
                                  #[link(wasm_import_module = "player")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "get-prev-raw-input")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "player_get-prev-raw-input")]
                                    fn wit_import(
                                    _: i64, _: i64, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1);
                                  match i32::from(*((ptr1 + 0) as *const u8)) {
                                    0 => None,
                                    1 => Some({
                                      let base2 = *((ptr1 + 4) as *const i32);
                                      let len2 = *((ptr1 + 8) as *const i32);
                                      let mut result2 = Vec::with_capacity(len2 as usize);
                                      for i in 0..len2 {
                                        let base = base2 + i *1;
                                        result2.push({#[cfg(debug_assertions)]{match i32::from(*((base + 0) as *const u8)) {
                                          0 => VirtualKeyCode::Key1,
                                          1 => VirtualKeyCode::Key2,
                                          2 => VirtualKeyCode::Key3,
                                          3 => VirtualKeyCode::Key4,
                                          4 => VirtualKeyCode::Key5,
                                          5 => VirtualKeyCode::Key6,
                                          6 => VirtualKeyCode::Key7,
                                          7 => VirtualKeyCode::Key8,
                                          8 => VirtualKeyCode::Key9,
                                          9 => VirtualKeyCode::Key0,
                                          10 => VirtualKeyCode::A,
                                          11 => VirtualKeyCode::B,
                                          12 => VirtualKeyCode::C,
                                          13 => VirtualKeyCode::D,
                                          14 => VirtualKeyCode::E,
                                          15 => VirtualKeyCode::F,
                                          16 => VirtualKeyCode::G,
                                          17 => VirtualKeyCode::H,
                                          18 => VirtualKeyCode::I,
                                          19 => VirtualKeyCode::J,
                                          20 => VirtualKeyCode::K,
                                          21 => VirtualKeyCode::L,
                                          22 => VirtualKeyCode::M,
                                          23 => VirtualKeyCode::N,
                                          24 => VirtualKeyCode::O,
                                          25 => VirtualKeyCode::P,
                                          26 => VirtualKeyCode::Q,
                                          27 => VirtualKeyCode::R,
                                          28 => VirtualKeyCode::S,
                                          29 => VirtualKeyCode::T,
                                          30 => VirtualKeyCode::U,
                                          31 => VirtualKeyCode::V,
                                          32 => VirtualKeyCode::W,
                                          33 => VirtualKeyCode::X,
                                          34 => VirtualKeyCode::Y,
                                          35 => VirtualKeyCode::Z,
                                          36 => VirtualKeyCode::Escape,
                                          37 => VirtualKeyCode::F1,
                                          38 => VirtualKeyCode::F2,
                                          39 => VirtualKeyCode::F3,
                                          40 => VirtualKeyCode::F4,
                                          41 => VirtualKeyCode::F5,
                                          42 => VirtualKeyCode::F6,
                                          43 => VirtualKeyCode::F7,
                                          44 => VirtualKeyCode::F8,
                                          45 => VirtualKeyCode::F9,
                                          46 => VirtualKeyCode::F10,
                                          47 => VirtualKeyCode::F11,
                                          48 => VirtualKeyCode::F12,
                                          49 => VirtualKeyCode::F13,
                                          50 => VirtualKeyCode::F14,
                                          51 => VirtualKeyCode::F15,
                                          52 => VirtualKeyCode::F16,
                                          53 => VirtualKeyCode::F17,
                                          54 => VirtualKeyCode::F18,
                                          55 => VirtualKeyCode::F19,
                                          56 => VirtualKeyCode::F20,
                                          57 => VirtualKeyCode::F21,
                                          58 => VirtualKeyCode::F22,
                                          59 => VirtualKeyCode::F23,
                                          60 => VirtualKeyCode::F24,
                                          61 => VirtualKeyCode::Snapshot,
                                          62 => VirtualKeyCode::Scroll,
                                          63 => VirtualKeyCode::Pause,
                                          64 => VirtualKeyCode::Insert,
                                          65 => VirtualKeyCode::Home,
                                          66 => VirtualKeyCode::Delete,
                                          67 => VirtualKeyCode::End,
                                          68 => VirtualKeyCode::PageDown,
                                          69 => VirtualKeyCode::PageUp,
                                          70 => VirtualKeyCode::Left,
                                          71 => VirtualKeyCode::Up,
                                          72 => VirtualKeyCode::Right,
                                          73 => VirtualKeyCode::Down,
                                          74 => VirtualKeyCode::Back,
                                          75 => VirtualKeyCode::Return,
                                          76 => VirtualKeyCode::Space,
                                          77 => VirtualKeyCode::Compose,
                                          78 => VirtualKeyCode::Caret,
                                          79 => VirtualKeyCode::Numlock,
                                          80 => VirtualKeyCode::Numpad0,
                                          81 => VirtualKeyCode::Numpad1,
                                          82 => VirtualKeyCode::Numpad2,
                                          83 => VirtualKeyCode::Numpad3,
                                          84 => VirtualKeyCode::Numpad4,
                                          85 => VirtualKeyCode::Numpad5,
                                          86 => VirtualKeyCode::Numpad6,
                                          87 => VirtualKeyCode::Numpad7,
                                          88 => VirtualKeyCode::Numpad8,
                                          89 => VirtualKeyCode::Numpad9,
                                          90 => VirtualKeyCode::NumpadAdd,
                                          91 => VirtualKeyCode::NumpadDivide,
                                          92 => VirtualKeyCode::NumpadDecimal,
                                          93 => VirtualKeyCode::NumpadComma,
                                          94 => VirtualKeyCode::NumpadEnter,
                                          95 => VirtualKeyCode::NumpadEquals,
                                          96 => VirtualKeyCode::NumpadMultiply,
                                          97 => VirtualKeyCode::NumpadSubtract,
                                          98 => VirtualKeyCode::AbntC1,
                                          99 => VirtualKeyCode::AbntC2,
                                          100 => VirtualKeyCode::Apostrophe,
                                          101 => VirtualKeyCode::Apps,
                                          102 => VirtualKeyCode::Asterisk,
                                          103 => VirtualKeyCode::At,
                                          104 => VirtualKeyCode::Ax,
                                          105 => VirtualKeyCode::Backslash,
                                          106 => VirtualKeyCode::Calculator,
                                          107 => VirtualKeyCode::Capital,
                                          108 => VirtualKeyCode::Colon,
                                          109 => VirtualKeyCode::Comma,
                                          110 => VirtualKeyCode::Convert,
                                          111 => VirtualKeyCode::Equals,
                                          112 => VirtualKeyCode::Grave,
                                          113 => VirtualKeyCode::Kana,
                                          114 => VirtualKeyCode::Kanji,
                                          115 => VirtualKeyCode::LAlt,
                                          116 => VirtualKeyCode::LBracket,
                                          117 => VirtualKeyCode::LControl,
                                          118 => VirtualKeyCode::LShift,
                                          119 => VirtualKeyCode::LWin,
                                          120 => VirtualKeyCode::Mail,
                                          121 => VirtualKeyCode::MediaSelect,
                                          122 => VirtualKeyCode::MediaStop,
                                          123 => VirtualKeyCode::Minus,
                                          124 => VirtualKeyCode::Mute,
                                          125 => VirtualKeyCode::MyComputer,
                                          126 => VirtualKeyCode::NavigateForward,
                                          127 => VirtualKeyCode::NavigateBackward,
                                          128 => VirtualKeyCode::NextTrack,
                                          129 => VirtualKeyCode::NoConvert,
                                          130 => VirtualKeyCode::Oem102,
                                          131 => VirtualKeyCode::Period,
                                          132 => VirtualKeyCode::PlayPause,
                                          133 => VirtualKeyCode::Plus,
                                          134 => VirtualKeyCode::Power,
                                          135 => VirtualKeyCode::PrevTrack,
                                          136 => VirtualKeyCode::RAlt,
                                          137 => VirtualKeyCode::RBracket,
                                          138 => VirtualKeyCode::RControl,
                                          139 => VirtualKeyCode::RShift,
                                          140 => VirtualKeyCode::RWin,
                                          141 => VirtualKeyCode::Semicolon,
                                          142 => VirtualKeyCode::Slash,
                                          143 => VirtualKeyCode::Sleep,
                                          144 => VirtualKeyCode::Stop,
                                          145 => VirtualKeyCode::Sysrq,
                                          146 => VirtualKeyCode::Tab,
                                          147 => VirtualKeyCode::Underline,
                                          148 => VirtualKeyCode::Unlabeled,
                                          149 => VirtualKeyCode::VolumeDown,
                                          150 => VirtualKeyCode::VolumeUp,
                                          151 => VirtualKeyCode::Wake,
                                          152 => VirtualKeyCode::WebBack,
                                          153 => VirtualKeyCode::WebFavorites,
                                          154 => VirtualKeyCode::WebForward,
                                          155 => VirtualKeyCode::WebHome,
                                          156 => VirtualKeyCode::WebRefresh,
                                          157 => VirtualKeyCode::WebSearch,
                                          158 => VirtualKeyCode::WebStop,
                                          159 => VirtualKeyCode::Yen,
                                          160 => VirtualKeyCode::Copy,
                                          161 => VirtualKeyCode::Paste,
                                          162 => VirtualKeyCode::Cut,
                                          _ => panic!("invalid enum discriminant"),
                                        }}#[cfg(not(debug_assertions))]{core::mem::transmute::<_, VirtualKeyCode>(i32::from(*((base + 0) as *const u8)) as u8)}});
                                      }
                                      wit_bindgen::rt::dealloc(base2, (len2 as usize) * 1, 1);
                                      let base3 = *((ptr1 + 32) as *const i32);
                                      let len3 = *((ptr1 + 36) as *const i32);
                                      let mut result3 = Vec::with_capacity(len3 as usize);
                                      for i in 0..len3 {
                                        let base = base3 + i *4;
                                        result3.push({{match i32::from(*((base + 0) as *const u8)) {
                                          0 => MouseButton::Left,
                                          1 => MouseButton::Right,
                                          2 => MouseButton::Middle,
                                          #[cfg(debug_assertions)]3 => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                          #[cfg(not(debug_assertions))]_ => MouseButton::Other(i32::from(*((base + 2) as *const u16)) as u16),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}});
                                      }
                                      wit_bindgen::rt::dealloc(base3, (len3 as usize) * 4, 2);
                                      
                                      RawInput{keys:result2, mouse_position:super::types::Vec2{x:*((ptr1 + 12) as *const f32), y:*((ptr1 + 16) as *const f32), }, cursor_position:super::types::Vec2{x:*((ptr1 + 20) as *const f32), y:*((ptr1 + 24) as *const f32), }, mouse_wheel:*((ptr1 + 28) as *const f32), mouse_buttons:result3, }
                                    }),
                                    #[cfg(not(debug_assertions))]
                                    _ => core::hint::unreachable_unchecked(),
                                    #[cfg(debug_assertions)]
                                    _ => panic!("invalid enum discriminant"),
                                  }
                                }
                              }
                              
                            }
                            
                            
                            #[allow(clippy::all)]
                            pub mod physics{ use super::wit_bindgen;
                              pub type EntityId = super::types::EntityId;
                              pub type Vec3 = super::types::Vec3;
                              #[repr(C)]
                              #[derive(Copy, Clone)]
                              pub struct CharacterCollision {
                                pub side: bool,
                                pub up: bool,
                                pub down: bool,
                              }
                              impl core::fmt::Debug for CharacterCollision {
                                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                                  f.debug_struct("CharacterCollision").field("side", &self.side).field("up", &self.up).field("down", &self.down).finish()
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn apply_force(entities: &[EntityId],force: Vec3,){
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  let vec0 = entities;
                                  let ptr0 = vec0.as_ptr() as i32;
                                  let len0 = vec0.len() as i32;
                                  let super::types::Vec3{ x:x1, y:y1, z:z1, } = force;
                                  
                                  #[link(wasm_import_module = "physics")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "apply-force")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "physics_apply-force")]
                                    fn wit_import(
                                    _: i32, _: i32, _: f32, _: f32, _: f32, );
                                  }
                                  wit_import(ptr0, len0, wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1));
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn explode_bomb(position: Vec3,force: f32,radius: f32,falloff_radius: Option<f32>,){
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  let super::types::Vec3{ x:x0, y:y0, z:z0, } = position;
                                  let (result1_0,result1_1,) = match falloff_radius {
                                    Some(e) => (1i32, wit_bindgen::rt::as_f32(e)),
                                    None => {
                                      (0i32, 0.0f32)
                                    },
                                  };
                                  #[link(wasm_import_module = "physics")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "explode-bomb")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "physics_explode-bomb")]
                                    fn wit_import(
                                    _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, _: f32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(force), wit_bindgen::rt::as_f32(radius), result1_0, result1_1);
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn set_gravity(gravity: Vec3,){
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  let super::types::Vec3{ x:x0, y:y0, z:z0, } = gravity;
                                  
                                  #[link(wasm_import_module = "physics")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "set-gravity")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "physics_set-gravity")]
                                    fn wit_import(
                                    _: f32, _: f32, _: f32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0));
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn unfreeze(entity: EntityId,){
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                  
                                  #[link(wasm_import_module = "physics")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "unfreeze")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "physics_unfreeze")]
                                    fn wit_import(
                                    _: i64, _: i64, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn freeze(entity: EntityId,){
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                  
                                  #[link(wasm_import_module = "physics")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "freeze")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "physics_freeze")]
                                    fn wit_import(
                                    _: i64, _: i64, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn start_motor(entity: EntityId,velocity: f32,){
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                  
                                  #[link(wasm_import_module = "physics")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "start-motor")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "physics_start-motor")]
                                    fn wit_import(
                                    _: i64, _: i64, _: f32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(velocity));
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn stop_motor(entity: EntityId,){
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                  
                                  #[link(wasm_import_module = "physics")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "stop-motor")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "physics_stop-motor")]
                                    fn wit_import(
                                    _: i64, _: i64, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10));
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn raycast_first(origin: Vec3,direction: Vec3,) -> Option<(EntityId,f32,)>{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  
                                  #[repr(align(8))]
                                  struct RetArea([u8; 32]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let super::types::Vec3{ x:x0, y:y0, z:z0, } = origin;
                                  let super::types::Vec3{ x:x1, y:y1, z:z1, } = direction;
                                  let ptr2 = ret_area.as_mut_ptr() as i32;
                                  #[link(wasm_import_module = "physics")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "raycast-first")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "physics_raycast-first")]
                                    fn wit_import(
                                    _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), ptr2);
                                  match i32::from(*((ptr2 + 0) as *const u8)) {
                                    0 => None,
                                    1 => Some((super::types::EntityId{id0:*((ptr2 + 8) as *const i64) as u64, id1:*((ptr2 + 16) as *const i64) as u64, }, *((ptr2 + 24) as *const f32))),
                                    #[cfg(not(debug_assertions))]
                                    _ => core::hint::unreachable_unchecked(),
                                    #[cfg(debug_assertions)]
                                    _ => panic!("invalid enum discriminant"),
                                  }
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn raycast(origin: Vec3,direction: Vec3,) -> wit_bindgen::rt::vec::Vec::<(EntityId,f32,)>{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  
                                  #[repr(align(4))]
                                  struct RetArea([u8; 8]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let super::types::Vec3{ x:x0, y:y0, z:z0, } = origin;
                                  let super::types::Vec3{ x:x1, y:y1, z:z1, } = direction;
                                  let ptr2 = ret_area.as_mut_ptr() as i32;
                                  #[link(wasm_import_module = "physics")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "raycast")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "physics_raycast")]
                                    fn wit_import(
                                    _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_f32(x0), wit_bindgen::rt::as_f32(y0), wit_bindgen::rt::as_f32(z0), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), ptr2);
                                  let len3 = *((ptr2 + 4) as *const i32) as usize;
                                  Vec::from_raw_parts(*((ptr2 + 0) as *const i32) as *mut _, len3, len3)
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn move_character(entity: EntityId,displacement: Vec3,min_dist: f32,elapsed_time: f32,) -> CharacterCollision{
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  
                                  #[repr(align(1))]
                                  struct RetArea([u8; 3]);
                                  let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                  let super::types::EntityId{ id0:id00, id1:id10, } = entity;
                                  let super::types::Vec3{ x:x1, y:y1, z:z1, } = displacement;
                                  let ptr2 = ret_area.as_mut_ptr() as i32;
                                  #[link(wasm_import_module = "physics")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "move-character")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "physics_move-character")]
                                    fn wit_import(
                                    _: i64, _: i64, _: f32, _: f32, _: f32, _: f32, _: f32, _: i32, );
                                  }
                                  wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_f32(x1), wit_bindgen::rt::as_f32(y1), wit_bindgen::rt::as_f32(z1), wit_bindgen::rt::as_f32(min_dist), wit_bindgen::rt::as_f32(elapsed_time), ptr2);
                                  CharacterCollision{side:{
                                    #[cfg(not(debug_assertions))]
                                    { core::mem::transmute::<u8, bool>(i32::from(*((ptr2 + 0) as *const u8)) as u8) }
                                    #[cfg(debug_assertions)]
                                    {
                                      match i32::from(*((ptr2 + 0) as *const u8)) {
                                        0 => false,
                                        1 => true,
                                        _ => panic!("invalid bool discriminant"),
                                      }
                                    }
                                  }, up:{
                                    #[cfg(not(debug_assertions))]
                                    { core::mem::transmute::<u8, bool>(i32::from(*((ptr2 + 1) as *const u8)) as u8) }
                                    #[cfg(debug_assertions)]
                                    {
                                      match i32::from(*((ptr2 + 1) as *const u8)) {
                                        0 => false,
                                        1 => true,
                                        _ => panic!("invalid bool discriminant"),
                                      }
                                    }
                                  }, down:{
                                    #[cfg(not(debug_assertions))]
                                    { core::mem::transmute::<u8, bool>(i32::from(*((ptr2 + 2) as *const u8)) as u8) }
                                    #[cfg(debug_assertions)]
                                    {
                                      match i32::from(*((ptr2 + 2) as *const u8)) {
                                        0 => false,
                                        1 => true,
                                        _ => panic!("invalid bool discriminant"),
                                      }
                                    }
                                  }, }
                                }
                              }
                              
                            }
                            
                            
                            #[allow(clippy::all)]
                            pub mod event{ use super::wit_bindgen;
                              pub type Entity<'a,> = super::component::Entity<'a,>;
                              #[allow(clippy::all)]
                              pub fn subscribe(name: &str,){
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  let vec0 = name;
                                  let ptr0 = vec0.as_ptr() as i32;
                                  let len0 = vec0.len() as i32;
                                  
                                  #[link(wasm_import_module = "event")]
                                  extern "C" {
                                    #[cfg_attr(target_arch = "wasm32", link_name = "subscribe")]
                                    #[cfg_attr(not(target_arch = "wasm32"), link_name = "event_subscribe")]
                                    fn wit_import(
                                    _: i32, _: i32, );
                                  }
                                  wit_import(ptr0, len0);
                                }
                              }
                              #[allow(clippy::all)]
                              pub fn send(name: &str,data: Entity<'_,>,){
                                
                                #[allow(unused_imports)]
                                use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                unsafe {
                                  let mut cleanup_list = Vec::new();
                                  let vec0 = name;
                                  let ptr0 = vec0.as_ptr() as i32;
                                  let len0 = vec0.len() as i32;
                                  let vec50 = data;
                                  let len50 = vec50.len() as i32;
                                  let layout50 = alloc::Layout::from_size_align_unchecked(vec50.len() * 96, 8);
                                  let result50 = if layout50.size() != 0
                                  {
                                    let ptr = alloc::alloc(layout50);
                                    if ptr.is_null()
                                    {
                                      alloc::handle_alloc_error(layout50);
                                    }
                                    ptr
                                  }else {
                                    core::ptr::null_mut()
                                  };
                                  for (i, e) in vec50.into_iter().enumerate() {
                                    let base = result50 as i32 + (i as i32) * 96;
                                    {
                                      let (t1_0, t1_1, ) = e;
                                      *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t1_0);
                                      match t1_1 {
                                        super::component::ComponentTypeParam::TypeEmpty(e) => {
                                          *((base + 8) as *mut u8) = (0i32) as u8;
                                          let () = e;
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeBool(e) => {
                                          *((base + 8) as *mut u8) = (1i32) as u8;
                                          *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeEntityId(e) => {
                                          *((base + 8) as *mut u8) = (2i32) as u8;
                                          let super::types::EntityId{ id0:id03, id1:id13, } = e;
                                          *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id03);
                                          *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id13);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeF32(e) => {
                                          *((base + 8) as *mut u8) = (3i32) as u8;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeF64(e) => {
                                          *((base + 8) as *mut u8) = (4i32) as u8;
                                          *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeMat4(e) => {
                                          *((base + 8) as *mut u8) = (5i32) as u8;
                                          let super::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
                                          let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                                          *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                                          *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                                          *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                                          let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
                                          *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                                          *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                                          *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                                          *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                                          let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
                                          *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                                          *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                                          *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                                          *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                                          let super::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
                                          *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                                          *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                                          *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                                          *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeI32(e) => {
                                          *((base + 8) as *mut u8) = (6i32) as u8;
                                          *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeQuat(e) => {
                                          *((base + 8) as *mut u8) = (7i32) as u8;
                                          let super::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x9);
                                          *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y9);
                                          *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z9);
                                          *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w9);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeString(e) => {
                                          *((base + 8) as *mut u8) = (8i32) as u8;
                                          let vec10 = e;
                                          let ptr10 = vec10.as_ptr() as i32;
                                          let len10 = vec10.len() as i32;
                                          *((base + 20) as *mut i32) = len10;
                                          *((base + 16) as *mut i32) = ptr10;
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeU32(e) => {
                                          *((base + 8) as *mut u8) = (9i32) as u8;
                                          *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeU64(e) => {
                                          *((base + 8) as *mut u8) = (10i32) as u8;
                                          *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeVec2(e) => {
                                          *((base + 8) as *mut u8) = (11i32) as u8;
                                          let super::types::Vec2{ x:x11, y:y11, } = e;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                                          *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeVec3(e) => {
                                          *((base + 8) as *mut u8) = (12i32) as u8;
                                          let super::types::Vec3{ x:x12, y:y12, z:z12, } = e;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                                          *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                                          *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeVec4(e) => {
                                          *((base + 8) as *mut u8) = (13i32) as u8;
                                          let super::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
                                          *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x13);
                                          *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y13);
                                          *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z13);
                                          *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w13);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeUvec2(e) => {
                                          *((base + 8) as *mut u8) = (14i32) as u8;
                                          let super::types::Uvec2{ x:x14, y:y14, } = e;
                                          *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                                          *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeUvec3(e) => {
                                          *((base + 8) as *mut u8) = (15i32) as u8;
                                          let super::types::Uvec3{ x:x15, y:y15, z:z15, } = e;
                                          *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                                          *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                                          *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeUvec4(e) => {
                                          *((base + 8) as *mut u8) = (16i32) as u8;
                                          let super::types::Uvec4{ x:x16, y:y16, z:z16, w:w16, } = e;
                                          *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                                          *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                                          *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z16);
                                          *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w16);
                                          
                                        },
                                        super::component::ComponentTypeParam::TypeList(e) => {
                                          *((base + 8) as *mut u8) = (17i32) as u8;
                                          match e {
                                            super::component::ComponentListTypeParam::TypeEmpty(e) => {
                                              *((base + 16) as *mut u8) = (0i32) as u8;
                                              let vec17 = e;
                                              let ptr17 = vec17.as_ptr() as i32;
                                              let len17 = vec17.len() as i32;
                                              *((base + 24) as *mut i32) = len17;
                                              *((base + 20) as *mut i32) = ptr17;
                                              
                                            },
                                            super::component::ComponentListTypeParam::TypeBool(e) => {
                                              *((base + 16) as *mut u8) = (1i32) as u8;
                                              let vec18 = e;
                                              let len18 = vec18.len() as i32;
                                              let layout18 = alloc::Layout::from_size_align_unchecked(vec18.len() * 1, 1);
                                              let result18 = if layout18.size() != 0
                                              {
                                                let ptr = alloc::alloc(layout18);
                                                if ptr.is_null()
                                                {
                                                  alloc::handle_alloc_error(layout18);
                                                }
                                                ptr
                                              }else {
                                                core::ptr::null_mut()
                                              };
                                              for (i, e) in vec18.into_iter().enumerate() {
                                                let base = result18 as i32 + (i as i32) * 1;
                                                {
                                                  *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                                  
                                                }}
                                                *((base + 24) as *mut i32) = len18;
                                                *((base + 20) as *mut i32) = result18 as i32;
                                                cleanup_list.extend_from_slice(&[(result18, layout18),]);
                                                
                                              },
                                              super::component::ComponentListTypeParam::TypeEntityId(e) => {
                                                *((base + 16) as *mut u8) = (2i32) as u8;
                                                let vec19 = e;
                                                let ptr19 = vec19.as_ptr() as i32;
                                                let len19 = vec19.len() as i32;
                                                *((base + 24) as *mut i32) = len19;
                                                *((base + 20) as *mut i32) = ptr19;
                                                
                                              },
                                              super::component::ComponentListTypeParam::TypeF32(e) => {
                                                *((base + 16) as *mut u8) = (3i32) as u8;
                                                let vec20 = e;
                                                let ptr20 = vec20.as_ptr() as i32;
                                                let len20 = vec20.len() as i32;
                                                *((base + 24) as *mut i32) = len20;
                                                *((base + 20) as *mut i32) = ptr20;
                                                
                                              },
                                              super::component::ComponentListTypeParam::TypeF64(e) => {
                                                *((base + 16) as *mut u8) = (4i32) as u8;
                                                let vec21 = e;
                                                let ptr21 = vec21.as_ptr() as i32;
                                                let len21 = vec21.len() as i32;
                                                *((base + 24) as *mut i32) = len21;
                                                *((base + 20) as *mut i32) = ptr21;
                                                
                                              },
                                              super::component::ComponentListTypeParam::TypeMat4(e) => {
                                                *((base + 16) as *mut u8) = (5i32) as u8;
                                                let vec22 = e;
                                                let ptr22 = vec22.as_ptr() as i32;
                                                let len22 = vec22.len() as i32;
                                                *((base + 24) as *mut i32) = len22;
                                                *((base + 20) as *mut i32) = ptr22;
                                                
                                              },
                                              super::component::ComponentListTypeParam::TypeI32(e) => {
                                                *((base + 16) as *mut u8) = (6i32) as u8;
                                                let vec23 = e;
                                                let ptr23 = vec23.as_ptr() as i32;
                                                let len23 = vec23.len() as i32;
                                                *((base + 24) as *mut i32) = len23;
                                                *((base + 20) as *mut i32) = ptr23;
                                                
                                              },
                                              super::component::ComponentListTypeParam::TypeQuat(e) => {
                                                *((base + 16) as *mut u8) = (7i32) as u8;
                                                let vec24 = e;
                                                let ptr24 = vec24.as_ptr() as i32;
                                                let len24 = vec24.len() as i32;
                                                *((base + 24) as *mut i32) = len24;
                                                *((base + 20) as *mut i32) = ptr24;
                                                
                                              },
                                              super::component::ComponentListTypeParam::TypeString(e) => {
                                                *((base + 16) as *mut u8) = (8i32) as u8;
                                                let vec26 = e;
                                                let len26 = vec26.len() as i32;
                                                let layout26 = alloc::Layout::from_size_align_unchecked(vec26.len() * 8, 4);
                                                let result26 = if layout26.size() != 0
                                                {
                                                  let ptr = alloc::alloc(layout26);
                                                  if ptr.is_null()
                                                  {
                                                    alloc::handle_alloc_error(layout26);
                                                  }
                                                  ptr
                                                }else {
                                                  core::ptr::null_mut()
                                                };
                                                for (i, e) in vec26.into_iter().enumerate() {
                                                  let base = result26 as i32 + (i as i32) * 8;
                                                  {
                                                    let vec25 = e;
                                                    let ptr25 = vec25.as_ptr() as i32;
                                                    let len25 = vec25.len() as i32;
                                                    *((base + 4) as *mut i32) = len25;
                                                    *((base + 0) as *mut i32) = ptr25;
                                                    
                                                  }}
                                                  *((base + 24) as *mut i32) = len26;
                                                  *((base + 20) as *mut i32) = result26 as i32;
                                                  cleanup_list.extend_from_slice(&[(result26, layout26),]);
                                                  
                                                },
                                                super::component::ComponentListTypeParam::TypeU32(e) => {
                                                  *((base + 16) as *mut u8) = (9i32) as u8;
                                                  let vec27 = e;
                                                  let ptr27 = vec27.as_ptr() as i32;
                                                  let len27 = vec27.len() as i32;
                                                  *((base + 24) as *mut i32) = len27;
                                                  *((base + 20) as *mut i32) = ptr27;
                                                  
                                                },
                                                super::component::ComponentListTypeParam::TypeU64(e) => {
                                                  *((base + 16) as *mut u8) = (10i32) as u8;
                                                  let vec28 = e;
                                                  let ptr28 = vec28.as_ptr() as i32;
                                                  let len28 = vec28.len() as i32;
                                                  *((base + 24) as *mut i32) = len28;
                                                  *((base + 20) as *mut i32) = ptr28;
                                                  
                                                },
                                                super::component::ComponentListTypeParam::TypeVec2(e) => {
                                                  *((base + 16) as *mut u8) = (11i32) as u8;
                                                  let vec29 = e;
                                                  let ptr29 = vec29.as_ptr() as i32;
                                                  let len29 = vec29.len() as i32;
                                                  *((base + 24) as *mut i32) = len29;
                                                  *((base + 20) as *mut i32) = ptr29;
                                                  
                                                },
                                                super::component::ComponentListTypeParam::TypeVec3(e) => {
                                                  *((base + 16) as *mut u8) = (12i32) as u8;
                                                  let vec30 = e;
                                                  let ptr30 = vec30.as_ptr() as i32;
                                                  let len30 = vec30.len() as i32;
                                                  *((base + 24) as *mut i32) = len30;
                                                  *((base + 20) as *mut i32) = ptr30;
                                                  
                                                },
                                                super::component::ComponentListTypeParam::TypeVec4(e) => {
                                                  *((base + 16) as *mut u8) = (13i32) as u8;
                                                  let vec31 = e;
                                                  let ptr31 = vec31.as_ptr() as i32;
                                                  let len31 = vec31.len() as i32;
                                                  *((base + 24) as *mut i32) = len31;
                                                  *((base + 20) as *mut i32) = ptr31;
                                                  
                                                },
                                                super::component::ComponentListTypeParam::TypeUvec2(e) => {
                                                  *((base + 16) as *mut u8) = (14i32) as u8;
                                                  let vec32 = e;
                                                  let ptr32 = vec32.as_ptr() as i32;
                                                  let len32 = vec32.len() as i32;
                                                  *((base + 24) as *mut i32) = len32;
                                                  *((base + 20) as *mut i32) = ptr32;
                                                  
                                                },
                                                super::component::ComponentListTypeParam::TypeUvec3(e) => {
                                                  *((base + 16) as *mut u8) = (15i32) as u8;
                                                  let vec33 = e;
                                                  let ptr33 = vec33.as_ptr() as i32;
                                                  let len33 = vec33.len() as i32;
                                                  *((base + 24) as *mut i32) = len33;
                                                  *((base + 20) as *mut i32) = ptr33;
                                                  
                                                },
                                                super::component::ComponentListTypeParam::TypeUvec4(e) => {
                                                  *((base + 16) as *mut u8) = (16i32) as u8;
                                                  let vec34 = e;
                                                  let ptr34 = vec34.as_ptr() as i32;
                                                  let len34 = vec34.len() as i32;
                                                  *((base + 24) as *mut i32) = len34;
                                                  *((base + 20) as *mut i32) = ptr34;
                                                  
                                                },
                                              };
                                              
                                            },
                                            super::component::ComponentTypeParam::TypeOption(e) => {
                                              *((base + 8) as *mut u8) = (18i32) as u8;
                                              match e {
                                                super::component::ComponentOptionTypeParam::TypeEmpty(e) => {
                                                  *((base + 16) as *mut u8) = (0i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let () = e;
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeBool(e) => {
                                                  *((base + 16) as *mut u8) = (1i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeEntityId(e) => {
                                                  *((base + 16) as *mut u8) = (2i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::EntityId{ id0:id036, id1:id136, } = e;
                                                      *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id036);
                                                      *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id136);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeF32(e) => {
                                                  *((base + 16) as *mut u8) = (3i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeF64(e) => {
                                                  *((base + 16) as *mut u8) = (4i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeMat4(e) => {
                                                  *((base + 16) as *mut u8) = (5i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Mat4{ x:x37, y:y37, z:z37, w:w37, } = e;
                                                      let super::types::Vec4{ x:x38, y:y38, z:z38, w:w38, } = x37;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x38);
                                                      *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y38);
                                                      *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z38);
                                                      *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w38);
                                                      let super::types::Vec4{ x:x39, y:y39, z:z39, w:w39, } = y37;
                                                      *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x39);
                                                      *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y39);
                                                      *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z39);
                                                      *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w39);
                                                      let super::types::Vec4{ x:x40, y:y40, z:z40, w:w40, } = z37;
                                                      *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x40);
                                                      *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y40);
                                                      *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z40);
                                                      *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w40);
                                                      let super::types::Vec4{ x:x41, y:y41, z:z41, w:w41, } = w37;
                                                      *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x41);
                                                      *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y41);
                                                      *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z41);
                                                      *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w41);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeI32(e) => {
                                                  *((base + 16) as *mut u8) = (6i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeQuat(e) => {
                                                  *((base + 16) as *mut u8) = (7i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Quat{ x:x42, y:y42, z:z42, w:w42, } = e;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x42);
                                                      *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y42);
                                                      *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z42);
                                                      *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w42);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeString(e) => {
                                                  *((base + 16) as *mut u8) = (8i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let vec43 = e;
                                                      let ptr43 = vec43.as_ptr() as i32;
                                                      let len43 = vec43.len() as i32;
                                                      *((base + 32) as *mut i32) = len43;
                                                      *((base + 28) as *mut i32) = ptr43;
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeU32(e) => {
                                                  *((base + 16) as *mut u8) = (9i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeU64(e) => {
                                                  *((base + 16) as *mut u8) = (10i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeVec2(e) => {
                                                  *((base + 16) as *mut u8) = (11i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Vec2{ x:x44, y:y44, } = e;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x44);
                                                      *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y44);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeVec3(e) => {
                                                  *((base + 16) as *mut u8) = (12i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Vec3{ x:x45, y:y45, z:z45, } = e;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x45);
                                                      *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y45);
                                                      *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z45);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeVec4(e) => {
                                                  *((base + 16) as *mut u8) = (13i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Vec4{ x:x46, y:y46, z:z46, w:w46, } = e;
                                                      *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x46);
                                                      *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y46);
                                                      *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z46);
                                                      *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w46);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeUvec2(e) => {
                                                  *((base + 16) as *mut u8) = (14i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Uvec2{ x:x47, y:y47, } = e;
                                                      *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x47);
                                                      *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y47);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeUvec3(e) => {
                                                  *((base + 16) as *mut u8) = (15i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Uvec3{ x:x48, y:y48, z:z48, } = e;
                                                      *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x48);
                                                      *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y48);
                                                      *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z48);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                                super::component::ComponentOptionTypeParam::TypeUvec4(e) => {
                                                  *((base + 16) as *mut u8) = (16i32) as u8;
                                                  match e {
                                                    Some(e) => {
                                                      *((base + 24) as *mut u8) = (1i32) as u8;
                                                      let super::types::Uvec4{ x:x49, y:y49, z:z49, w:w49, } = e;
                                                      *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x49);
                                                      *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y49);
                                                      *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z49);
                                                      *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w49);
                                                      
                                                    },
                                                    None => {
                                                      {
                                                        *((base + 24) as *mut u8) = (0i32) as u8;
                                                        
                                                      }
                                                    },
                                                  };
                                                },
                                              };
                                              
                                            },
                                          };
                                          
                                        }}
                                        
                                        #[link(wasm_import_module = "event")]
                                        extern "C" {
                                          #[cfg_attr(target_arch = "wasm32", link_name = "send")]
                                          #[cfg_attr(not(target_arch = "wasm32"), link_name = "event_send")]
                                          fn wit_import(
                                          _: i32, _: i32, _: i32, _: i32, );
                                        }
                                        wit_import(ptr0, len0, result50 as i32, len50);
                                        if layout50.size() != 0 {
                                          alloc::dealloc(result50, layout50);
                                        }
                                        for (ptr, layout) in cleanup_list {
                                          
                                          if layout.size() != 0 {
                                            
                                            alloc::dealloc(ptr, layout);
                                            
                                          }
                                          
                                        }
                                      }
                                    }
                                    
                                  }
                                  
                                  
                                  #[allow(clippy::all)]
                                  pub mod asset{ use super::wit_bindgen;
                                    #[allow(clippy::all)]
                                    pub fn url(path: &str,) -> Option<wit_bindgen::rt::string::String>{
                                      
                                      #[allow(unused_imports)]
                                      use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
                                      unsafe {
                                        
                                        #[repr(align(4))]
                                        struct RetArea([u8; 12]);
                                        let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
                                        let vec0 = path;
                                        let ptr0 = vec0.as_ptr() as i32;
                                        let len0 = vec0.len() as i32;
                                        let ptr1 = ret_area.as_mut_ptr() as i32;
                                        #[link(wasm_import_module = "asset")]
                                        extern "C" {
                                          #[cfg_attr(target_arch = "wasm32", link_name = "url")]
                                          #[cfg_attr(not(target_arch = "wasm32"), link_name = "asset_url")]
                                          fn wit_import(
                                          _: i32, _: i32, _: i32, );
                                        }
                                        wit_import(ptr0, len0, ptr1);
                                        match i32::from(*((ptr1 + 0) as *const u8)) {
                                          0 => None,
                                          1 => Some({
                                            let len2 = *((ptr1 + 8) as *const i32) as usize;
                                            
                                            {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2)).unwrap()}}
                                          }),
                                          #[cfg(not(debug_assertions))]
                                          _ => core::hint::unreachable_unchecked(),
                                          #[cfg(debug_assertions)]
                                          _ => panic!("invalid enum discriminant"),
                                        }
                                      }
                                    }
                                    
                                  }
                                  
                                  
                                  #[allow(clippy::all)]
                                  pub mod guest{ use super::wit_bindgen;
                                    pub type ComponentType = super::component::ComponentTypeResult;
                                    pub trait Guest {
                                      fn init(interface_version: u32,);
                                      fn exec(time: f32,event_name: wit_bindgen::rt::string::String,event_data: wit_bindgen::rt::vec::Vec::<(u32,ComponentType,)>,);
                                    }
                                    
                                    #[doc(hidden)]
                                    pub unsafe fn call_init<T: Guest>(arg0: i32,) {
                                      
                                      #[allow(unused_imports)]
                                      use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                      T::init(arg0 as u32);
                                    }
                                    
                                    #[doc(hidden)]
                                    pub unsafe fn call_exec<T: Guest>(arg0: f32,arg1: i32,arg2: i32,arg3: i32,arg4: i32,) {
                                      
                                      #[allow(unused_imports)]
                                      use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                                      let len0 = arg2 as usize;
                                      let base21 = arg3;
                                      let len21 = arg4;
                                      let mut result21 = Vec::with_capacity(len21 as usize);
                                      for i in 0..len21 {
                                        let base = base21 + i *96;
                                        result21.push((*((base + 0) as *const i32) as u32, {{match i32::from(*((base + 8) as *const u8)) {
                                          0 => super::component::ComponentTypeResult::TypeEmpty(()),
                                          1 => super::component::ComponentTypeResult::TypeBool({
                                            #[cfg(not(debug_assertions))]
                                            { core::mem::transmute::<u8, bool>(i32::from(*((base + 16) as *const u8)) as u8) }
                                            #[cfg(debug_assertions)]
                                            {
                                              match i32::from(*((base + 16) as *const u8)) {
                                                0 => false,
                                                1 => true,
                                                _ => panic!("invalid bool discriminant"),
                                              }
                                            }
                                          }),
                                          2 => super::component::ComponentTypeResult::TypeEntityId(super::types::EntityId{id0:*((base + 16) as *const i64) as u64, id1:*((base + 24) as *const i64) as u64, }),
                                          3 => super::component::ComponentTypeResult::TypeF32(*((base + 16) as *const f32)),
                                          4 => super::component::ComponentTypeResult::TypeF64(*((base + 16) as *const f64)),
                                          5 => super::component::ComponentTypeResult::TypeMat4(super::types::Mat4{x:super::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }, y:super::types::Vec4{x:*((base + 32) as *const f32), y:*((base + 36) as *const f32), z:*((base + 40) as *const f32), w:*((base + 44) as *const f32), }, z:super::types::Vec4{x:*((base + 48) as *const f32), y:*((base + 52) as *const f32), z:*((base + 56) as *const f32), w:*((base + 60) as *const f32), }, w:super::types::Vec4{x:*((base + 64) as *const f32), y:*((base + 68) as *const f32), z:*((base + 72) as *const f32), w:*((base + 76) as *const f32), }, }),
                                          6 => super::component::ComponentTypeResult::TypeI32(*((base + 16) as *const i32)),
                                          7 => super::component::ComponentTypeResult::TypeQuat(super::types::Quat{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                                          8 => super::component::ComponentTypeResult::TypeString({
                                            let len1 = *((base + 20) as *const i32) as usize;
                                            
                                            {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len1, len1)).unwrap()}}
                                          }),
                                          9 => super::component::ComponentTypeResult::TypeU32(*((base + 16) as *const i32) as u32),
                                          10 => super::component::ComponentTypeResult::TypeU64(*((base + 16) as *const i64) as u64),
                                          11 => super::component::ComponentTypeResult::TypeVec2(super::types::Vec2{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), }),
                                          12 => super::component::ComponentTypeResult::TypeVec3(super::types::Vec3{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), }),
                                          13 => super::component::ComponentTypeResult::TypeVec4(super::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                                          14 => super::component::ComponentTypeResult::TypeUvec2(super::types::Uvec2{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, }),
                                          15 => super::component::ComponentTypeResult::TypeUvec3(super::types::Uvec3{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, }),
                                          16 => super::component::ComponentTypeResult::TypeUvec4(super::types::Uvec4{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, w:*((base + 28) as *const i32) as u32, }),
                                          17 => super::component::ComponentTypeResult::TypeList({{match i32::from(*((base + 16) as *const u8)) {
                                            0 => super::component::ComponentListTypeResult::TypeEmpty({
                                              let len2 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len2, len2)
                                            }),
                                            1 => super::component::ComponentListTypeResult::TypeBool({
                                              let base3 = *((base + 20) as *const i32);
                                              let len3 = *((base + 24) as *const i32);
                                              let mut result3 = Vec::with_capacity(len3 as usize);
                                              for i in 0..len3 {
                                                let base = base3 + i *1;
                                                result3.push({
                                                  #[cfg(not(debug_assertions))]
                                                  { core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                                                  #[cfg(debug_assertions)]
                                                  {
                                                    match i32::from(*((base + 0) as *const u8)) {
                                                      0 => false,
                                                      1 => true,
                                                      _ => panic!("invalid bool discriminant"),
                                                    }
                                                  }
                                                });
                                              }
                                              wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                                              
                                              result3
                                            }),
                                            2 => super::component::ComponentListTypeResult::TypeEntityId({
                                              let len4 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len4, len4)
                                            }),
                                            3 => super::component::ComponentListTypeResult::TypeF32({
                                              let len5 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len5, len5)
                                            }),
                                            4 => super::component::ComponentListTypeResult::TypeF64({
                                              let len6 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len6, len6)
                                            }),
                                            5 => super::component::ComponentListTypeResult::TypeMat4({
                                              let len7 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len7, len7)
                                            }),
                                            6 => super::component::ComponentListTypeResult::TypeI32({
                                              let len8 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len8, len8)
                                            }),
                                            7 => super::component::ComponentListTypeResult::TypeQuat({
                                              let len9 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len9, len9)
                                            }),
                                            8 => super::component::ComponentListTypeResult::TypeString({
                                              let base11 = *((base + 20) as *const i32);
                                              let len11 = *((base + 24) as *const i32);
                                              let mut result11 = Vec::with_capacity(len11 as usize);
                                              for i in 0..len11 {
                                                let base = base11 + i *8;
                                                result11.push({
                                                  let len10 = *((base + 4) as *const i32) as usize;
                                                  
                                                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10)).unwrap()}}
                                                });
                                              }
                                              wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                                              
                                              result11
                                            }),
                                            9 => super::component::ComponentListTypeResult::TypeU32({
                                              let len12 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len12, len12)
                                            }),
                                            10 => super::component::ComponentListTypeResult::TypeU64({
                                              let len13 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len13, len13)
                                            }),
                                            11 => super::component::ComponentListTypeResult::TypeVec2({
                                              let len14 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len14, len14)
                                            }),
                                            12 => super::component::ComponentListTypeResult::TypeVec3({
                                              let len15 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len15, len15)
                                            }),
                                            13 => super::component::ComponentListTypeResult::TypeVec4({
                                              let len16 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len16, len16)
                                            }),
                                            14 => super::component::ComponentListTypeResult::TypeUvec2({
                                              let len17 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len17, len17)
                                            }),
                                            15 => super::component::ComponentListTypeResult::TypeUvec3({
                                              let len18 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len18, len18)
                                            }),
                                            #[cfg(debug_assertions)]16 => super::component::ComponentListTypeResult::TypeUvec4({
                                              let len19 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len19, len19)
                                            }),
                                            #[cfg(not(debug_assertions))]_ => super::component::ComponentListTypeResult::TypeUvec4({
                                              let len19 = *((base + 24) as *const i32) as usize;
                                              
                                              Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len19, len19)
                                            }),
                                            #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                          }}}),
                                          #[cfg(debug_assertions)]18 => super::component::ComponentTypeResult::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                                            0 => super::component::ComponentOptionTypeResult::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(()),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            1 => super::component::ComponentOptionTypeResult::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some({
                                                #[cfg(not(debug_assertions))]
                                                { core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                                                #[cfg(debug_assertions)]
                                                {
                                                  match i32::from(*((base + 25) as *const u8)) {
                                                    0 => false,
                                                    1 => true,
                                                    _ => panic!("invalid bool discriminant"),
                                                  }
                                                }
                                              }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            2 => super::component::ComponentOptionTypeResult::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            3 => super::component::ComponentOptionTypeResult::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(*((base + 28) as *const f32)),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            4 => super::component::ComponentOptionTypeResult::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(*((base + 32) as *const f64)),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            5 => super::component::ComponentOptionTypeResult::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            6 => super::component::ComponentOptionTypeResult::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(*((base + 28) as *const i32)),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            7 => super::component::ComponentOptionTypeResult::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            8 => super::component::ComponentOptionTypeResult::TypeString(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some({
                                                let len20 = *((base + 32) as *const i32) as usize;
                                                
                                                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len20, len20))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len20, len20)).unwrap()}}
                                              }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            9 => super::component::ComponentOptionTypeResult::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(*((base + 28) as *const i32) as u32),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            10 => super::component::ComponentOptionTypeResult::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(*((base + 32) as *const i64) as u64),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            11 => super::component::ComponentOptionTypeResult::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            12 => super::component::ComponentOptionTypeResult::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            13 => super::component::ComponentOptionTypeResult::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            14 => super::component::ComponentOptionTypeResult::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            15 => super::component::ComponentOptionTypeResult::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            #[cfg(debug_assertions)]16 => super::component::ComponentOptionTypeResult::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            #[cfg(not(debug_assertions))]_ => super::component::ComponentOptionTypeResult::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                          }}}),
                                          #[cfg(not(debug_assertions))]_ => super::component::ComponentTypeResult::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                                            0 => super::component::ComponentOptionTypeResult::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(()),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            1 => super::component::ComponentOptionTypeResult::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some({
                                                #[cfg(not(debug_assertions))]
                                                { core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                                                #[cfg(debug_assertions)]
                                                {
                                                  match i32::from(*((base + 25) as *const u8)) {
                                                    0 => false,
                                                    1 => true,
                                                    _ => panic!("invalid bool discriminant"),
                                                  }
                                                }
                                              }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            2 => super::component::ComponentOptionTypeResult::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            3 => super::component::ComponentOptionTypeResult::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(*((base + 28) as *const f32)),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            4 => super::component::ComponentOptionTypeResult::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(*((base + 32) as *const f64)),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            5 => super::component::ComponentOptionTypeResult::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            6 => super::component::ComponentOptionTypeResult::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(*((base + 28) as *const i32)),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            7 => super::component::ComponentOptionTypeResult::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            8 => super::component::ComponentOptionTypeResult::TypeString(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some({
                                                let len20 = *((base + 32) as *const i32) as usize;
                                                
                                                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len20, len20))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len20, len20)).unwrap()}}
                                              }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            9 => super::component::ComponentOptionTypeResult::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(*((base + 28) as *const i32) as u32),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            10 => super::component::ComponentOptionTypeResult::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(*((base + 32) as *const i64) as u64),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            11 => super::component::ComponentOptionTypeResult::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            12 => super::component::ComponentOptionTypeResult::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            13 => super::component::ComponentOptionTypeResult::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            14 => super::component::ComponentOptionTypeResult::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            15 => super::component::ComponentOptionTypeResult::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            #[cfg(debug_assertions)]16 => super::component::ComponentOptionTypeResult::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            #[cfg(not(debug_assertions))]_ => super::component::ComponentOptionTypeResult::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                                              0 => None,
                                              1 => Some(super::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                                              #[cfg(not(debug_assertions))]
                                              _ => core::hint::unreachable_unchecked(),
                                              #[cfg(debug_assertions)]
                                              _ => panic!("invalid enum discriminant"),
                                            }),
                                            #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                          }}}),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}}));
                                      }
                                      wit_bindgen::rt::dealloc(base21, (len21 as usize) * 96, 8);
                                      T::exec(arg0, {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(arg1 as *mut _, len0, len0))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(arg1 as *mut _, len0, len0)).unwrap()}}, result21);
                                    }
                                    
                                  }
                                  
                                  
                                  /// Declares the export of the component's world for the
                                  /// given type.
                                  
                                  macro_rules! export_bindings(($t:ident) => {
                                    const _: () = {
                                      
                                      #[doc(hidden)]
                                      #[export_name = "guest#init"]
                                      #[allow(non_snake_case)]
                                      unsafe extern "C" fn __export_guest_init(arg0: i32,) {
                                        guest::call_init::<$t>(arg0,)
                                      }
                                      
                                      #[doc(hidden)]
                                      #[export_name = "guest#exec"]
                                      #[allow(non_snake_case)]
                                      unsafe extern "C" fn __export_guest_exec(arg0: f32,arg1: i32,arg2: i32,arg3: i32,arg4: i32,) {
                                        guest::call_exec::<$t>(arg0,arg1,arg2,arg3,arg4,)
                                      }
                                      
                                    };
                                    
                                    #[used]
                                    #[doc(hidden)]
                                    #[cfg(target_arch = "wasm32")]
                                    static __FORCE_SECTION_REF: fn() = __force_section_ref;
                                    #[doc(hidden)]
                                    #[cfg(target_arch = "wasm32")]
                                    fn __force_section_ref() {
                                      __link_section()
                                    }
                                  });
                                  
                                  #[cfg(target_arch = "wasm32")]
                                  #[link_section = "component-type:bindings"]
                                  #[doc(hidden)]pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 14798] = [2, 0, 3, 119, 105, 116, 4, 109, 97, 105, 110, 8, 98, 105, 110, 100, 105, 110, 103, 115, 0, 97, 115, 109, 12, 0, 1, 0, 7, 245, 1, 1, 65, 2, 1, 66, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 12, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 14, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 16, 4, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 11, 21, 1, 5, 116, 121, 112, 101, 115, 10, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 3, 0, 0, 7, 200, 12, 1, 65, 6, 1, 66, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 12, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 14, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 16, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 66, 16, 2, 3, 2, 1, 1, 4, 4, 118, 101, 99, 50, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 2, 1, 109, 163, 1, 4, 107, 101, 121, 49, 4, 107, 101, 121, 50, 4, 107, 101, 121, 51, 4, 107, 101, 121, 52, 4, 107, 101, 121, 53, 4, 107, 101, 121, 54, 4, 107, 101, 121, 55, 4, 107, 101, 121, 56, 4, 107, 101, 121, 57, 4, 107, 101, 121, 48, 1, 97, 1, 98, 1, 99, 1, 100, 1, 101, 1, 102, 1, 103, 1, 104, 1, 105, 1, 106, 1, 107, 1, 108, 1, 109, 1, 110, 1, 111, 1, 112, 1, 113, 1, 114, 1, 115, 1, 116, 1, 117, 1, 118, 1, 119, 1, 120, 1, 121, 1, 122, 6, 101, 115, 99, 97, 112, 101, 2, 102, 49, 2, 102, 50, 2, 102, 51, 2, 102, 52, 2, 102, 53, 2, 102, 54, 2, 102, 55, 2, 102, 56, 2, 102, 57, 3, 102, 49, 48, 3, 102, 49, 49, 3, 102, 49, 50, 3, 102, 49, 51, 3, 102, 49, 52, 3, 102, 49, 53, 3, 102, 49, 54, 3, 102, 49, 55, 3, 102, 49, 56, 3, 102, 49, 57, 3, 102, 50, 48, 3, 102, 50, 49, 3, 102, 50, 50, 3, 102, 50, 51, 3, 102, 50, 52, 8, 115, 110, 97, 112, 115, 104, 111, 116, 6, 115, 99, 114, 111, 108, 108, 5, 112, 97, 117, 115, 101, 6, 105, 110, 115, 101, 114, 116, 4, 104, 111, 109, 101, 6, 100, 101, 108, 101, 116, 101, 3, 101, 110, 100, 9, 112, 97, 103, 101, 45, 100, 111, 119, 110, 7, 112, 97, 103, 101, 45, 117, 112, 4, 108, 101, 102, 116, 2, 117, 112, 5, 114, 105, 103, 104, 116, 4, 100, 111, 119, 110, 4, 98, 97, 99, 107, 6, 114, 101, 116, 117, 114, 110, 5, 115, 112, 97, 99, 101, 7, 99, 111, 109, 112, 111, 115, 101, 5, 99, 97, 114, 101, 116, 7, 110, 117, 109, 108, 111, 99, 107, 7, 110, 117, 109, 112, 97, 100, 48, 7, 110, 117, 109, 112, 97, 100, 49, 7, 110, 117, 109, 112, 97, 100, 50, 7, 110, 117, 109, 112, 97, 100, 51, 7, 110, 117, 109, 112, 97, 100, 52, 7, 110, 117, 109, 112, 97, 100, 53, 7, 110, 117, 109, 112, 97, 100, 54, 7, 110, 117, 109, 112, 97, 100, 55, 7, 110, 117, 109, 112, 97, 100, 56, 7, 110, 117, 109, 112, 97, 100, 57, 10, 110, 117, 109, 112, 97, 100, 45, 97, 100, 100, 13, 110, 117, 109, 112, 97, 100, 45, 100, 105, 118, 105, 100, 101, 14, 110, 117, 109, 112, 97, 100, 45, 100, 101, 99, 105, 109, 97, 108, 12, 110, 117, 109, 112, 97, 100, 45, 99, 111, 109, 109, 97, 12, 110, 117, 109, 112, 97, 100, 45, 101, 110, 116, 101, 114, 13, 110, 117, 109, 112, 97, 100, 45, 101, 113, 117, 97, 108, 115, 15, 110, 117, 109, 112, 97, 100, 45, 109, 117, 108, 116, 105, 112, 108, 121, 15, 110, 117, 109, 112, 97, 100, 45, 115, 117, 98, 116, 114, 97, 99, 116, 7, 97, 98, 110, 116, 45, 99, 49, 7, 97, 98, 110, 116, 45, 99, 50, 10, 97, 112, 111, 115, 116, 114, 111, 112, 104, 101, 4, 97, 112, 112, 115, 8, 97, 115, 116, 101, 114, 105, 115, 107, 2, 97, 116, 2, 97, 120, 9, 98, 97, 99, 107, 115, 108, 97, 115, 104, 10, 99, 97, 108, 99, 117, 108, 97, 116, 111, 114, 7, 99, 97, 112, 105, 116, 97, 108, 5, 99, 111, 108, 111, 110, 5, 99, 111, 109, 109, 97, 7, 99, 111, 110, 118, 101, 114, 116, 6, 101, 113, 117, 97, 108, 115, 5, 103, 114, 97, 118, 101, 4, 107, 97, 110, 97, 5, 107, 97, 110, 106, 105, 5, 108, 45, 97, 108, 116, 9, 108, 45, 98, 114, 97, 99, 107, 101, 116, 9, 108, 45, 99, 111, 110, 116, 114, 111, 108, 7, 108, 45, 115, 104, 105, 102, 116, 5, 108, 45, 119, 105, 110, 4, 109, 97, 105, 108, 12, 109, 101, 100, 105, 97, 45, 115, 101, 108, 101, 99, 116, 10, 109, 101, 100, 105, 97, 45, 115, 116, 111, 112, 5, 109, 105, 110, 117, 115, 4, 109, 117, 116, 101, 11, 109, 121, 45, 99, 111, 109, 112, 117, 116, 101, 114, 16, 110, 97, 118, 105, 103, 97, 116, 101, 45, 102, 111, 114, 119, 97, 114, 100, 17, 110, 97, 118, 105, 103, 97, 116, 101, 45, 98, 97, 99, 107, 119, 97, 114, 100, 10, 110, 101, 120, 116, 45, 116, 114, 97, 99, 107, 10, 110, 111, 45, 99, 111, 110, 118, 101, 114, 116, 6, 111, 101, 109, 49, 48, 50, 6, 112, 101, 114, 105, 111, 100, 10, 112, 108, 97, 121, 45, 112, 97, 117, 115, 101, 4, 112, 108, 117, 115, 5, 112, 111, 119, 101, 114, 10, 112, 114, 101, 118, 45, 116, 114, 97, 99, 107, 5, 114, 45, 97, 108, 116, 9, 114, 45, 98, 114, 97, 99, 107, 101, 116, 9, 114, 45, 99, 111, 110, 116, 114, 111, 108, 7, 114, 45, 115, 104, 105, 102, 116, 5, 114, 45, 119, 105, 110, 9, 115, 101, 109, 105, 99, 111, 108, 111, 110, 5, 115, 108, 97, 115, 104, 5, 115, 108, 101, 101, 112, 4, 115, 116, 111, 112, 5, 115, 121, 115, 114, 113, 3, 116, 97, 98, 9, 117, 110, 100, 101, 114, 108, 105, 110, 101, 9, 117, 110, 108, 97, 98, 101, 108, 101, 100, 11, 118, 111, 108, 117, 109, 101, 45, 100, 111, 119, 110, 9, 118, 111, 108, 117, 109, 101, 45, 117, 112, 4, 119, 97, 107, 101, 8, 119, 101, 98, 45, 98, 97, 99, 107, 13, 119, 101, 98, 45, 102, 97, 118, 111, 114, 105, 116, 101, 115, 11, 119, 101, 98, 45, 102, 111, 114, 119, 97, 114, 100, 8, 119, 101, 98, 45, 104, 111, 109, 101, 11, 119, 101, 98, 45, 114, 101, 102, 114, 101, 115, 104, 10, 119, 101, 98, 45, 115, 101, 97, 114, 99, 104, 8, 119, 101, 98, 45, 115, 116, 111, 112, 3, 121, 101, 110, 4, 99, 111, 112, 121, 5, 112, 97, 115, 116, 101, 3, 99, 117, 116, 4, 16, 118, 105, 114, 116, 117, 97, 108, 45, 107, 101, 121, 45, 99, 111, 100, 101, 0, 3, 0, 4, 1, 113, 4, 4, 108, 101, 102, 116, 0, 0, 5, 114, 105, 103, 104, 116, 0, 0, 6, 109, 105, 100, 100, 108, 101, 0, 0, 5, 111, 116, 104, 101, 114, 1, 123, 0, 4, 12, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 0, 3, 0, 6, 1, 112, 5, 1, 112, 7, 1, 114, 5, 4, 107, 101, 121, 115, 8, 14, 109, 111, 117, 115, 101, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 15, 99, 117, 114, 115, 111, 114, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 11, 109, 111, 117, 115, 101, 45, 119, 104, 101, 101, 108, 118, 13, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 115, 9, 4, 9, 114, 97, 119, 45, 105, 110, 112, 117, 116, 0, 3, 0, 10, 1, 107, 11, 1, 64, 1, 6, 112, 108, 97, 121, 101, 114, 3, 0, 12, 4, 13, 103, 101, 116, 45, 114, 97, 119, 45, 105, 110, 112, 117, 116, 0, 1, 13, 4, 18, 103, 101, 116, 45, 112, 114, 101, 118, 45, 114, 97, 119, 45, 105, 110, 112, 117, 116, 0, 1, 13, 4, 6, 112, 108, 97, 121, 101, 114, 18, 112, 107, 103, 58, 47, 112, 108, 97, 121, 101, 114, 47, 112, 108, 97, 121, 101, 114, 5, 3, 11, 23, 1, 6, 112, 108, 97, 121, 101, 114, 11, 112, 107, 103, 58, 47, 112, 108, 97, 121, 101, 114, 3, 2, 0, 7, 129, 6, 1, 65, 6, 1, 66, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 12, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 14, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 16, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 118, 101, 99, 51, 1, 66, 29, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 3, 4, 115, 105, 100, 101, 127, 2, 117, 112, 127, 4, 100, 111, 119, 110, 127, 4, 19, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 99, 111, 108, 108, 105, 115, 105, 111, 110, 0, 3, 0, 4, 1, 112, 1, 1, 64, 2, 8, 101, 110, 116, 105, 116, 105, 101, 115, 6, 5, 102, 111, 114, 99, 101, 3, 1, 0, 4, 11, 97, 112, 112, 108, 121, 45, 102, 111, 114, 99, 101, 0, 1, 7, 1, 107, 118, 1, 64, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 5, 102, 111, 114, 99, 101, 118, 6, 114, 97, 100, 105, 117, 115, 118, 14, 102, 97, 108, 108, 111, 102, 102, 45, 114, 97, 100, 105, 117, 115, 8, 1, 0, 4, 12, 101, 120, 112, 108, 111, 100, 101, 45, 98, 111, 109, 98, 0, 1, 9, 1, 64, 1, 7, 103, 114, 97, 118, 105, 116, 121, 3, 1, 0, 4, 11, 115, 101, 116, 45, 103, 114, 97, 118, 105, 116, 121, 0, 1, 10, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 1, 0, 4, 8, 117, 110, 102, 114, 101, 101, 122, 101, 0, 1, 11, 4, 6, 102, 114, 101, 101, 122, 101, 0, 1, 11, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 118, 101, 108, 111, 99, 105, 116, 121, 118, 1, 0, 4, 11, 115, 116, 97, 114, 116, 45, 109, 111, 116, 111, 114, 0, 1, 12, 4, 10, 115, 116, 111, 112, 45, 109, 111, 116, 111, 114, 0, 1, 11, 1, 111, 2, 1, 118, 1, 107, 13, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 14, 4, 13, 114, 97, 121, 99, 97, 115, 116, 45, 102, 105, 114, 115, 116, 0, 1, 15, 1, 112, 13, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 16, 4, 7, 114, 97, 121, 99, 97, 115, 116, 0, 1, 17, 1, 64, 4, 6, 101, 110, 116, 105, 116, 121, 1, 12, 100, 105, 115, 112, 108, 97, 99, 101, 109, 101, 110, 116, 3, 8, 109, 105, 110, 45, 100, 105, 115, 116, 118, 12, 101, 108, 97, 112, 115, 101, 100, 45, 116, 105, 109, 101, 118, 0, 5, 4, 14, 109, 111, 118, 101, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 0, 1, 18, 4, 7, 112, 104, 121, 115, 105, 99, 115, 20, 112, 107, 103, 58, 47, 112, 104, 121, 115, 105, 99, 115, 47, 112, 104, 121, 115, 105, 99, 115, 5, 3, 11, 25, 1, 7, 112, 104, 121, 115, 105, 99, 115, 12, 112, 107, 103, 58, 47, 112, 104, 121, 115, 105, 99, 115, 3, 4, 0, 7, 148, 15, 1, 65, 13, 1, 66, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 12, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 14, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 16, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 118, 101, 99, 52, 2, 3, 0, 0, 5, 117, 118, 101, 99, 50, 2, 3, 0, 0, 5, 117, 118, 101, 99, 51, 2, 3, 0, 0, 5, 117, 118, 101, 99, 52, 1, 66, 92, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 4, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 6, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 2, 3, 2, 1, 7, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 12, 2, 3, 2, 1, 8, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 14, 2, 3, 2, 1, 9, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 16, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 0, 3, 0, 18, 1, 112, 121, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 20, 7, 105, 110, 99, 108, 117, 100, 101, 20, 7, 101, 120, 99, 108, 117, 100, 101, 20, 7, 99, 104, 97, 110, 103, 101, 100, 20, 4, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 0, 3, 0, 21, 1, 111, 0, 1, 107, 23, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 113, 17, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 24, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 25, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 26, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 27, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 28, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 29, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 30, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 31, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 32, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 33, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 34, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 35, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 36, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 37, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 38, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 39, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 40, 0, 4, 21, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 111, 112, 116, 105, 111, 110, 45, 116, 121, 112, 101, 0, 3, 0, 41, 1, 112, 23, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 113, 17, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 43, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 44, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 45, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 46, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 47, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 48, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 49, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 50, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 51, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 20, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 52, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 53, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 54, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 55, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 56, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 57, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 58, 0, 4, 19, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 108, 105, 115, 116, 45, 116, 121, 112, 101, 0, 3, 0, 59, 1, 113, 19, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 23, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 9, 116, 121, 112, 101, 45, 108, 105, 115, 116, 1, 60, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 42, 0, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 61, 1, 111, 2, 121, 62, 1, 112, 63, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 64, 1, 64, 1, 2, 105, 100, 115, 0, 33, 4, 9, 103, 101, 116, 45, 105, 110, 100, 101, 120, 0, 1, 66, 1, 107, 62, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 195, 0, 4, 13, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 68, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 5, 118, 97, 108, 117, 101, 62, 1, 0, 4, 13, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 69, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 4, 100, 97, 116, 97, 193, 0, 1, 0, 4, 14, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 70, 4, 13, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 69, 4, 14, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 70, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 127, 4, 13, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 71, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 20, 0, 127, 4, 14, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 72, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 1, 0, 4, 16, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 73, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 20, 1, 0, 4, 17, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 74, 1, 64, 2, 1, 113, 22, 1, 116, 19, 0, 119, 4, 5, 113, 117, 101, 114, 121, 0, 1, 75, 1, 112, 62, 1, 111, 2, 1, 204, 0, 1, 112, 205, 0, 1, 64, 1, 1, 113, 119, 0, 206, 0, 4, 10, 113, 117, 101, 114, 121, 45, 101, 118, 97, 108, 0, 1, 79, 4, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 10, 11, 29, 1, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 14, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 3, 6, 0, 7, 154, 13, 1, 65, 16, 1, 66, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 12, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 14, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 16, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 118, 101, 99, 52, 2, 3, 0, 0, 5, 117, 118, 101, 99, 50, 2, 3, 0, 0, 5, 117, 118, 101, 99, 51, 2, 3, 0, 0, 5, 117, 118, 101, 99, 52, 1, 66, 66, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 4, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 6, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 2, 3, 2, 1, 7, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 12, 2, 3, 2, 1, 8, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 14, 2, 3, 2, 1, 9, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 16, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 0, 3, 0, 18, 1, 112, 121, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 20, 7, 105, 110, 99, 108, 117, 100, 101, 20, 7, 101, 120, 99, 108, 117, 100, 101, 20, 7, 99, 104, 97, 110, 103, 101, 100, 20, 4, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 0, 3, 0, 21, 1, 111, 0, 1, 107, 23, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 113, 17, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 24, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 25, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 26, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 27, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 28, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 29, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 30, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 31, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 32, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 33, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 34, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 35, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 36, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 37, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 38, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 39, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 40, 0, 4, 21, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 111, 112, 116, 105, 111, 110, 45, 116, 121, 112, 101, 0, 3, 0, 41, 1, 112, 23, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 113, 17, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 43, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 44, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 45, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 46, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 47, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 48, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 49, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 50, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 51, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 20, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 52, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 53, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 54, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 55, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 56, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 57, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 58, 0, 4, 19, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 108, 105, 115, 116, 45, 116, 121, 112, 101, 0, 3, 0, 59, 1, 113, 19, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 23, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 9, 116, 121, 112, 101, 45, 108, 105, 115, 116, 1, 60, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 42, 0, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 61, 1, 111, 2, 121, 62, 1, 112, 63, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 64, 3, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 10, 2, 3, 0, 1, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 1, 66, 8, 2, 3, 2, 1, 11, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 0, 1, 64, 1, 17, 105, 110, 116, 101, 114, 102, 97, 99, 101, 45, 118, 101, 114, 115, 105, 111, 110, 121, 1, 0, 4, 4, 105, 110, 105, 116, 0, 1, 2, 1, 111, 2, 121, 1, 1, 112, 3, 1, 64, 3, 4, 116, 105, 109, 101, 118, 10, 101, 118, 101, 110, 116, 45, 110, 97, 109, 101, 115, 10, 101, 118, 101, 110, 116, 45, 100, 97, 116, 97, 4, 1, 0, 4, 4, 101, 120, 101, 99, 0, 1, 5, 4, 5, 103, 117, 101, 115, 116, 16, 112, 107, 103, 58, 47, 103, 117, 101, 115, 116, 47, 103, 117, 101, 115, 116, 5, 12, 11, 21, 1, 5, 103, 117, 101, 115, 116, 10, 112, 107, 103, 58, 47, 103, 117, 101, 115, 116, 3, 8, 0, 7, 232, 12, 1, 65, 16, 1, 66, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 12, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 14, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 16, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 118, 101, 99, 52, 2, 3, 0, 0, 5, 117, 118, 101, 99, 50, 2, 3, 0, 0, 5, 117, 118, 101, 99, 51, 2, 3, 0, 0, 5, 117, 118, 101, 99, 52, 1, 66, 66, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 4, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 6, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 2, 3, 2, 1, 7, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 12, 2, 3, 2, 1, 8, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 14, 2, 3, 2, 1, 9, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 16, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 0, 3, 0, 18, 1, 112, 121, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 20, 7, 105, 110, 99, 108, 117, 100, 101, 20, 7, 101, 120, 99, 108, 117, 100, 101, 20, 7, 99, 104, 97, 110, 103, 101, 100, 20, 4, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 0, 3, 0, 21, 1, 111, 0, 1, 107, 23, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 113, 17, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 24, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 25, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 26, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 27, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 28, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 29, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 30, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 31, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 32, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 33, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 34, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 35, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 36, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 37, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 38, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 39, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 40, 0, 4, 21, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 111, 112, 116, 105, 111, 110, 45, 116, 121, 112, 101, 0, 3, 0, 41, 1, 112, 23, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 113, 17, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 43, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 44, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 45, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 46, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 47, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 48, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 49, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 50, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 51, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 20, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 52, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 53, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 54, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 55, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 56, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 57, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 58, 0, 4, 19, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 108, 105, 115, 116, 45, 116, 121, 112, 101, 0, 3, 0, 59, 1, 113, 19, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 23, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 9, 116, 121, 112, 101, 45, 108, 105, 115, 116, 1, 60, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 42, 0, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 61, 1, 111, 2, 121, 62, 1, 112, 63, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 64, 3, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 10, 2, 3, 0, 1, 6, 101, 110, 116, 105, 116, 121, 1, 66, 6, 2, 3, 2, 1, 11, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 0, 1, 64, 1, 4, 110, 97, 109, 101, 115, 1, 0, 4, 9, 115, 117, 98, 115, 99, 114, 105, 98, 101, 0, 1, 2, 1, 64, 2, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 1, 1, 0, 4, 4, 115, 101, 110, 100, 0, 1, 3, 4, 5, 101, 118, 101, 110, 116, 16, 112, 107, 103, 58, 47, 101, 118, 101, 110, 116, 47, 101, 118, 101, 110, 116, 5, 12, 11, 21, 1, 5, 101, 118, 101, 110, 116, 10, 112, 107, 103, 58, 47, 101, 118, 101, 110, 116, 3, 10, 0, 7, 167, 15, 1, 65, 16, 1, 66, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 12, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 14, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 16, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 118, 101, 99, 52, 2, 3, 0, 0, 5, 117, 118, 101, 99, 50, 2, 3, 0, 0, 5, 117, 118, 101, 99, 51, 2, 3, 0, 0, 5, 117, 118, 101, 99, 52, 1, 66, 66, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 4, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 6, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 2, 3, 2, 1, 7, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 12, 2, 3, 2, 1, 8, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 14, 2, 3, 2, 1, 9, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 16, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 0, 3, 0, 18, 1, 112, 121, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 20, 7, 105, 110, 99, 108, 117, 100, 101, 20, 7, 101, 120, 99, 108, 117, 100, 101, 20, 7, 99, 104, 97, 110, 103, 101, 100, 20, 4, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 0, 3, 0, 21, 1, 111, 0, 1, 107, 23, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 113, 17, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 24, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 25, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 26, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 27, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 28, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 29, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 30, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 31, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 32, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 33, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 34, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 35, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 36, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 37, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 38, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 39, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 40, 0, 4, 21, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 111, 112, 116, 105, 111, 110, 45, 116, 121, 112, 101, 0, 3, 0, 41, 1, 112, 23, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 113, 17, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 43, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 44, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 45, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 46, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 47, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 48, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 49, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 50, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 51, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 20, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 52, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 53, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 54, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 55, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 56, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 57, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 58, 0, 4, 19, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 108, 105, 115, 116, 45, 116, 121, 112, 101, 0, 3, 0, 59, 1, 113, 19, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 23, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 9, 116, 121, 112, 101, 45, 108, 105, 115, 116, 1, 60, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 42, 0, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 61, 1, 111, 2, 121, 62, 1, 112, 63, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 64, 3, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 10, 2, 3, 0, 1, 6, 101, 110, 116, 105, 116, 121, 1, 66, 27, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 11, 4, 11, 101, 110, 116, 105, 116, 121, 45, 100, 97, 116, 97, 0, 3, 0, 6, 1, 114, 3, 8, 99, 108, 105, 112, 45, 117, 114, 108, 115, 7, 108, 111, 111, 112, 105, 110, 103, 127, 6, 119, 101, 105, 103, 104, 116, 118, 4, 16, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 99, 116, 105, 111, 110, 0, 3, 0, 8, 1, 112, 9, 1, 114, 2, 7, 97, 99, 116, 105, 111, 110, 115, 10, 15, 97, 112, 112, 108, 121, 45, 98, 97, 115, 101, 45, 112, 111, 115, 101, 127, 4, 20, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 0, 3, 0, 11, 1, 64, 1, 4, 100, 97, 116, 97, 7, 0, 1, 4, 5, 115, 112, 97, 119, 110, 0, 1, 13, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 127, 4, 7, 100, 101, 115, 112, 97, 119, 110, 0, 1, 14, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 20, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 12, 1, 0, 4, 24, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 0, 1, 15, 1, 112, 1, 1, 64, 2, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 114, 97, 100, 105, 117, 115, 118, 0, 16, 4, 7, 105, 110, 45, 97, 114, 101, 97, 0, 1, 17, 4, 6, 101, 120, 105, 115, 116, 115, 0, 1, 14, 1, 64, 1, 5, 105, 110, 100, 101, 120, 121, 0, 16, 4, 7, 103, 101, 116, 45, 97, 108, 108, 0, 1, 18, 1, 64, 0, 0, 1, 4, 9, 114, 101, 115, 111, 117, 114, 99, 101, 115, 0, 1, 19, 4, 6, 101, 110, 116, 105, 116, 121, 18, 112, 107, 103, 58, 47, 101, 110, 116, 105, 116, 121, 47, 101, 110, 116, 105, 116, 121, 5, 12, 11, 23, 1, 6, 101, 110, 116, 105, 116, 121, 11, 112, 107, 103, 58, 47, 101, 110, 116, 105, 116, 121, 3, 12, 0, 7, 54, 1, 65, 2, 1, 66, 3, 1, 107, 115, 1, 64, 1, 4, 112, 97, 116, 104, 115, 0, 0, 4, 3, 117, 114, 108, 0, 1, 1, 4, 5, 97, 115, 115, 101, 116, 16, 112, 107, 103, 58, 47, 97, 115, 115, 101, 116, 47, 97, 115, 115, 101, 116, 5, 0, 11, 21, 1, 5, 97, 115, 115, 101, 116, 10, 112, 107, 103, 58, 47, 97, 115, 115, 101, 116, 3, 14, 0, 7, 196, 35, 1, 65, 2, 1, 65, 27, 1, 66, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 6, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 8, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 10, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 12, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 14, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 16, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 118, 101, 99, 52, 2, 3, 0, 0, 5, 117, 118, 101, 99, 50, 2, 3, 0, 0, 5, 117, 118, 101, 99, 51, 2, 3, 0, 0, 5, 117, 118, 101, 99, 52, 1, 66, 92, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 4, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 6, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 2, 3, 2, 1, 7, 4, 5, 117, 118, 101, 99, 50, 0, 3, 0, 12, 2, 3, 2, 1, 8, 4, 5, 117, 118, 101, 99, 51, 0, 3, 0, 14, 2, 3, 2, 1, 9, 4, 5, 117, 118, 101, 99, 52, 0, 3, 0, 16, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 0, 3, 0, 18, 1, 112, 121, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 20, 7, 105, 110, 99, 108, 117, 100, 101, 20, 7, 101, 120, 99, 108, 117, 100, 101, 20, 7, 99, 104, 97, 110, 103, 101, 100, 20, 4, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 0, 3, 0, 21, 1, 111, 0, 1, 107, 23, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 113, 17, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 24, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 25, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 26, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 27, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 28, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 29, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 30, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 31, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 32, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 33, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 34, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 35, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 36, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 37, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 38, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 39, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 40, 0, 4, 21, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 111, 112, 116, 105, 111, 110, 45, 116, 121, 112, 101, 0, 3, 0, 41, 1, 112, 23, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 113, 17, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 43, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 44, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 45, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 46, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 47, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 48, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 49, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 50, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 51, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 20, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 52, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 53, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 54, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 55, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 56, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 57, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 58, 0, 4, 19, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 108, 105, 115, 116, 45, 116, 121, 112, 101, 0, 3, 0, 59, 1, 113, 19, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 23, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 9, 116, 121, 112, 101, 45, 108, 105, 115, 116, 1, 60, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 42, 0, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 61, 1, 111, 2, 121, 62, 1, 112, 63, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 64, 1, 64, 1, 2, 105, 100, 115, 0, 33, 4, 9, 103, 101, 116, 45, 105, 110, 100, 101, 120, 0, 1, 66, 1, 107, 62, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 195, 0, 4, 13, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 68, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 5, 118, 97, 108, 117, 101, 62, 1, 0, 4, 13, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 69, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 4, 100, 97, 116, 97, 193, 0, 1, 0, 4, 14, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 70, 4, 13, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 69, 4, 14, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 70, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 127, 4, 13, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 71, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 20, 0, 127, 4, 14, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 72, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 1, 0, 4, 16, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 73, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 20, 1, 0, 4, 17, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 0, 1, 74, 1, 64, 2, 1, 113, 22, 1, 116, 19, 0, 119, 4, 5, 113, 117, 101, 114, 121, 0, 1, 75, 1, 112, 62, 1, 111, 2, 1, 204, 0, 1, 112, 205, 0, 1, 64, 1, 1, 113, 119, 0, 206, 0, 4, 10, 113, 117, 101, 114, 121, 45, 101, 118, 97, 108, 0, 1, 79, 3, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 10, 2, 3, 0, 1, 6, 101, 110, 116, 105, 116, 121, 1, 66, 27, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 11, 4, 11, 101, 110, 116, 105, 116, 121, 45, 100, 97, 116, 97, 0, 3, 0, 6, 1, 114, 3, 8, 99, 108, 105, 112, 45, 117, 114, 108, 115, 7, 108, 111, 111, 112, 105, 110, 103, 127, 6, 119, 101, 105, 103, 104, 116, 118, 4, 16, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 97, 99, 116, 105, 111, 110, 0, 3, 0, 8, 1, 112, 9, 1, 114, 2, 7, 97, 99, 116, 105, 111, 110, 115, 10, 15, 97, 112, 112, 108, 121, 45, 98, 97, 115, 101, 45, 112, 111, 115, 101, 127, 4, 20, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 0, 3, 0, 11, 1, 64, 1, 4, 100, 97, 116, 97, 7, 0, 1, 4, 5, 115, 112, 97, 119, 110, 0, 1, 13, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 127, 4, 7, 100, 101, 115, 112, 97, 119, 110, 0, 1, 14, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 20, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 12, 1, 0, 4, 24, 115, 101, 116, 45, 97, 110, 105, 109, 97, 116, 105, 111, 110, 45, 99, 111, 110, 116, 114, 111, 108, 108, 101, 114, 0, 1, 15, 1, 112, 1, 1, 64, 2, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 114, 97, 100, 105, 117, 115, 118, 0, 16, 4, 7, 105, 110, 45, 97, 114, 101, 97, 0, 1, 17, 4, 6, 101, 120, 105, 115, 116, 115, 0, 1, 14, 1, 64, 1, 5, 105, 110, 100, 101, 120, 121, 0, 16, 4, 7, 103, 101, 116, 45, 97, 108, 108, 0, 1, 18, 1, 64, 0, 0, 1, 4, 9, 114, 101, 115, 111, 117, 114, 99, 101, 115, 0, 1, 19, 3, 6, 101, 110, 116, 105, 116, 121, 18, 112, 107, 103, 58, 47, 101, 110, 116, 105, 116, 121, 47, 101, 110, 116, 105, 116, 121, 5, 12, 1, 66, 16, 2, 3, 2, 1, 4, 4, 4, 118, 101, 99, 50, 0, 3, 0, 0, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 2, 1, 109, 163, 1, 4, 107, 101, 121, 49, 4, 107, 101, 121, 50, 4, 107, 101, 121, 51, 4, 107, 101, 121, 52, 4, 107, 101, 121, 53, 4, 107, 101, 121, 54, 4, 107, 101, 121, 55, 4, 107, 101, 121, 56, 4, 107, 101, 121, 57, 4, 107, 101, 121, 48, 1, 97, 1, 98, 1, 99, 1, 100, 1, 101, 1, 102, 1, 103, 1, 104, 1, 105, 1, 106, 1, 107, 1, 108, 1, 109, 1, 110, 1, 111, 1, 112, 1, 113, 1, 114, 1, 115, 1, 116, 1, 117, 1, 118, 1, 119, 1, 120, 1, 121, 1, 122, 6, 101, 115, 99, 97, 112, 101, 2, 102, 49, 2, 102, 50, 2, 102, 51, 2, 102, 52, 2, 102, 53, 2, 102, 54, 2, 102, 55, 2, 102, 56, 2, 102, 57, 3, 102, 49, 48, 3, 102, 49, 49, 3, 102, 49, 50, 3, 102, 49, 51, 3, 102, 49, 52, 3, 102, 49, 53, 3, 102, 49, 54, 3, 102, 49, 55, 3, 102, 49, 56, 3, 102, 49, 57, 3, 102, 50, 48, 3, 102, 50, 49, 3, 102, 50, 50, 3, 102, 50, 51, 3, 102, 50, 52, 8, 115, 110, 97, 112, 115, 104, 111, 116, 6, 115, 99, 114, 111, 108, 108, 5, 112, 97, 117, 115, 101, 6, 105, 110, 115, 101, 114, 116, 4, 104, 111, 109, 101, 6, 100, 101, 108, 101, 116, 101, 3, 101, 110, 100, 9, 112, 97, 103, 101, 45, 100, 111, 119, 110, 7, 112, 97, 103, 101, 45, 117, 112, 4, 108, 101, 102, 116, 2, 117, 112, 5, 114, 105, 103, 104, 116, 4, 100, 111, 119, 110, 4, 98, 97, 99, 107, 6, 114, 101, 116, 117, 114, 110, 5, 115, 112, 97, 99, 101, 7, 99, 111, 109, 112, 111, 115, 101, 5, 99, 97, 114, 101, 116, 7, 110, 117, 109, 108, 111, 99, 107, 7, 110, 117, 109, 112, 97, 100, 48, 7, 110, 117, 109, 112, 97, 100, 49, 7, 110, 117, 109, 112, 97, 100, 50, 7, 110, 117, 109, 112, 97, 100, 51, 7, 110, 117, 109, 112, 97, 100, 52, 7, 110, 117, 109, 112, 97, 100, 53, 7, 110, 117, 109, 112, 97, 100, 54, 7, 110, 117, 109, 112, 97, 100, 55, 7, 110, 117, 109, 112, 97, 100, 56, 7, 110, 117, 109, 112, 97, 100, 57, 10, 110, 117, 109, 112, 97, 100, 45, 97, 100, 100, 13, 110, 117, 109, 112, 97, 100, 45, 100, 105, 118, 105, 100, 101, 14, 110, 117, 109, 112, 97, 100, 45, 100, 101, 99, 105, 109, 97, 108, 12, 110, 117, 109, 112, 97, 100, 45, 99, 111, 109, 109, 97, 12, 110, 117, 109, 112, 97, 100, 45, 101, 110, 116, 101, 114, 13, 110, 117, 109, 112, 97, 100, 45, 101, 113, 117, 97, 108, 115, 15, 110, 117, 109, 112, 97, 100, 45, 109, 117, 108, 116, 105, 112, 108, 121, 15, 110, 117, 109, 112, 97, 100, 45, 115, 117, 98, 116, 114, 97, 99, 116, 7, 97, 98, 110, 116, 45, 99, 49, 7, 97, 98, 110, 116, 45, 99, 50, 10, 97, 112, 111, 115, 116, 114, 111, 112, 104, 101, 4, 97, 112, 112, 115, 8, 97, 115, 116, 101, 114, 105, 115, 107, 2, 97, 116, 2, 97, 120, 9, 98, 97, 99, 107, 115, 108, 97, 115, 104, 10, 99, 97, 108, 99, 117, 108, 97, 116, 111, 114, 7, 99, 97, 112, 105, 116, 97, 108, 5, 99, 111, 108, 111, 110, 5, 99, 111, 109, 109, 97, 7, 99, 111, 110, 118, 101, 114, 116, 6, 101, 113, 117, 97, 108, 115, 5, 103, 114, 97, 118, 101, 4, 107, 97, 110, 97, 5, 107, 97, 110, 106, 105, 5, 108, 45, 97, 108, 116, 9, 108, 45, 98, 114, 97, 99, 107, 101, 116, 9, 108, 45, 99, 111, 110, 116, 114, 111, 108, 7, 108, 45, 115, 104, 105, 102, 116, 5, 108, 45, 119, 105, 110, 4, 109, 97, 105, 108, 12, 109, 101, 100, 105, 97, 45, 115, 101, 108, 101, 99, 116, 10, 109, 101, 100, 105, 97, 45, 115, 116, 111, 112, 5, 109, 105, 110, 117, 115, 4, 109, 117, 116, 101, 11, 109, 121, 45, 99, 111, 109, 112, 117, 116, 101, 114, 16, 110, 97, 118, 105, 103, 97, 116, 101, 45, 102, 111, 114, 119, 97, 114, 100, 17, 110, 97, 118, 105, 103, 97, 116, 101, 45, 98, 97, 99, 107, 119, 97, 114, 100, 10, 110, 101, 120, 116, 45, 116, 114, 97, 99, 107, 10, 110, 111, 45, 99, 111, 110, 118, 101, 114, 116, 6, 111, 101, 109, 49, 48, 50, 6, 112, 101, 114, 105, 111, 100, 10, 112, 108, 97, 121, 45, 112, 97, 117, 115, 101, 4, 112, 108, 117, 115, 5, 112, 111, 119, 101, 114, 10, 112, 114, 101, 118, 45, 116, 114, 97, 99, 107, 5, 114, 45, 97, 108, 116, 9, 114, 45, 98, 114, 97, 99, 107, 101, 116, 9, 114, 45, 99, 111, 110, 116, 114, 111, 108, 7, 114, 45, 115, 104, 105, 102, 116, 5, 114, 45, 119, 105, 110, 9, 115, 101, 109, 105, 99, 111, 108, 111, 110, 5, 115, 108, 97, 115, 104, 5, 115, 108, 101, 101, 112, 4, 115, 116, 111, 112, 5, 115, 121, 115, 114, 113, 3, 116, 97, 98, 9, 117, 110, 100, 101, 114, 108, 105, 110, 101, 9, 117, 110, 108, 97, 98, 101, 108, 101, 100, 11, 118, 111, 108, 117, 109, 101, 45, 100, 111, 119, 110, 9, 118, 111, 108, 117, 109, 101, 45, 117, 112, 4, 119, 97, 107, 101, 8, 119, 101, 98, 45, 98, 97, 99, 107, 13, 119, 101, 98, 45, 102, 97, 118, 111, 114, 105, 116, 101, 115, 11, 119, 101, 98, 45, 102, 111, 114, 119, 97, 114, 100, 8, 119, 101, 98, 45, 104, 111, 109, 101, 11, 119, 101, 98, 45, 114, 101, 102, 114, 101, 115, 104, 10, 119, 101, 98, 45, 115, 101, 97, 114, 99, 104, 8, 119, 101, 98, 45, 115, 116, 111, 112, 3, 121, 101, 110, 4, 99, 111, 112, 121, 5, 112, 97, 115, 116, 101, 3, 99, 117, 116, 4, 16, 118, 105, 114, 116, 117, 97, 108, 45, 107, 101, 121, 45, 99, 111, 100, 101, 0, 3, 0, 4, 1, 113, 4, 4, 108, 101, 102, 116, 0, 0, 5, 114, 105, 103, 104, 116, 0, 0, 6, 109, 105, 100, 100, 108, 101, 0, 0, 5, 111, 116, 104, 101, 114, 1, 123, 0, 4, 12, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 0, 3, 0, 6, 1, 112, 5, 1, 112, 7, 1, 114, 5, 4, 107, 101, 121, 115, 8, 14, 109, 111, 117, 115, 101, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 15, 99, 117, 114, 115, 111, 114, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 11, 109, 111, 117, 115, 101, 45, 119, 104, 101, 101, 108, 118, 13, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 115, 9, 4, 9, 114, 97, 119, 45, 105, 110, 112, 117, 116, 0, 3, 0, 10, 1, 107, 11, 1, 64, 1, 6, 112, 108, 97, 121, 101, 114, 3, 0, 12, 4, 13, 103, 101, 116, 45, 114, 97, 119, 45, 105, 110, 112, 117, 116, 0, 1, 13, 4, 18, 103, 101, 116, 45, 112, 114, 101, 118, 45, 114, 97, 119, 45, 105, 110, 112, 117, 116, 0, 1, 13, 3, 6, 112, 108, 97, 121, 101, 114, 18, 112, 107, 103, 58, 47, 112, 108, 97, 121, 101, 114, 47, 112, 108, 97, 121, 101, 114, 5, 13, 1, 66, 29, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 3, 4, 115, 105, 100, 101, 127, 2, 117, 112, 127, 4, 100, 111, 119, 110, 127, 4, 19, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 99, 111, 108, 108, 105, 115, 105, 111, 110, 0, 3, 0, 4, 1, 112, 1, 1, 64, 2, 8, 101, 110, 116, 105, 116, 105, 101, 115, 6, 5, 102, 111, 114, 99, 101, 3, 1, 0, 4, 11, 97, 112, 112, 108, 121, 45, 102, 111, 114, 99, 101, 0, 1, 7, 1, 107, 118, 1, 64, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 5, 102, 111, 114, 99, 101, 118, 6, 114, 97, 100, 105, 117, 115, 118, 14, 102, 97, 108, 108, 111, 102, 102, 45, 114, 97, 100, 105, 117, 115, 8, 1, 0, 4, 12, 101, 120, 112, 108, 111, 100, 101, 45, 98, 111, 109, 98, 0, 1, 9, 1, 64, 1, 7, 103, 114, 97, 118, 105, 116, 121, 3, 1, 0, 4, 11, 115, 101, 116, 45, 103, 114, 97, 118, 105, 116, 121, 0, 1, 10, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 1, 0, 4, 8, 117, 110, 102, 114, 101, 101, 122, 101, 0, 1, 11, 4, 6, 102, 114, 101, 101, 122, 101, 0, 1, 11, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 118, 101, 108, 111, 99, 105, 116, 121, 118, 1, 0, 4, 11, 115, 116, 97, 114, 116, 45, 109, 111, 116, 111, 114, 0, 1, 12, 4, 10, 115, 116, 111, 112, 45, 109, 111, 116, 111, 114, 0, 1, 11, 1, 111, 2, 1, 118, 1, 107, 13, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 14, 4, 13, 114, 97, 121, 99, 97, 115, 116, 45, 102, 105, 114, 115, 116, 0, 1, 15, 1, 112, 13, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 16, 4, 7, 114, 97, 121, 99, 97, 115, 116, 0, 1, 17, 1, 64, 4, 6, 101, 110, 116, 105, 116, 121, 1, 12, 100, 105, 115, 112, 108, 97, 99, 101, 109, 101, 110, 116, 3, 8, 109, 105, 110, 45, 100, 105, 115, 116, 118, 12, 101, 108, 97, 112, 115, 101, 100, 45, 116, 105, 109, 101, 118, 0, 5, 4, 14, 109, 111, 118, 101, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 0, 1, 18, 3, 7, 112, 104, 121, 115, 105, 99, 115, 20, 112, 107, 103, 58, 47, 112, 104, 121, 115, 105, 99, 115, 47, 112, 104, 121, 115, 105, 99, 115, 5, 14, 1, 66, 6, 2, 3, 2, 1, 11, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 0, 1, 64, 1, 4, 110, 97, 109, 101, 115, 1, 0, 4, 9, 115, 117, 98, 115, 99, 114, 105, 98, 101, 0, 1, 2, 1, 64, 2, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 1, 1, 0, 4, 4, 115, 101, 110, 100, 0, 1, 3, 3, 5, 101, 118, 101, 110, 116, 16, 112, 107, 103, 58, 47, 101, 118, 101, 110, 116, 47, 101, 118, 101, 110, 116, 5, 15, 1, 66, 3, 1, 107, 115, 1, 64, 1, 4, 112, 97, 116, 104, 115, 0, 0, 4, 3, 117, 114, 108, 0, 1, 1, 3, 5, 97, 115, 115, 101, 116, 16, 112, 107, 103, 58, 47, 97, 115, 115, 101, 116, 47, 97, 115, 115, 101, 116, 5, 16, 2, 3, 0, 1, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 1, 66, 8, 2, 3, 2, 1, 17, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 0, 1, 64, 1, 17, 105, 110, 116, 101, 114, 102, 97, 99, 101, 45, 118, 101, 114, 115, 105, 111, 110, 121, 1, 0, 4, 4, 105, 110, 105, 116, 0, 1, 2, 1, 111, 2, 121, 1, 1, 112, 3, 1, 64, 3, 4, 116, 105, 109, 101, 118, 10, 101, 118, 101, 110, 116, 45, 110, 97, 109, 101, 115, 10, 101, 118, 101, 110, 116, 45, 100, 97, 116, 97, 4, 1, 0, 4, 4, 101, 120, 101, 99, 0, 1, 5, 4, 5, 103, 117, 101, 115, 116, 16, 112, 107, 103, 58, 47, 103, 117, 101, 115, 116, 47, 103, 117, 101, 115, 116, 5, 18, 4, 8, 98, 105, 110, 100, 105, 110, 103, 115, 18, 112, 107, 103, 58, 47, 109, 97, 105, 110, 47, 98, 105, 110, 100, 105, 110, 103, 115, 4, 0, 0, 68, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 48, 46, 55, 46, 51, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 5, 48, 46, 51, 46, 48, 11, 19, 1, 4, 109, 97, 105, 110, 9, 112, 107, 103, 58, 47, 109, 97, 105, 110, 3, 16, 0];
                                  
                                  #[inline(never)]
                                  #[doc(hidden)]
                                  #[cfg(target_arch = "wasm32")]
                                  pub fn __link_section() {}
                                  
#[allow(missing_docs)] pub const INTERFACE_VERSION: u32 = 11;