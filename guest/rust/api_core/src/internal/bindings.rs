// Generated by `wit-bindgen` 0.9.0. DO NOT EDIT!
pub mod ambient {
  pub mod bindings {
    
    #[allow(clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct EntityId {
        pub id0: u64,
        pub id1: u64,
      }
      impl ::core::fmt::Debug for EntityId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("EntityId").field("id0", &self.id0).field("id1", &self.id1).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Vec2 {
        pub x: f32,
        pub y: f32,
      }
      impl ::core::fmt::Debug for Vec2 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Vec2").field("x", &self.x).field("y", &self.y).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Vec3 {
        pub x: f32,
        pub y: f32,
        pub z: f32,
      }
      impl ::core::fmt::Debug for Vec3 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Vec3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Vec4 {
        pub x: f32,
        pub y: f32,
        pub z: f32,
        pub w: f32,
      }
      impl ::core::fmt::Debug for Vec4 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Vec4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Uvec2 {
        pub x: u32,
        pub y: u32,
      }
      impl ::core::fmt::Debug for Uvec2 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Uvec2").field("x", &self.x).field("y", &self.y).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Uvec3 {
        pub x: u32,
        pub y: u32,
        pub z: u32,
      }
      impl ::core::fmt::Debug for Uvec3 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Uvec3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Uvec4 {
        pub x: u32,
        pub y: u32,
        pub z: u32,
        pub w: u32,
      }
      impl ::core::fmt::Debug for Uvec4 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Uvec4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Ivec2 {
        pub x: i32,
        pub y: i32,
      }
      impl ::core::fmt::Debug for Ivec2 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Ivec2").field("x", &self.x).field("y", &self.y).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Ivec3 {
        pub x: i32,
        pub y: i32,
        pub z: i32,
      }
      impl ::core::fmt::Debug for Ivec3 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Ivec3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Ivec4 {
        pub x: i32,
        pub y: i32,
        pub z: i32,
        pub w: i32,
      }
      impl ::core::fmt::Debug for Ivec4 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Ivec4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Quat {
        pub x: f32,
        pub y: f32,
        pub z: f32,
        pub w: f32,
      }
      impl ::core::fmt::Debug for Quat {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Quat").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Mat4 {
        pub x: Vec4,
        pub y: Vec4,
        pub z: Vec4,
        pub w: Vec4,
      }
      impl ::core::fmt::Debug for Mat4 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Mat4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
        }
      }
      #[repr(C)]
      #[derive(Copy, Clone)]
      pub struct Duration {
        pub seconds: u64,
        pub nanoseconds: u32,
      }
      impl ::core::fmt::Debug for Duration {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Duration").field("seconds", &self.seconds).field("nanoseconds", &self.nanoseconds).finish()
        }
      }
      pub type Ulid = (u64,u64,);
      
    }
    
    
    #[allow(clippy::all)]
    pub mod asset {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      
      #[derive(Clone)]
      pub enum UrlError{
        InvalidUrl(wit_bindgen::rt::string::String),
      }
      impl ::core::fmt::Debug for UrlError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UrlError::InvalidUrl(e) => {
              f.debug_tuple("UrlError::InvalidUrl").field(e).finish()
            }
          }
        }
      }
      impl ::core::fmt::Display for UrlError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)}
        }
        
        impl std::error::Error for UrlError {}
        #[allow(clippy::all)]
        pub fn url(path: &str,) -> Result<wit_bindgen::rt::string::String,UrlError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = path;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/asset")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "url")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/asset_url")]
              fn wit_import(
              _: i32, _: i32, _: i32, );
            }
            wit_import(ptr0, len0, ptr1);
            match i32::from(*((ptr1 + 0) as *const u8)) {
              0 => Ok({
                let len2 = *((ptr1 + 8) as *const i32) as usize;
                
                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 4) as *const i32) as *mut _, len2, len2)).unwrap()}}
              }),
              1 => Err({{match i32::from(*((ptr1 + 4) as *const u8)) {
                #[cfg(debug_assertions)]0 => UrlError::InvalidUrl({
                  let len3 = *((ptr1 + 12) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3)).unwrap()}}
                }),
                #[cfg(not(debug_assertions))]_ => UrlError::InvalidUrl({
                  let len3 = *((ptr1 + 12) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 8) as *const i32) as *mut _, len3, len3)).unwrap()}}
                }),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}),
              #[cfg(not(debug_assertions))]
              _ => ::core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }
          }
        }
        
      }
      
      
      #[allow(clippy::all)]
      pub mod client_mesh {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
        
        pub type Vec2 = super::super::super::ambient::bindings::types::Vec2;
        pub type Vec3 = super::super::super::ambient::bindings::types::Vec3;
        pub type Ulid = super::super::super::ambient::bindings::types::Ulid;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Vertex {
          pub position: Vec3,
          pub normal: Vec3,
          pub tangent: Vec3,
          pub texcoord0: Vec2,
        }
        impl ::core::fmt::Debug for Vertex {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Vertex").field("position", &self.position).field("normal", &self.normal).field("tangent", &self.tangent).field("texcoord0", &self.texcoord0).finish()
          }
        }
        #[derive(Clone)]
        pub struct Descriptor {
          pub vertices: wit_bindgen::rt::vec::Vec::<Vertex>,
          pub indices: wit_bindgen::rt::vec::Vec::<u32>,
        }
        impl ::core::fmt::Debug for Descriptor {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Descriptor").field("vertices", &self.vertices).field("indices", &self.indices).finish()
          }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Handle {
          pub ulid: Ulid,
        }
        impl ::core::fmt::Debug for Handle {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Handle").field("ulid", &self.ulid).finish()
          }
        }
        #[allow(clippy::all)]
        pub fn create(desc: &Descriptor,) -> Handle{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let Descriptor{ vertices:vertices0, indices:indices0, } = desc;
            let vec1 = vertices0;
            let ptr1 = vec1.as_ptr() as i32;
            let len1 = vec1.len() as i32;
            let vec2 = indices0;
            let ptr2 = vec2.as_ptr() as i32;
            let len2 = vec2.len() as i32;
            let ptr3 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/client-mesh")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "create")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-mesh_create")]
              fn wit_import(
              _: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            wit_import(ptr1, len1, ptr2, len2, ptr3);
            Handle{ulid:(*((ptr3 + 0) as *const i64) as u64, *((ptr3 + 8) as *const i64) as u64), }
          }
        }
        #[allow(clippy::all)]
        pub fn destroy(handle: Handle,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            let Handle{ ulid:ulid0, } = handle;
            let (t1_0, t1_1, ) = ulid0;
            
            #[link(wasm_import_module = "ambient:bindings/client-mesh")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-mesh_destroy")]
              fn wit_import(
              _: i64, _: i64, );
            }
            wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
          }
        }
        
      }
      
      
      #[allow(clippy::all)]
      pub mod client_texture {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
        
        pub type Ulid = super::super::super::ambient::bindings::types::Ulid;
        #[derive(Clone, Copy)]
        pub enum Format{
          R8Unorm,
          R8Snorm,
          R8Uint,
          R8Sint,
          R16Uint,
          R16Sint,
          R16Unorm,
          R16Snorm,
          R16Float,
          Rg8Unorm,
          Rg8Snorm,
          Rg8Uint,
          Rg8Sint,
          R32Uint,
          R32Sint,
          R32Float,
          Rg16Uint,
          Rg16Sint,
          Rg16Unorm,
          Rg16Snorm,
          Rg16Float,
          Rgba8Unorm,
          Rgba8UnormSrgb,
          Rgba8Snorm,
          Rgba8Uint,
          Rgba8Sint,
          Bgra8Unorm,
          Bgra8UnormSrgb,
          Rgb9e5Ufloat,
          Rgb10a2Unorm,
          Rg11b10Float,
          Rg32Uint,
          Rg32Sint,
          Rg32Float,
          Rgba16Uint,
          Rgba16Sint,
          Rgba16Unorm,
          Rgba16Snorm,
          Rgba16Float,
          Rgba32Uint,
          Rgba32Sint,
          Rgba32Float,
        }
        impl ::core::fmt::Debug for Format {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Format::R8Unorm => {
                f.debug_tuple("Format::R8Unorm").finish()
              }
              Format::R8Snorm => {
                f.debug_tuple("Format::R8Snorm").finish()
              }
              Format::R8Uint => {
                f.debug_tuple("Format::R8Uint").finish()
              }
              Format::R8Sint => {
                f.debug_tuple("Format::R8Sint").finish()
              }
              Format::R16Uint => {
                f.debug_tuple("Format::R16Uint").finish()
              }
              Format::R16Sint => {
                f.debug_tuple("Format::R16Sint").finish()
              }
              Format::R16Unorm => {
                f.debug_tuple("Format::R16Unorm").finish()
              }
              Format::R16Snorm => {
                f.debug_tuple("Format::R16Snorm").finish()
              }
              Format::R16Float => {
                f.debug_tuple("Format::R16Float").finish()
              }
              Format::Rg8Unorm => {
                f.debug_tuple("Format::Rg8Unorm").finish()
              }
              Format::Rg8Snorm => {
                f.debug_tuple("Format::Rg8Snorm").finish()
              }
              Format::Rg8Uint => {
                f.debug_tuple("Format::Rg8Uint").finish()
              }
              Format::Rg8Sint => {
                f.debug_tuple("Format::Rg8Sint").finish()
              }
              Format::R32Uint => {
                f.debug_tuple("Format::R32Uint").finish()
              }
              Format::R32Sint => {
                f.debug_tuple("Format::R32Sint").finish()
              }
              Format::R32Float => {
                f.debug_tuple("Format::R32Float").finish()
              }
              Format::Rg16Uint => {
                f.debug_tuple("Format::Rg16Uint").finish()
              }
              Format::Rg16Sint => {
                f.debug_tuple("Format::Rg16Sint").finish()
              }
              Format::Rg16Unorm => {
                f.debug_tuple("Format::Rg16Unorm").finish()
              }
              Format::Rg16Snorm => {
                f.debug_tuple("Format::Rg16Snorm").finish()
              }
              Format::Rg16Float => {
                f.debug_tuple("Format::Rg16Float").finish()
              }
              Format::Rgba8Unorm => {
                f.debug_tuple("Format::Rgba8Unorm").finish()
              }
              Format::Rgba8UnormSrgb => {
                f.debug_tuple("Format::Rgba8UnormSrgb").finish()
              }
              Format::Rgba8Snorm => {
                f.debug_tuple("Format::Rgba8Snorm").finish()
              }
              Format::Rgba8Uint => {
                f.debug_tuple("Format::Rgba8Uint").finish()
              }
              Format::Rgba8Sint => {
                f.debug_tuple("Format::Rgba8Sint").finish()
              }
              Format::Bgra8Unorm => {
                f.debug_tuple("Format::Bgra8Unorm").finish()
              }
              Format::Bgra8UnormSrgb => {
                f.debug_tuple("Format::Bgra8UnormSrgb").finish()
              }
              Format::Rgb9e5Ufloat => {
                f.debug_tuple("Format::Rgb9e5Ufloat").finish()
              }
              Format::Rgb10a2Unorm => {
                f.debug_tuple("Format::Rgb10a2Unorm").finish()
              }
              Format::Rg11b10Float => {
                f.debug_tuple("Format::Rg11b10Float").finish()
              }
              Format::Rg32Uint => {
                f.debug_tuple("Format::Rg32Uint").finish()
              }
              Format::Rg32Sint => {
                f.debug_tuple("Format::Rg32Sint").finish()
              }
              Format::Rg32Float => {
                f.debug_tuple("Format::Rg32Float").finish()
              }
              Format::Rgba16Uint => {
                f.debug_tuple("Format::Rgba16Uint").finish()
              }
              Format::Rgba16Sint => {
                f.debug_tuple("Format::Rgba16Sint").finish()
              }
              Format::Rgba16Unorm => {
                f.debug_tuple("Format::Rgba16Unorm").finish()
              }
              Format::Rgba16Snorm => {
                f.debug_tuple("Format::Rgba16Snorm").finish()
              }
              Format::Rgba16Float => {
                f.debug_tuple("Format::Rgba16Float").finish()
              }
              Format::Rgba32Uint => {
                f.debug_tuple("Format::Rgba32Uint").finish()
              }
              Format::Rgba32Sint => {
                f.debug_tuple("Format::Rgba32Sint").finish()
              }
              Format::Rgba32Float => {
                f.debug_tuple("Format::Rgba32Float").finish()
              }
            }
          }
        }
        #[derive(Clone)]
        pub struct Descriptor2d {
          pub width: u32,
          pub height: u32,
          pub format: Format,
          pub data: wit_bindgen::rt::vec::Vec::<u8>,
        }
        impl ::core::fmt::Debug for Descriptor2d {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Descriptor2d").field("width", &self.width).field("height", &self.height).field("format", &self.format).field("data", &self.data).finish()
          }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Handle {
          pub ulid: Ulid,
        }
        impl ::core::fmt::Debug for Handle {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Handle").field("ulid", &self.ulid).finish()
          }
        }
        #[allow(clippy::all)]
        pub fn create2d(desc: &Descriptor2d,) -> Handle{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let Descriptor2d{ width:width0, height:height0, format:format0, data:data0, } = desc;
            let result1 = match format0 {
              Format::R8Unorm=> {
                0i32
              }
              Format::R8Snorm=> {
                1i32
              }
              Format::R8Uint=> {
                2i32
              }
              Format::R8Sint=> {
                3i32
              }
              Format::R16Uint=> {
                4i32
              }
              Format::R16Sint=> {
                5i32
              }
              Format::R16Unorm=> {
                6i32
              }
              Format::R16Snorm=> {
                7i32
              }
              Format::R16Float=> {
                8i32
              }
              Format::Rg8Unorm=> {
                9i32
              }
              Format::Rg8Snorm=> {
                10i32
              }
              Format::Rg8Uint=> {
                11i32
              }
              Format::Rg8Sint=> {
                12i32
              }
              Format::R32Uint=> {
                13i32
              }
              Format::R32Sint=> {
                14i32
              }
              Format::R32Float=> {
                15i32
              }
              Format::Rg16Uint=> {
                16i32
              }
              Format::Rg16Sint=> {
                17i32
              }
              Format::Rg16Unorm=> {
                18i32
              }
              Format::Rg16Snorm=> {
                19i32
              }
              Format::Rg16Float=> {
                20i32
              }
              Format::Rgba8Unorm=> {
                21i32
              }
              Format::Rgba8UnormSrgb=> {
                22i32
              }
              Format::Rgba8Snorm=> {
                23i32
              }
              Format::Rgba8Uint=> {
                24i32
              }
              Format::Rgba8Sint=> {
                25i32
              }
              Format::Bgra8Unorm=> {
                26i32
              }
              Format::Bgra8UnormSrgb=> {
                27i32
              }
              Format::Rgb9e5Ufloat=> {
                28i32
              }
              Format::Rgb10a2Unorm=> {
                29i32
              }
              Format::Rg11b10Float=> {
                30i32
              }
              Format::Rg32Uint=> {
                31i32
              }
              Format::Rg32Sint=> {
                32i32
              }
              Format::Rg32Float=> {
                33i32
              }
              Format::Rgba16Uint=> {
                34i32
              }
              Format::Rgba16Sint=> {
                35i32
              }
              Format::Rgba16Unorm=> {
                36i32
              }
              Format::Rgba16Snorm=> {
                37i32
              }
              Format::Rgba16Float=> {
                38i32
              }
              Format::Rgba32Uint=> {
                39i32
              }
              Format::Rgba32Sint=> {
                40i32
              }
              Format::Rgba32Float=> {
                41i32
              }
            };
            let vec2 = data0;
            let ptr2 = vec2.as_ptr() as i32;
            let len2 = vec2.len() as i32;
            let ptr3 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/client-texture")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "create2d")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-texture_create2d")]
              fn wit_import(
              _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i32(width0), wit_bindgen::rt::as_i32(height0), result1, ptr2, len2, ptr3);
            Handle{ulid:(*((ptr3 + 0) as *const i64) as u64, *((ptr3 + 8) as *const i64) as u64), }
          }
        }
        #[allow(clippy::all)]
        pub fn destroy(handle: Handle,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            let Handle{ ulid:ulid0, } = handle;
            let (t1_0, t1_1, ) = ulid0;
            
            #[link(wasm_import_module = "ambient:bindings/client-texture")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-texture_destroy")]
              fn wit_import(
              _: i64, _: i64, );
            }
            wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
          }
        }
        
      }
      
      
      #[allow(clippy::all)]
      pub mod client_sampler {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
        
        pub type Ulid = super::super::super::ambient::bindings::types::Ulid;
        #[derive(Clone, Copy)]
        pub enum AddressMode{
          ClampToEdge,
          Repeat,
          MirrorRepeat,
        }
        impl ::core::fmt::Debug for AddressMode {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              AddressMode::ClampToEdge => {
                f.debug_tuple("AddressMode::ClampToEdge").finish()
              }
              AddressMode::Repeat => {
                f.debug_tuple("AddressMode::Repeat").finish()
              }
              AddressMode::MirrorRepeat => {
                f.debug_tuple("AddressMode::MirrorRepeat").finish()
              }
            }
          }
        }
        #[derive(Clone, Copy)]
        pub enum FilterMode{
          Nearest,
          Linear,
        }
        impl ::core::fmt::Debug for FilterMode {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              FilterMode::Nearest => {
                f.debug_tuple("FilterMode::Nearest").finish()
              }
              FilterMode::Linear => {
                f.debug_tuple("FilterMode::Linear").finish()
              }
            }
          }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Descriptor {
          pub address_mode_u: AddressMode,
          pub address_mode_v: AddressMode,
          pub address_mode_w: AddressMode,
          pub mag_filter: FilterMode,
          pub min_filter: FilterMode,
          pub mipmap_filter: FilterMode,
        }
        impl ::core::fmt::Debug for Descriptor {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Descriptor").field("address-mode-u", &self.address_mode_u).field("address-mode-v", &self.address_mode_v).field("address-mode-w", &self.address_mode_w).field("mag-filter", &self.mag_filter).field("min-filter", &self.min_filter).field("mipmap-filter", &self.mipmap_filter).finish()
          }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Handle {
          pub ulid: Ulid,
        }
        impl ::core::fmt::Debug for Handle {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Handle").field("ulid", &self.ulid).finish()
          }
        }
        #[allow(clippy::all)]
        pub fn create(desc: Descriptor,) -> Handle{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let Descriptor{ address_mode_u:address_mode_u0, address_mode_v:address_mode_v0, address_mode_w:address_mode_w0, mag_filter:mag_filter0, min_filter:min_filter0, mipmap_filter:mipmap_filter0, } = desc;
            let result1 = match address_mode_u0 {
              AddressMode::ClampToEdge=> {
                0i32
              }
              AddressMode::Repeat=> {
                1i32
              }
              AddressMode::MirrorRepeat=> {
                2i32
              }
            };
            let result2 = match address_mode_v0 {
              AddressMode::ClampToEdge=> {
                0i32
              }
              AddressMode::Repeat=> {
                1i32
              }
              AddressMode::MirrorRepeat=> {
                2i32
              }
            };
            let result3 = match address_mode_w0 {
              AddressMode::ClampToEdge=> {
                0i32
              }
              AddressMode::Repeat=> {
                1i32
              }
              AddressMode::MirrorRepeat=> {
                2i32
              }
            };
            let result4 = match mag_filter0 {
              FilterMode::Nearest=> {
                0i32
              }
              FilterMode::Linear=> {
                1i32
              }
            };
            let result5 = match min_filter0 {
              FilterMode::Nearest=> {
                0i32
              }
              FilterMode::Linear=> {
                1i32
              }
            };
            let result6 = match mipmap_filter0 {
              FilterMode::Nearest=> {
                0i32
              }
              FilterMode::Linear=> {
                1i32
              }
            };
            let ptr7 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/client-sampler")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "create")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-sampler_create")]
              fn wit_import(
              _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            wit_import(result1, result2, result3, result4, result5, result6, ptr7);
            Handle{ulid:(*((ptr7 + 0) as *const i64) as u64, *((ptr7 + 8) as *const i64) as u64), }
          }
        }
        #[allow(clippy::all)]
        pub fn destroy(handle: Handle,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            let Handle{ ulid:ulid0, } = handle;
            let (t1_0, t1_1, ) = ulid0;
            
            #[link(wasm_import_module = "ambient:bindings/client-sampler")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-sampler_destroy")]
              fn wit_import(
              _: i64, _: i64, );
            }
            wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
          }
        }
        
      }
      
      
      #[allow(clippy::all)]
      pub mod client_material {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
        
        pub type Ulid = super::super::super::ambient::bindings::types::Ulid;
        pub type TextureHandle = super::super::super::ambient::bindings::client_texture::Handle;
        pub type SamplerHandle = super::super::super::ambient::bindings::client_sampler::Handle;
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Descriptor {
          pub base_color_map: TextureHandle,
          pub normal_map: TextureHandle,
          pub metallic_roughness_map: TextureHandle,
          pub sampler: SamplerHandle,
          pub transparent: bool,
        }
        impl ::core::fmt::Debug for Descriptor {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Descriptor").field("base-color-map", &self.base_color_map).field("normal-map", &self.normal_map).field("metallic-roughness-map", &self.metallic_roughness_map).field("sampler", &self.sampler).field("transparent", &self.transparent).finish()
          }
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct Handle {
          pub ulid: Ulid,
        }
        impl ::core::fmt::Debug for Handle {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("Handle").field("ulid", &self.ulid).finish()
          }
        }
        #[allow(clippy::all)]
        pub fn create(desc: Descriptor,) -> Handle{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let Descriptor{ base_color_map:base_color_map0, normal_map:normal_map0, metallic_roughness_map:metallic_roughness_map0, sampler:sampler0, transparent:transparent0, } = desc;
            let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid1, } = base_color_map0;
            let (t2_0, t2_1, ) = ulid1;
            let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid3, } = normal_map0;
            let (t4_0, t4_1, ) = ulid3;
            let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid5, } = metallic_roughness_map0;
            let (t6_0, t6_1, ) = ulid5;
            let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid7, } = sampler0;
            let (t8_0, t8_1, ) = ulid7;
            let ptr9 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/client-material")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "create")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-material_create")]
              fn wit_import(
              _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i64, _: i32, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i64(t2_0), wit_bindgen::rt::as_i64(t2_1), wit_bindgen::rt::as_i64(t4_0), wit_bindgen::rt::as_i64(t4_1), wit_bindgen::rt::as_i64(t6_0), wit_bindgen::rt::as_i64(t6_1), wit_bindgen::rt::as_i64(t8_0), wit_bindgen::rt::as_i64(t8_1), match transparent0 { true => 1, false => 0 }, ptr9);
            Handle{ulid:(*((ptr9 + 0) as *const i64) as u64, *((ptr9 + 8) as *const i64) as u64), }
          }
        }
        #[allow(clippy::all)]
        pub fn destroy(handle: Handle,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            let Handle{ ulid:ulid0, } = handle;
            let (t1_0, t1_1, ) = ulid0;
            
            #[link(wasm_import_module = "ambient:bindings/client-material")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "destroy")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/client-material_destroy")]
              fn wit_import(
              _: i64, _: i64, );
            }
            wit_import(wit_bindgen::rt::as_i64(t1_0), wit_bindgen::rt::as_i64(t1_1));
          }
        }
        
      }
      
      
      #[allow(clippy::all)]
      pub mod component {
        #[used]
        #[doc(hidden)]
        #[cfg(target_arch = "wasm32")]
        static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
        
        pub type EntityId = super::super::super::ambient::bindings::types::EntityId;
        pub type Mat4 = super::super::super::ambient::bindings::types::Mat4;
        pub type Quat = super::super::super::ambient::bindings::types::Quat;
        pub type Vec2 = super::super::super::ambient::bindings::types::Vec2;
        pub type Vec3 = super::super::super::ambient::bindings::types::Vec3;
        pub type Vec4 = super::super::super::ambient::bindings::types::Vec4;
        pub type Uvec2 = super::super::super::ambient::bindings::types::Uvec2;
        pub type Uvec3 = super::super::super::ambient::bindings::types::Uvec3;
        pub type Uvec4 = super::super::super::ambient::bindings::types::Uvec4;
        pub type Ivec2 = super::super::super::ambient::bindings::types::Ivec2;
        pub type Ivec3 = super::super::super::ambient::bindings::types::Ivec3;
        pub type Ivec4 = super::super::super::ambient::bindings::types::Ivec4;
        pub type Duration = super::super::super::ambient::bindings::types::Duration;
        pub type ProceduralMeshHandle = super::super::super::ambient::bindings::client_mesh::Handle;
        pub type ProceduralTextureHandle = super::super::super::ambient::bindings::client_texture::Handle;
        pub type ProceduralSamplerHandle = super::super::super::ambient::bindings::client_sampler::Handle;
        pub type ProceduralMaterialHandle = super::super::super::ambient::bindings::client_material::Handle;
        #[derive(Clone)]
        pub enum VecValue{
          TypeBool(wit_bindgen::rt::vec::Vec::<bool>),
          TypeEntityId(wit_bindgen::rt::vec::Vec::<EntityId>),
          TypeF32(wit_bindgen::rt::vec::Vec::<f32>),
          TypeF64(wit_bindgen::rt::vec::Vec::<f64>),
          TypeMat4(wit_bindgen::rt::vec::Vec::<Mat4>),
          TypeQuat(wit_bindgen::rt::vec::Vec::<Quat>),
          TypeString(wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>),
          TypeU8(wit_bindgen::rt::vec::Vec::<u8>),
          TypeU16(wit_bindgen::rt::vec::Vec::<u16>),
          TypeU32(wit_bindgen::rt::vec::Vec::<u32>),
          TypeU64(wit_bindgen::rt::vec::Vec::<u64>),
          TypeI8(wit_bindgen::rt::vec::Vec::<i8>),
          TypeI16(wit_bindgen::rt::vec::Vec::<i16>),
          TypeI32(wit_bindgen::rt::vec::Vec::<i32>),
          TypeI64(wit_bindgen::rt::vec::Vec::<i64>),
          TypeVec2(wit_bindgen::rt::vec::Vec::<Vec2>),
          TypeVec3(wit_bindgen::rt::vec::Vec::<Vec3>),
          TypeVec4(wit_bindgen::rt::vec::Vec::<Vec4>),
          TypeUvec2(wit_bindgen::rt::vec::Vec::<Uvec2>),
          TypeUvec3(wit_bindgen::rt::vec::Vec::<Uvec3>),
          TypeUvec4(wit_bindgen::rt::vec::Vec::<Uvec4>),
          TypeIvec2(wit_bindgen::rt::vec::Vec::<Ivec2>),
          TypeIvec3(wit_bindgen::rt::vec::Vec::<Ivec3>),
          TypeIvec4(wit_bindgen::rt::vec::Vec::<Ivec4>),
          TypeDuration(wit_bindgen::rt::vec::Vec::<Duration>),
          TypeProceduralMeshHandle(wit_bindgen::rt::vec::Vec::<ProceduralMeshHandle>),
          TypeProceduralTextureHandle(wit_bindgen::rt::vec::Vec::<ProceduralTextureHandle>),
          TypeProceduralSamplerHandle(wit_bindgen::rt::vec::Vec::<ProceduralSamplerHandle>),
          TypeProceduralMaterialHandle(wit_bindgen::rt::vec::Vec::<ProceduralMaterialHandle>),
        }
        impl ::core::fmt::Debug for VecValue {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              VecValue::TypeBool(e) => {
                f.debug_tuple("VecValue::TypeBool").field(e).finish()
              }
              VecValue::TypeEntityId(e) => {
                f.debug_tuple("VecValue::TypeEntityId").field(e).finish()
              }
              VecValue::TypeF32(e) => {
                f.debug_tuple("VecValue::TypeF32").field(e).finish()
              }
              VecValue::TypeF64(e) => {
                f.debug_tuple("VecValue::TypeF64").field(e).finish()
              }
              VecValue::TypeMat4(e) => {
                f.debug_tuple("VecValue::TypeMat4").field(e).finish()
              }
              VecValue::TypeQuat(e) => {
                f.debug_tuple("VecValue::TypeQuat").field(e).finish()
              }
              VecValue::TypeString(e) => {
                f.debug_tuple("VecValue::TypeString").field(e).finish()
              }
              VecValue::TypeU8(e) => {
                f.debug_tuple("VecValue::TypeU8").field(e).finish()
              }
              VecValue::TypeU16(e) => {
                f.debug_tuple("VecValue::TypeU16").field(e).finish()
              }
              VecValue::TypeU32(e) => {
                f.debug_tuple("VecValue::TypeU32").field(e).finish()
              }
              VecValue::TypeU64(e) => {
                f.debug_tuple("VecValue::TypeU64").field(e).finish()
              }
              VecValue::TypeI8(e) => {
                f.debug_tuple("VecValue::TypeI8").field(e).finish()
              }
              VecValue::TypeI16(e) => {
                f.debug_tuple("VecValue::TypeI16").field(e).finish()
              }
              VecValue::TypeI32(e) => {
                f.debug_tuple("VecValue::TypeI32").field(e).finish()
              }
              VecValue::TypeI64(e) => {
                f.debug_tuple("VecValue::TypeI64").field(e).finish()
              }
              VecValue::TypeVec2(e) => {
                f.debug_tuple("VecValue::TypeVec2").field(e).finish()
              }
              VecValue::TypeVec3(e) => {
                f.debug_tuple("VecValue::TypeVec3").field(e).finish()
              }
              VecValue::TypeVec4(e) => {
                f.debug_tuple("VecValue::TypeVec4").field(e).finish()
              }
              VecValue::TypeUvec2(e) => {
                f.debug_tuple("VecValue::TypeUvec2").field(e).finish()
              }
              VecValue::TypeUvec3(e) => {
                f.debug_tuple("VecValue::TypeUvec3").field(e).finish()
              }
              VecValue::TypeUvec4(e) => {
                f.debug_tuple("VecValue::TypeUvec4").field(e).finish()
              }
              VecValue::TypeIvec2(e) => {
                f.debug_tuple("VecValue::TypeIvec2").field(e).finish()
              }
              VecValue::TypeIvec3(e) => {
                f.debug_tuple("VecValue::TypeIvec3").field(e).finish()
              }
              VecValue::TypeIvec4(e) => {
                f.debug_tuple("VecValue::TypeIvec4").field(e).finish()
              }
              VecValue::TypeDuration(e) => {
                f.debug_tuple("VecValue::TypeDuration").field(e).finish()
              }
              VecValue::TypeProceduralMeshHandle(e) => {
                f.debug_tuple("VecValue::TypeProceduralMeshHandle").field(e).finish()
              }
              VecValue::TypeProceduralTextureHandle(e) => {
                f.debug_tuple("VecValue::TypeProceduralTextureHandle").field(e).finish()
              }
              VecValue::TypeProceduralSamplerHandle(e) => {
                f.debug_tuple("VecValue::TypeProceduralSamplerHandle").field(e).finish()
              }
              VecValue::TypeProceduralMaterialHandle(e) => {
                f.debug_tuple("VecValue::TypeProceduralMaterialHandle").field(e).finish()
              }
            }
          }
        }
        #[derive(Clone)]
        pub enum OptionValue{
          TypeBool(Option<bool>),
          TypeEntityId(Option<EntityId>),
          TypeF32(Option<f32>),
          TypeF64(Option<f64>),
          TypeMat4(Option<Mat4>),
          TypeQuat(Option<Quat>),
          TypeString(Option<wit_bindgen::rt::string::String>),
          TypeU8(Option<u8>),
          TypeU16(Option<u16>),
          TypeU32(Option<u32>),
          TypeU64(Option<u64>),
          TypeI8(Option<i8>),
          TypeI16(Option<i16>),
          TypeI32(Option<i32>),
          TypeI64(Option<i64>),
          TypeVec2(Option<Vec2>),
          TypeVec3(Option<Vec3>),
          TypeVec4(Option<Vec4>),
          TypeUvec2(Option<Uvec2>),
          TypeUvec3(Option<Uvec3>),
          TypeUvec4(Option<Uvec4>),
          TypeIvec2(Option<Ivec2>),
          TypeIvec3(Option<Ivec3>),
          TypeIvec4(Option<Ivec4>),
          TypeDuration(Option<Duration>),
          TypeProceduralMeshHandle(Option<ProceduralMeshHandle>),
          TypeProceduralTextureHandle(Option<ProceduralTextureHandle>),
          TypeProceduralSamplerHandle(Option<ProceduralSamplerHandle>),
          TypeProceduralMaterialHandle(Option<ProceduralMaterialHandle>),
        }
        impl ::core::fmt::Debug for OptionValue {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              OptionValue::TypeBool(e) => {
                f.debug_tuple("OptionValue::TypeBool").field(e).finish()
              }
              OptionValue::TypeEntityId(e) => {
                f.debug_tuple("OptionValue::TypeEntityId").field(e).finish()
              }
              OptionValue::TypeF32(e) => {
                f.debug_tuple("OptionValue::TypeF32").field(e).finish()
              }
              OptionValue::TypeF64(e) => {
                f.debug_tuple("OptionValue::TypeF64").field(e).finish()
              }
              OptionValue::TypeMat4(e) => {
                f.debug_tuple("OptionValue::TypeMat4").field(e).finish()
              }
              OptionValue::TypeQuat(e) => {
                f.debug_tuple("OptionValue::TypeQuat").field(e).finish()
              }
              OptionValue::TypeString(e) => {
                f.debug_tuple("OptionValue::TypeString").field(e).finish()
              }
              OptionValue::TypeU8(e) => {
                f.debug_tuple("OptionValue::TypeU8").field(e).finish()
              }
              OptionValue::TypeU16(e) => {
                f.debug_tuple("OptionValue::TypeU16").field(e).finish()
              }
              OptionValue::TypeU32(e) => {
                f.debug_tuple("OptionValue::TypeU32").field(e).finish()
              }
              OptionValue::TypeU64(e) => {
                f.debug_tuple("OptionValue::TypeU64").field(e).finish()
              }
              OptionValue::TypeI8(e) => {
                f.debug_tuple("OptionValue::TypeI8").field(e).finish()
              }
              OptionValue::TypeI16(e) => {
                f.debug_tuple("OptionValue::TypeI16").field(e).finish()
              }
              OptionValue::TypeI32(e) => {
                f.debug_tuple("OptionValue::TypeI32").field(e).finish()
              }
              OptionValue::TypeI64(e) => {
                f.debug_tuple("OptionValue::TypeI64").field(e).finish()
              }
              OptionValue::TypeVec2(e) => {
                f.debug_tuple("OptionValue::TypeVec2").field(e).finish()
              }
              OptionValue::TypeVec3(e) => {
                f.debug_tuple("OptionValue::TypeVec3").field(e).finish()
              }
              OptionValue::TypeVec4(e) => {
                f.debug_tuple("OptionValue::TypeVec4").field(e).finish()
              }
              OptionValue::TypeUvec2(e) => {
                f.debug_tuple("OptionValue::TypeUvec2").field(e).finish()
              }
              OptionValue::TypeUvec3(e) => {
                f.debug_tuple("OptionValue::TypeUvec3").field(e).finish()
              }
              OptionValue::TypeUvec4(e) => {
                f.debug_tuple("OptionValue::TypeUvec4").field(e).finish()
              }
              OptionValue::TypeIvec2(e) => {
                f.debug_tuple("OptionValue::TypeIvec2").field(e).finish()
              }
              OptionValue::TypeIvec3(e) => {
                f.debug_tuple("OptionValue::TypeIvec3").field(e).finish()
              }
              OptionValue::TypeIvec4(e) => {
                f.debug_tuple("OptionValue::TypeIvec4").field(e).finish()
              }
              OptionValue::TypeDuration(e) => {
                f.debug_tuple("OptionValue::TypeDuration").field(e).finish()
              }
              OptionValue::TypeProceduralMeshHandle(e) => {
                f.debug_tuple("OptionValue::TypeProceduralMeshHandle").field(e).finish()
              }
              OptionValue::TypeProceduralTextureHandle(e) => {
                f.debug_tuple("OptionValue::TypeProceduralTextureHandle").field(e).finish()
              }
              OptionValue::TypeProceduralSamplerHandle(e) => {
                f.debug_tuple("OptionValue::TypeProceduralSamplerHandle").field(e).finish()
              }
              OptionValue::TypeProceduralMaterialHandle(e) => {
                f.debug_tuple("OptionValue::TypeProceduralMaterialHandle").field(e).finish()
              }
            }
          }
        }
        #[derive(Clone)]
        pub enum Value{
          TypeBool(bool),
          TypeEntityId(EntityId),
          TypeF32(f32),
          TypeF64(f64),
          TypeMat4(Mat4),
          TypeQuat(Quat),
          TypeString(wit_bindgen::rt::string::String),
          TypeU8(u8),
          TypeU16(u16),
          TypeU32(u32),
          TypeU64(u64),
          TypeI8(i8),
          TypeI16(i16),
          TypeI32(i32),
          TypeI64(i64),
          TypeVec2(Vec2),
          TypeVec3(Vec3),
          TypeVec4(Vec4),
          TypeUvec2(Uvec2),
          TypeUvec3(Uvec3),
          TypeUvec4(Uvec4),
          TypeIvec2(Ivec2),
          TypeIvec3(Ivec3),
          TypeIvec4(Ivec4),
          TypeDuration(Duration),
          TypeProceduralMeshHandle(ProceduralMeshHandle),
          TypeProceduralTextureHandle(ProceduralTextureHandle),
          TypeProceduralSamplerHandle(ProceduralSamplerHandle),
          TypeProceduralMaterialHandle(ProceduralMaterialHandle),
          TypeVec(VecValue),
          TypeOption(OptionValue),
        }
        impl ::core::fmt::Debug for Value {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              Value::TypeBool(e) => {
                f.debug_tuple("Value::TypeBool").field(e).finish()
              }
              Value::TypeEntityId(e) => {
                f.debug_tuple("Value::TypeEntityId").field(e).finish()
              }
              Value::TypeF32(e) => {
                f.debug_tuple("Value::TypeF32").field(e).finish()
              }
              Value::TypeF64(e) => {
                f.debug_tuple("Value::TypeF64").field(e).finish()
              }
              Value::TypeMat4(e) => {
                f.debug_tuple("Value::TypeMat4").field(e).finish()
              }
              Value::TypeQuat(e) => {
                f.debug_tuple("Value::TypeQuat").field(e).finish()
              }
              Value::TypeString(e) => {
                f.debug_tuple("Value::TypeString").field(e).finish()
              }
              Value::TypeU8(e) => {
                f.debug_tuple("Value::TypeU8").field(e).finish()
              }
              Value::TypeU16(e) => {
                f.debug_tuple("Value::TypeU16").field(e).finish()
              }
              Value::TypeU32(e) => {
                f.debug_tuple("Value::TypeU32").field(e).finish()
              }
              Value::TypeU64(e) => {
                f.debug_tuple("Value::TypeU64").field(e).finish()
              }
              Value::TypeI8(e) => {
                f.debug_tuple("Value::TypeI8").field(e).finish()
              }
              Value::TypeI16(e) => {
                f.debug_tuple("Value::TypeI16").field(e).finish()
              }
              Value::TypeI32(e) => {
                f.debug_tuple("Value::TypeI32").field(e).finish()
              }
              Value::TypeI64(e) => {
                f.debug_tuple("Value::TypeI64").field(e).finish()
              }
              Value::TypeVec2(e) => {
                f.debug_tuple("Value::TypeVec2").field(e).finish()
              }
              Value::TypeVec3(e) => {
                f.debug_tuple("Value::TypeVec3").field(e).finish()
              }
              Value::TypeVec4(e) => {
                f.debug_tuple("Value::TypeVec4").field(e).finish()
              }
              Value::TypeUvec2(e) => {
                f.debug_tuple("Value::TypeUvec2").field(e).finish()
              }
              Value::TypeUvec3(e) => {
                f.debug_tuple("Value::TypeUvec3").field(e).finish()
              }
              Value::TypeUvec4(e) => {
                f.debug_tuple("Value::TypeUvec4").field(e).finish()
              }
              Value::TypeIvec2(e) => {
                f.debug_tuple("Value::TypeIvec2").field(e).finish()
              }
              Value::TypeIvec3(e) => {
                f.debug_tuple("Value::TypeIvec3").field(e).finish()
              }
              Value::TypeIvec4(e) => {
                f.debug_tuple("Value::TypeIvec4").field(e).finish()
              }
              Value::TypeDuration(e) => {
                f.debug_tuple("Value::TypeDuration").field(e).finish()
              }
              Value::TypeProceduralMeshHandle(e) => {
                f.debug_tuple("Value::TypeProceduralMeshHandle").field(e).finish()
              }
              Value::TypeProceduralTextureHandle(e) => {
                f.debug_tuple("Value::TypeProceduralTextureHandle").field(e).finish()
              }
              Value::TypeProceduralSamplerHandle(e) => {
                f.debug_tuple("Value::TypeProceduralSamplerHandle").field(e).finish()
              }
              Value::TypeProceduralMaterialHandle(e) => {
                f.debug_tuple("Value::TypeProceduralMaterialHandle").field(e).finish()
              }
              Value::TypeVec(e) => {
                f.debug_tuple("Value::TypeVec").field(e).finish()
              }
              Value::TypeOption(e) => {
                f.debug_tuple("Value::TypeOption").field(e).finish()
              }
            }
          }
        }
        pub type Entity = wit_bindgen::rt::vec::Vec::<(u32,Value,)>;
        #[derive(Clone)]
        pub struct QueryBuild {
          pub components: wit_bindgen::rt::vec::Vec::<u32>,
          pub includes: wit_bindgen::rt::vec::Vec::<u32>,
          pub excludes: wit_bindgen::rt::vec::Vec::<u32>,
          pub changed: wit_bindgen::rt::vec::Vec::<u32>,
        }
        impl ::core::fmt::Debug for QueryBuild {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("QueryBuild").field("components", &self.components).field("includes", &self.includes).field("excludes", &self.excludes).field("changed", &self.changed).finish()
          }
        }
        #[repr(u8)]
        #[derive(Clone, Copy, PartialEq, Eq)]
        pub enum QueryEvent {
          Frame,
          Spawn,
          Despawn,
        }
        impl ::core::fmt::Debug for QueryEvent {
          fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            match self {
              QueryEvent::Frame => {
                f.debug_tuple("QueryEvent::Frame").finish()
              }
              QueryEvent::Spawn => {
                f.debug_tuple("QueryEvent::Spawn").finish()
              }
              QueryEvent::Despawn => {
                f.debug_tuple("QueryEvent::Despawn").finish()
              }
            }
          }
        }
        #[allow(clippy::all)]
        pub fn get_index(id: &str,) -> Option<u32>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 8]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = id;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/component")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "get-index")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_get-index")]
              fn wit_import(
              _: i32, _: i32, _: i32, );
            }
            wit_import(ptr0, len0, ptr1);
            match i32::from(*((ptr1 + 0) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 4) as *const i32) as u32),
              #[cfg(not(debug_assertions))]
              _ => ::core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }
          }
        }
        #[allow(clippy::all)]
        pub fn get_id(index: u32,) -> Option<wit_bindgen::rt::string::String>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/component")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "get-id")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_get-id")]
              fn wit_import(
              _: i32, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i32(index), ptr0);
            match i32::from(*((ptr0 + 0) as *const u8)) {
              0 => None,
              1 => Some({
                let len1 = *((ptr0 + 8) as *const i32) as usize;
                
                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr0 + 4) as *const i32) as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr0 + 4) as *const i32) as *mut _, len1, len1)).unwrap()}}
              }),
              #[cfg(not(debug_assertions))]
              _ => ::core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }
          }
        }
        #[allow(clippy::all)]
        pub fn get_component(entity: EntityId,index: u32,) -> Option<Value>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 96]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/component")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "get-component")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_get-component")]
              fn wit_import(
              _: i64, _: i64, _: i32, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index), ptr1);
            match i32::from(*((ptr1 + 0) as *const u8)) {
              0 => None,
              1 => Some({{match i32::from(*((ptr1 + 8) as *const u8)) {
                0 => Value::TypeBool({
                  #[cfg(not(debug_assertions))]
                  { ::core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 16) as *const u8)) as u8) }
                  #[cfg(debug_assertions)]
                  {
                    match i32::from(*((ptr1 + 16) as *const u8)) {
                      0 => false,
                      1 => true,
                      _ => panic!("invalid bool discriminant"),
                    }
                  }
                }),
                1 => Value::TypeEntityId(super::super::super::ambient::bindings::types::EntityId{id0:*((ptr1 + 16) as *const i64) as u64, id1:*((ptr1 + 24) as *const i64) as u64, }),
                2 => Value::TypeF32(*((ptr1 + 16) as *const f32)),
                3 => Value::TypeF64(*((ptr1 + 16) as *const f64)),
                4 => Value::TypeMat4(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 32) as *const f32), y:*((ptr1 + 36) as *const f32), z:*((ptr1 + 40) as *const f32), w:*((ptr1 + 44) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 48) as *const f32), y:*((ptr1 + 52) as *const f32), z:*((ptr1 + 56) as *const f32), w:*((ptr1 + 60) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 64) as *const f32), y:*((ptr1 + 68) as *const f32), z:*((ptr1 + 72) as *const f32), w:*((ptr1 + 76) as *const f32), }, }),
                5 => Value::TypeQuat(super::super::super::ambient::bindings::types::Quat{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }),
                6 => Value::TypeString({
                  let len2 = *((ptr1 + 20) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 16) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 16) as *const i32) as *mut _, len2, len2)).unwrap()}}
                }),
                7 => Value::TypeU8(i32::from(*((ptr1 + 16) as *const u8)) as u8),
                8 => Value::TypeU16(i32::from(*((ptr1 + 16) as *const u16)) as u16),
                9 => Value::TypeU32(*((ptr1 + 16) as *const i32) as u32),
                10 => Value::TypeU64(*((ptr1 + 16) as *const i64) as u64),
                11 => Value::TypeI8(i32::from(*((ptr1 + 16) as *const i8)) as i8),
                12 => Value::TypeI16(i32::from(*((ptr1 + 16) as *const i16)) as i16),
                13 => Value::TypeI32(*((ptr1 + 16) as *const i32)),
                14 => Value::TypeI64(*((ptr1 + 16) as *const i64)),
                15 => Value::TypeVec2(super::super::super::ambient::bindings::types::Vec2{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), }),
                16 => Value::TypeVec3(super::super::super::ambient::bindings::types::Vec3{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), }),
                17 => Value::TypeVec4(super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }),
                18 => Value::TypeUvec2(super::super::super::ambient::bindings::types::Uvec2{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, }),
                19 => Value::TypeUvec3(super::super::super::ambient::bindings::types::Uvec3{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, z:*((ptr1 + 24) as *const i32) as u32, }),
                20 => Value::TypeUvec4(super::super::super::ambient::bindings::types::Uvec4{x:*((ptr1 + 16) as *const i32) as u32, y:*((ptr1 + 20) as *const i32) as u32, z:*((ptr1 + 24) as *const i32) as u32, w:*((ptr1 + 28) as *const i32) as u32, }),
                21 => Value::TypeIvec2(super::super::super::ambient::bindings::types::Ivec2{x:*((ptr1 + 16) as *const i32), y:*((ptr1 + 20) as *const i32), }),
                22 => Value::TypeIvec3(super::super::super::ambient::bindings::types::Ivec3{x:*((ptr1 + 16) as *const i32), y:*((ptr1 + 20) as *const i32), z:*((ptr1 + 24) as *const i32), }),
                23 => Value::TypeIvec4(super::super::super::ambient::bindings::types::Ivec4{x:*((ptr1 + 16) as *const i32), y:*((ptr1 + 20) as *const i32), z:*((ptr1 + 24) as *const i32), w:*((ptr1 + 28) as *const i32), }),
                24 => Value::TypeDuration(super::super::super::ambient::bindings::types::Duration{seconds:*((ptr1 + 16) as *const i64) as u64, nanoseconds:*((ptr1 + 24) as *const i32) as u32, }),
                25 => Value::TypeProceduralMeshHandle(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
                26 => Value::TypeProceduralTextureHandle(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
                27 => Value::TypeProceduralSamplerHandle(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
                28 => Value::TypeProceduralMaterialHandle(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((ptr1 + 16) as *const i64) as u64, *((ptr1 + 24) as *const i64) as u64), }),
                29 => Value::TypeVec({{match i32::from(*((ptr1 + 16) as *const u8)) {
                  0 => VecValue::TypeBool({
                    let base3 = *((ptr1 + 20) as *const i32);
                    let len3 = *((ptr1 + 24) as *const i32);
                    let mut result3 = Vec::with_capacity(len3 as usize);
                    for i in 0..len3 {
                      let base = base3 + i *1;
                      result3.push({
                        #[cfg(not(debug_assertions))]
                        { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                        #[cfg(debug_assertions)]
                        {
                          match i32::from(*((base + 0) as *const u8)) {
                            0 => false,
                            1 => true,
                            _ => panic!("invalid bool discriminant"),
                          }
                        }
                      });
                    }
                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                    
                    result3
                  }),
                  1 => VecValue::TypeEntityId({
                    let len4 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len4, len4)
                  }),
                  2 => VecValue::TypeF32({
                    let len5 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len5, len5)
                  }),
                  3 => VecValue::TypeF64({
                    let len6 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len6, len6)
                  }),
                  4 => VecValue::TypeMat4({
                    let len7 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len7, len7)
                  }),
                  5 => VecValue::TypeQuat({
                    let len8 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len8, len8)
                  }),
                  6 => VecValue::TypeString({
                    let base10 = *((ptr1 + 20) as *const i32);
                    let len10 = *((ptr1 + 24) as *const i32);
                    let mut result10 = Vec::with_capacity(len10 as usize);
                    for i in 0..len10 {
                      let base = base10 + i *8;
                      result10.push({
                        let len9 = *((base + 4) as *const i32) as usize;
                        
                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len9, len9))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len9, len9)).unwrap()}}
                      });
                    }
                    wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                    
                    result10
                  }),
                  7 => VecValue::TypeU8({
                    let len11 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len11, len11)
                  }),
                  8 => VecValue::TypeU16({
                    let len12 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len12, len12)
                  }),
                  9 => VecValue::TypeU32({
                    let len13 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len13, len13)
                  }),
                  10 => VecValue::TypeU64({
                    let len14 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len14, len14)
                  }),
                  11 => VecValue::TypeI8({
                    let len15 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len15, len15)
                  }),
                  12 => VecValue::TypeI16({
                    let len16 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len16, len16)
                  }),
                  13 => VecValue::TypeI32({
                    let len17 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len17, len17)
                  }),
                  14 => VecValue::TypeI64({
                    let len18 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len18, len18)
                  }),
                  15 => VecValue::TypeVec2({
                    let len19 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len19, len19)
                  }),
                  16 => VecValue::TypeVec3({
                    let len20 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len20, len20)
                  }),
                  17 => VecValue::TypeVec4({
                    let len21 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len21, len21)
                  }),
                  18 => VecValue::TypeUvec2({
                    let len22 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len22, len22)
                  }),
                  19 => VecValue::TypeUvec3({
                    let len23 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len23, len23)
                  }),
                  20 => VecValue::TypeUvec4({
                    let len24 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len24, len24)
                  }),
                  21 => VecValue::TypeIvec2({
                    let len25 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len25, len25)
                  }),
                  22 => VecValue::TypeIvec3({
                    let len26 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len26, len26)
                  }),
                  23 => VecValue::TypeIvec4({
                    let len27 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len27, len27)
                  }),
                  24 => VecValue::TypeDuration({
                    let len28 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len28, len28)
                  }),
                  25 => VecValue::TypeProceduralMeshHandle({
                    let len29 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len29, len29)
                  }),
                  26 => VecValue::TypeProceduralTextureHandle({
                    let len30 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len30, len30)
                  }),
                  27 => VecValue::TypeProceduralSamplerHandle({
                    let len31 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len31, len31)
                  }),
                  #[cfg(debug_assertions)]28 => VecValue::TypeProceduralMaterialHandle({
                    let len32 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len32, len32)
                  }),
                  #[cfg(not(debug_assertions))]_ => VecValue::TypeProceduralMaterialHandle({
                    let len32 = *((ptr1 + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len32, len32)
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]30 => Value::TypeOption({{match i32::from(*((ptr1 + 16) as *const u8)) {
                  0 => OptionValue::TypeBool(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((ptr1 + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeEntityId(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((ptr1 + 32) as *const i64) as u64, id1:*((ptr1 + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeF32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeMat4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 44) as *const f32), y:*((ptr1 + 48) as *const f32), z:*((ptr1 + 52) as *const f32), w:*((ptr1 + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 60) as *const f32), y:*((ptr1 + 64) as *const f32), z:*((ptr1 + 68) as *const f32), w:*((ptr1 + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 76) as *const f32), y:*((ptr1 + 80) as *const f32), z:*((ptr1 + 84) as *const f32), w:*((ptr1 + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeQuat(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeString(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len33 = *((ptr1 + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len33, len33))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len33, len33)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeU8(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU16(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeI8(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI16(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeVec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeUvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, w:*((ptr1 + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeIvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), z:*((ptr1 + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), z:*((ptr1 + 36) as *const i32), w:*((ptr1 + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeDuration(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((ptr1 + 32) as *const i64) as u64, nanoseconds:*((ptr1 + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]28 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(not(debug_assertions))]_ => Value::TypeOption({{match i32::from(*((ptr1 + 16) as *const u8)) {
                  0 => OptionValue::TypeBool(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((ptr1 + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeEntityId(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((ptr1 + 32) as *const i64) as u64, id1:*((ptr1 + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeF32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeMat4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 44) as *const f32), y:*((ptr1 + 48) as *const f32), z:*((ptr1 + 52) as *const f32), w:*((ptr1 + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 60) as *const f32), y:*((ptr1 + 64) as *const f32), z:*((ptr1 + 68) as *const f32), w:*((ptr1 + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 76) as *const f32), y:*((ptr1 + 80) as *const f32), z:*((ptr1 + 84) as *const f32), w:*((ptr1 + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeQuat(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeString(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len33 = *((ptr1 + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len33, len33))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len33, len33)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeU8(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU16(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeI8(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI16(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((ptr1 + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI32(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI64(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((ptr1 + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeVec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeUvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((ptr1 + 28) as *const i32) as u32, y:*((ptr1 + 32) as *const i32) as u32, z:*((ptr1 + 36) as *const i32) as u32, w:*((ptr1 + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeIvec2(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec3(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), z:*((ptr1 + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec4(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((ptr1 + 28) as *const i32), y:*((ptr1 + 32) as *const i32), z:*((ptr1 + 36) as *const i32), w:*((ptr1 + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeDuration(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((ptr1 + 32) as *const i64) as u64, nanoseconds:*((ptr1 + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]28 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((ptr1 + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((ptr1 + 32) as *const i64) as u64, *((ptr1 + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}),
              #[cfg(not(debug_assertions))]
              _ => ::core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }
          }
        }
        #[allow(clippy::all)]
        pub fn get_components(entity: EntityId,indices: &[u32],) -> Entity{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 8]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
            let vec1 = indices;
            let ptr1 = vec1.as_ptr() as i32;
            let len1 = vec1.len() as i32;
            let ptr2 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/component")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "get-components")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_get-components")]
              fn wit_import(
              _: i64, _: i64, _: i32, _: i32, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1, len1, ptr2);
            let base35 = *((ptr2 + 0) as *const i32);
            let len35 = *((ptr2 + 4) as *const i32);
            let mut result35 = Vec::with_capacity(len35 as usize);
            for i in 0..len35 {
              let base = base35 + i *96;
              result35.push((*((base + 0) as *const i32) as u32, {{match i32::from(*((base + 8) as *const u8)) {
                0 => Value::TypeBool({
                  #[cfg(not(debug_assertions))]
                  { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 16) as *const u8)) as u8) }
                  #[cfg(debug_assertions)]
                  {
                    match i32::from(*((base + 16) as *const u8)) {
                      0 => false,
                      1 => true,
                      _ => panic!("invalid bool discriminant"),
                    }
                  }
                }),
                1 => Value::TypeEntityId(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 16) as *const i64) as u64, id1:*((base + 24) as *const i64) as u64, }),
                2 => Value::TypeF32(*((base + 16) as *const f32)),
                3 => Value::TypeF64(*((base + 16) as *const f64)),
                4 => Value::TypeMat4(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 32) as *const f32), y:*((base + 36) as *const f32), z:*((base + 40) as *const f32), w:*((base + 44) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 48) as *const f32), y:*((base + 52) as *const f32), z:*((base + 56) as *const f32), w:*((base + 60) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 64) as *const f32), y:*((base + 68) as *const f32), z:*((base + 72) as *const f32), w:*((base + 76) as *const f32), }, }),
                5 => Value::TypeQuat(super::super::super::ambient::bindings::types::Quat{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                6 => Value::TypeString({
                  let len3 = *((base + 20) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len3, len3))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len3, len3)).unwrap()}}
                }),
                7 => Value::TypeU8(i32::from(*((base + 16) as *const u8)) as u8),
                8 => Value::TypeU16(i32::from(*((base + 16) as *const u16)) as u16),
                9 => Value::TypeU32(*((base + 16) as *const i32) as u32),
                10 => Value::TypeU64(*((base + 16) as *const i64) as u64),
                11 => Value::TypeI8(i32::from(*((base + 16) as *const i8)) as i8),
                12 => Value::TypeI16(i32::from(*((base + 16) as *const i16)) as i16),
                13 => Value::TypeI32(*((base + 16) as *const i32)),
                14 => Value::TypeI64(*((base + 16) as *const i64)),
                15 => Value::TypeVec2(super::super::super::ambient::bindings::types::Vec2{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), }),
                16 => Value::TypeVec3(super::super::super::ambient::bindings::types::Vec3{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), }),
                17 => Value::TypeVec4(super::super::super::ambient::bindings::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                18 => Value::TypeUvec2(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, }),
                19 => Value::TypeUvec3(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, }),
                20 => Value::TypeUvec4(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, w:*((base + 28) as *const i32) as u32, }),
                21 => Value::TypeIvec2(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), }),
                22 => Value::TypeIvec3(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), z:*((base + 24) as *const i32), }),
                23 => Value::TypeIvec4(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), z:*((base + 24) as *const i32), w:*((base + 28) as *const i32), }),
                24 => Value::TypeDuration(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 16) as *const i64) as u64, nanoseconds:*((base + 24) as *const i32) as u32, }),
                25 => Value::TypeProceduralMeshHandle(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                26 => Value::TypeProceduralTextureHandle(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                27 => Value::TypeProceduralSamplerHandle(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                28 => Value::TypeProceduralMaterialHandle(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                29 => Value::TypeVec({{match i32::from(*((base + 16) as *const u8)) {
                  0 => VecValue::TypeBool({
                    let base4 = *((base + 20) as *const i32);
                    let len4 = *((base + 24) as *const i32);
                    let mut result4 = Vec::with_capacity(len4 as usize);
                    for i in 0..len4 {
                      let base = base4 + i *1;
                      result4.push({
                        #[cfg(not(debug_assertions))]
                        { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                        #[cfg(debug_assertions)]
                        {
                          match i32::from(*((base + 0) as *const u8)) {
                            0 => false,
                            1 => true,
                            _ => panic!("invalid bool discriminant"),
                          }
                        }
                      });
                    }
                    wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
                    
                    result4
                  }),
                  1 => VecValue::TypeEntityId({
                    let len5 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len5, len5)
                  }),
                  2 => VecValue::TypeF32({
                    let len6 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len6, len6)
                  }),
                  3 => VecValue::TypeF64({
                    let len7 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len7, len7)
                  }),
                  4 => VecValue::TypeMat4({
                    let len8 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len8, len8)
                  }),
                  5 => VecValue::TypeQuat({
                    let len9 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len9, len9)
                  }),
                  6 => VecValue::TypeString({
                    let base11 = *((base + 20) as *const i32);
                    let len11 = *((base + 24) as *const i32);
                    let mut result11 = Vec::with_capacity(len11 as usize);
                    for i in 0..len11 {
                      let base = base11 + i *8;
                      result11.push({
                        let len10 = *((base + 4) as *const i32) as usize;
                        
                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len10, len10)).unwrap()}}
                      });
                    }
                    wit_bindgen::rt::dealloc(base11, (len11 as usize) * 8, 4);
                    
                    result11
                  }),
                  7 => VecValue::TypeU8({
                    let len12 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len12, len12)
                  }),
                  8 => VecValue::TypeU16({
                    let len13 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len13, len13)
                  }),
                  9 => VecValue::TypeU32({
                    let len14 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len14, len14)
                  }),
                  10 => VecValue::TypeU64({
                    let len15 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len15, len15)
                  }),
                  11 => VecValue::TypeI8({
                    let len16 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len16, len16)
                  }),
                  12 => VecValue::TypeI16({
                    let len17 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len17, len17)
                  }),
                  13 => VecValue::TypeI32({
                    let len18 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len18, len18)
                  }),
                  14 => VecValue::TypeI64({
                    let len19 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len19, len19)
                  }),
                  15 => VecValue::TypeVec2({
                    let len20 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len20, len20)
                  }),
                  16 => VecValue::TypeVec3({
                    let len21 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len21, len21)
                  }),
                  17 => VecValue::TypeVec4({
                    let len22 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len22, len22)
                  }),
                  18 => VecValue::TypeUvec2({
                    let len23 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len23, len23)
                  }),
                  19 => VecValue::TypeUvec3({
                    let len24 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len24, len24)
                  }),
                  20 => VecValue::TypeUvec4({
                    let len25 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len25, len25)
                  }),
                  21 => VecValue::TypeIvec2({
                    let len26 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len26, len26)
                  }),
                  22 => VecValue::TypeIvec3({
                    let len27 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len27, len27)
                  }),
                  23 => VecValue::TypeIvec4({
                    let len28 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len28, len28)
                  }),
                  24 => VecValue::TypeDuration({
                    let len29 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len29, len29)
                  }),
                  25 => VecValue::TypeProceduralMeshHandle({
                    let len30 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len30, len30)
                  }),
                  26 => VecValue::TypeProceduralTextureHandle({
                    let len31 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len31, len31)
                  }),
                  27 => VecValue::TypeProceduralSamplerHandle({
                    let len32 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len32, len32)
                  }),
                  #[cfg(debug_assertions)]28 => VecValue::TypeProceduralMaterialHandle({
                    let len33 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len33, len33)
                  }),
                  #[cfg(not(debug_assertions))]_ => VecValue::TypeProceduralMaterialHandle({
                    let len33 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len33, len33)
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]30 => Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                  0 => OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((base + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len34 = *((base + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeI8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeIvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), w:*((base + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeDuration(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 32) as *const i64) as u64, nanoseconds:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]28 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(not(debug_assertions))]_ => Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                  0 => OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((base + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len34 = *((base + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len34, len34)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeI8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeIvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), w:*((base + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeDuration(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 32) as *const i64) as u64, nanoseconds:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]28 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}));
            }
            wit_bindgen::rt::dealloc(base35, (len35 as usize) * 96, 8);
            result35
          }
        }
        #[allow(clippy::all)]
        pub fn get_all_components(entity: EntityId,) -> Entity{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 8]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[link(wasm_import_module = "ambient:bindings/component")]
            extern "C" {
              #[cfg_attr(target_arch = "wasm32", link_name = "get-all-components")]
              #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_get-all-components")]
              fn wit_import(
              _: i64, _: i64, _: i32, );
            }
            wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1);
            let base34 = *((ptr1 + 0) as *const i32);
            let len34 = *((ptr1 + 4) as *const i32);
            let mut result34 = Vec::with_capacity(len34 as usize);
            for i in 0..len34 {
              let base = base34 + i *96;
              result34.push((*((base + 0) as *const i32) as u32, {{match i32::from(*((base + 8) as *const u8)) {
                0 => Value::TypeBool({
                  #[cfg(not(debug_assertions))]
                  { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 16) as *const u8)) as u8) }
                  #[cfg(debug_assertions)]
                  {
                    match i32::from(*((base + 16) as *const u8)) {
                      0 => false,
                      1 => true,
                      _ => panic!("invalid bool discriminant"),
                    }
                  }
                }),
                1 => Value::TypeEntityId(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 16) as *const i64) as u64, id1:*((base + 24) as *const i64) as u64, }),
                2 => Value::TypeF32(*((base + 16) as *const f32)),
                3 => Value::TypeF64(*((base + 16) as *const f64)),
                4 => Value::TypeMat4(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 32) as *const f32), y:*((base + 36) as *const f32), z:*((base + 40) as *const f32), w:*((base + 44) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 48) as *const f32), y:*((base + 52) as *const f32), z:*((base + 56) as *const f32), w:*((base + 60) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 64) as *const f32), y:*((base + 68) as *const f32), z:*((base + 72) as *const f32), w:*((base + 76) as *const f32), }, }),
                5 => Value::TypeQuat(super::super::super::ambient::bindings::types::Quat{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                6 => Value::TypeString({
                  let len2 = *((base + 20) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len2, len2)).unwrap()}}
                }),
                7 => Value::TypeU8(i32::from(*((base + 16) as *const u8)) as u8),
                8 => Value::TypeU16(i32::from(*((base + 16) as *const u16)) as u16),
                9 => Value::TypeU32(*((base + 16) as *const i32) as u32),
                10 => Value::TypeU64(*((base + 16) as *const i64) as u64),
                11 => Value::TypeI8(i32::from(*((base + 16) as *const i8)) as i8),
                12 => Value::TypeI16(i32::from(*((base + 16) as *const i16)) as i16),
                13 => Value::TypeI32(*((base + 16) as *const i32)),
                14 => Value::TypeI64(*((base + 16) as *const i64)),
                15 => Value::TypeVec2(super::super::super::ambient::bindings::types::Vec2{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), }),
                16 => Value::TypeVec3(super::super::super::ambient::bindings::types::Vec3{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), }),
                17 => Value::TypeVec4(super::super::super::ambient::bindings::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                18 => Value::TypeUvec2(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, }),
                19 => Value::TypeUvec3(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, }),
                20 => Value::TypeUvec4(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 16) as *const i32) as u32, y:*((base + 20) as *const i32) as u32, z:*((base + 24) as *const i32) as u32, w:*((base + 28) as *const i32) as u32, }),
                21 => Value::TypeIvec2(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), }),
                22 => Value::TypeIvec3(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), z:*((base + 24) as *const i32), }),
                23 => Value::TypeIvec4(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 16) as *const i32), y:*((base + 20) as *const i32), z:*((base + 24) as *const i32), w:*((base + 28) as *const i32), }),
                24 => Value::TypeDuration(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 16) as *const i64) as u64, nanoseconds:*((base + 24) as *const i32) as u32, }),
                25 => Value::TypeProceduralMeshHandle(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                26 => Value::TypeProceduralTextureHandle(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                27 => Value::TypeProceduralSamplerHandle(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                28 => Value::TypeProceduralMaterialHandle(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 16) as *const i64) as u64, *((base + 24) as *const i64) as u64), }),
                29 => Value::TypeVec({{match i32::from(*((base + 16) as *const u8)) {
                  0 => VecValue::TypeBool({
                    let base3 = *((base + 20) as *const i32);
                    let len3 = *((base + 24) as *const i32);
                    let mut result3 = Vec::with_capacity(len3 as usize);
                    for i in 0..len3 {
                      let base = base3 + i *1;
                      result3.push({
                        #[cfg(not(debug_assertions))]
                        { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                        #[cfg(debug_assertions)]
                        {
                          match i32::from(*((base + 0) as *const u8)) {
                            0 => false,
                            1 => true,
                            _ => panic!("invalid bool discriminant"),
                          }
                        }
                      });
                    }
                    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 1, 1);
                    
                    result3
                  }),
                  1 => VecValue::TypeEntityId({
                    let len4 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len4, len4)
                  }),
                  2 => VecValue::TypeF32({
                    let len5 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len5, len5)
                  }),
                  3 => VecValue::TypeF64({
                    let len6 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len6, len6)
                  }),
                  4 => VecValue::TypeMat4({
                    let len7 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len7, len7)
                  }),
                  5 => VecValue::TypeQuat({
                    let len8 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len8, len8)
                  }),
                  6 => VecValue::TypeString({
                    let base10 = *((base + 20) as *const i32);
                    let len10 = *((base + 24) as *const i32);
                    let mut result10 = Vec::with_capacity(len10 as usize);
                    for i in 0..len10 {
                      let base = base10 + i *8;
                      result10.push({
                        let len9 = *((base + 4) as *const i32) as usize;
                        
                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len9, len9))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len9, len9)).unwrap()}}
                      });
                    }
                    wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                    
                    result10
                  }),
                  7 => VecValue::TypeU8({
                    let len11 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len11, len11)
                  }),
                  8 => VecValue::TypeU16({
                    let len12 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len12, len12)
                  }),
                  9 => VecValue::TypeU32({
                    let len13 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len13, len13)
                  }),
                  10 => VecValue::TypeU64({
                    let len14 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len14, len14)
                  }),
                  11 => VecValue::TypeI8({
                    let len15 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len15, len15)
                  }),
                  12 => VecValue::TypeI16({
                    let len16 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len16, len16)
                  }),
                  13 => VecValue::TypeI32({
                    let len17 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len17, len17)
                  }),
                  14 => VecValue::TypeI64({
                    let len18 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len18, len18)
                  }),
                  15 => VecValue::TypeVec2({
                    let len19 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len19, len19)
                  }),
                  16 => VecValue::TypeVec3({
                    let len20 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len20, len20)
                  }),
                  17 => VecValue::TypeVec4({
                    let len21 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len21, len21)
                  }),
                  18 => VecValue::TypeUvec2({
                    let len22 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len22, len22)
                  }),
                  19 => VecValue::TypeUvec3({
                    let len23 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len23, len23)
                  }),
                  20 => VecValue::TypeUvec4({
                    let len24 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len24, len24)
                  }),
                  21 => VecValue::TypeIvec2({
                    let len25 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len25, len25)
                  }),
                  22 => VecValue::TypeIvec3({
                    let len26 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len26, len26)
                  }),
                  23 => VecValue::TypeIvec4({
                    let len27 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len27, len27)
                  }),
                  24 => VecValue::TypeDuration({
                    let len28 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len28, len28)
                  }),
                  25 => VecValue::TypeProceduralMeshHandle({
                    let len29 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len29, len29)
                  }),
                  26 => VecValue::TypeProceduralTextureHandle({
                    let len30 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len30, len30)
                  }),
                  27 => VecValue::TypeProceduralSamplerHandle({
                    let len31 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len31, len31)
                  }),
                  #[cfg(debug_assertions)]28 => VecValue::TypeProceduralMaterialHandle({
                    let len32 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len32, len32)
                  }),
                  #[cfg(not(debug_assertions))]_ => VecValue::TypeProceduralMaterialHandle({
                    let len32 = *((base + 24) as *const i32) as usize;
                    
                    Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len32, len32)
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]30 => Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                  0 => OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((base + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len33 = *((base + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len33, len33))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len33, len33)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeI8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeIvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), w:*((base + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeDuration(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 32) as *const i64) as u64, nanoseconds:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]28 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(not(debug_assertions))]_ => Value::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                  0 => OptionValue::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      #[cfg(not(debug_assertions))]
                      { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                      #[cfg(debug_assertions)]
                      {
                        match i32::from(*((base + 25) as *const u8)) {
                          0 => false,
                          1 => true,
                          _ => panic!("invalid bool discriminant"),
                        }
                      }
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  1 => OptionValue::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  2 => OptionValue::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const f32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  3 => OptionValue::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const f64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  4 => OptionValue::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  5 => OptionValue::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  6 => OptionValue::TypeString(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some({
                      let len33 = *((base + 32) as *const i32) as usize;
                      
                      {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len33, len33))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len33, len33)).unwrap()}}
                    }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  7 => OptionValue::TypeU8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const u8)) as u8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  8 => OptionValue::TypeU16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const u16)) as u16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  9 => OptionValue::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32) as u32),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  10 => OptionValue::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64) as u64),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  11 => OptionValue::TypeI8(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 25) as *const i8)) as i8),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  12 => OptionValue::TypeI16(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(i32::from(*((base + 26) as *const i16)) as i16),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  13 => OptionValue::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 28) as *const i32)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  14 => OptionValue::TypeI64(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(*((base + 32) as *const i64)),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  15 => OptionValue::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  16 => OptionValue::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  17 => OptionValue::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  18 => OptionValue::TypeUvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  19 => OptionValue::TypeUvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  20 => OptionValue::TypeUvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 28) as *const i32) as u32, y:*((base + 32) as *const i32) as u32, z:*((base + 36) as *const i32) as u32, w:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  21 => OptionValue::TypeIvec2(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  22 => OptionValue::TypeIvec3(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  23 => OptionValue::TypeIvec4(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 28) as *const i32), y:*((base + 32) as *const i32), z:*((base + 36) as *const i32), w:*((base + 40) as *const i32), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  24 => OptionValue::TypeDuration(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 32) as *const i64) as u64, nanoseconds:*((base + 40) as *const i32) as u32, }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  25 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  26 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  27 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]28 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 24) as *const u8)) {
                    0 => None,
                    1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 32) as *const i64) as u64, *((base + 40) as *const i64) as u64), }),
                    #[cfg(not(debug_assertions))]
                    _ => ::core::hint::unreachable_unchecked(),
                    #[cfg(debug_assertions)]
                    _ => panic!("invalid enum discriminant"),
                  }),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}),
                #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
              }}}));
            }
            wit_bindgen::rt::dealloc(base34, (len34 as usize) * 96, 8);
            result34
          }
        }
        #[allow(clippy::all)]
        pub fn add_component(entity: EntityId,index: u32,value: &Value,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            let mut cleanup_list = Vec::new();
            
            #[repr(align(8))]
            struct RetArea([u8; 112]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;let super::super::super::ambient::bindings::types::EntityId{ id0:id01, id1:id11, } = entity;
            *((ptr0 + 0) as *mut i64) = wit_bindgen::rt::as_i64(id01);
            *((ptr0 + 8) as *mut i64) = wit_bindgen::rt::as_i64(id11);
            *((ptr0 + 16) as *mut i32) = wit_bindgen::rt::as_i32(index);
            match value {
              Value::TypeBool(e) => {
                *((ptr0 + 24) as *mut u8) = (0i32) as u8;
                *((ptr0 + 32) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                
              },
              Value::TypeEntityId(e) => {
                *((ptr0 + 24) as *mut u8) = (1i32) as u8;
                let super::super::super::ambient::bindings::types::EntityId{ id0:id02, id1:id12, } = e;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(id02);
                *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(id12);
                
              },
              Value::TypeF32(e) => {
                *((ptr0 + 24) as *mut u8) = (2i32) as u8;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(e);
                
              },
              Value::TypeF64(e) => {
                *((ptr0 + 24) as *mut u8) = (3i32) as u8;
                *((ptr0 + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                
              },
              Value::TypeMat4(e) => {
                *((ptr0 + 24) as *mut u8) = (4i32) as u8;
                let super::super::super::ambient::bindings::types::Mat4{ x:x3, y:y3, z:z3, w:w3, } = e;
                let super::super::super::ambient::bindings::types::Vec4{ x:x4, y:y4, z:z4, w:w4, } = x3;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x4);
                *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y4);
                *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z4);
                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w4);
                let super::super::super::ambient::bindings::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = y3;
                *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                let super::super::super::ambient::bindings::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = z3;
                *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                let super::super::super::ambient::bindings::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = w3;
                *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                
              },
              Value::TypeQuat(e) => {
                *((ptr0 + 24) as *mut u8) = (5i32) as u8;
                let super::super::super::ambient::bindings::types::Quat{ x:x8, y:y8, z:z8, w:w8, } = e;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                
              },
              Value::TypeString(e) => {
                *((ptr0 + 24) as *mut u8) = (6i32) as u8;
                let vec9 = e;
                let ptr9 = vec9.as_ptr() as i32;
                let len9 = vec9.len() as i32;
                *((ptr0 + 36) as *mut i32) = len9;
                *((ptr0 + 32) as *mut i32) = ptr9;
                
              },
              Value::TypeU8(e) => {
                *((ptr0 + 24) as *mut u8) = (7i32) as u8;
                *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                
              },
              Value::TypeU16(e) => {
                *((ptr0 + 24) as *mut u8) = (8i32) as u8;
                *((ptr0 + 32) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                
              },
              Value::TypeU32(e) => {
                *((ptr0 + 24) as *mut u8) = (9i32) as u8;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                
              },
              Value::TypeU64(e) => {
                *((ptr0 + 24) as *mut u8) = (10i32) as u8;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                
              },
              Value::TypeI8(e) => {
                *((ptr0 + 24) as *mut u8) = (11i32) as u8;
                *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                
              },
              Value::TypeI16(e) => {
                *((ptr0 + 24) as *mut u8) = (12i32) as u8;
                *((ptr0 + 32) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                
              },
              Value::TypeI32(e) => {
                *((ptr0 + 24) as *mut u8) = (13i32) as u8;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                
              },
              Value::TypeI64(e) => {
                *((ptr0 + 24) as *mut u8) = (14i32) as u8;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                
              },
              Value::TypeVec2(e) => {
                *((ptr0 + 24) as *mut u8) = (15i32) as u8;
                let super::super::super::ambient::bindings::types::Vec2{ x:x10, y:y10, } = e;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x10);
                *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y10);
                
              },
              Value::TypeVec3(e) => {
                *((ptr0 + 24) as *mut u8) = (16i32) as u8;
                let super::super::super::ambient::bindings::types::Vec3{ x:x11, y:y11, z:z11, } = e;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z11);
                
              },
              Value::TypeVec4(e) => {
                *((ptr0 + 24) as *mut u8) = (17i32) as u8;
                let super::super::super::ambient::bindings::types::Vec4{ x:x12, y:y12, z:z12, w:w12, } = e;
                *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w12);
                
              },
              Value::TypeUvec2(e) => {
                *((ptr0 + 24) as *mut u8) = (18i32) as u8;
                let super::super::super::ambient::bindings::types::Uvec2{ x:x13, y:y13, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x13);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y13);
                
              },
              Value::TypeUvec3(e) => {
                *((ptr0 + 24) as *mut u8) = (19i32) as u8;
                let super::super::super::ambient::bindings::types::Uvec3{ x:x14, y:y14, z:z14, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z14);
                
              },
              Value::TypeUvec4(e) => {
                *((ptr0 + 24) as *mut u8) = (20i32) as u8;
                let super::super::super::ambient::bindings::types::Uvec4{ x:x15, y:y15, z:z15, w:w15, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w15);
                
              },
              Value::TypeIvec2(e) => {
                *((ptr0 + 24) as *mut u8) = (21i32) as u8;
                let super::super::super::ambient::bindings::types::Ivec2{ x:x16, y:y16, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                
              },
              Value::TypeIvec3(e) => {
                *((ptr0 + 24) as *mut u8) = (22i32) as u8;
                let super::super::super::ambient::bindings::types::Ivec3{ x:x17, y:y17, z:z17, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x17);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y17);
                *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z17);
                
              },
              Value::TypeIvec4(e) => {
                *((ptr0 + 24) as *mut u8) = (23i32) as u8;
                let super::super::super::ambient::bindings::types::Ivec4{ x:x18, y:y18, z:z18, w:w18, } = e;
                *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x18);
                *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y18);
                *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z18);
                *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w18);
                
              },
              Value::TypeDuration(e) => {
                *((ptr0 + 24) as *mut u8) = (24i32) as u8;
                let super::super::super::ambient::bindings::types::Duration{ seconds:seconds19, nanoseconds:nanoseconds19, } = e;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(seconds19);
                *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds19);
                
              },
              Value::TypeProceduralMeshHandle(e) => {
                *((ptr0 + 24) as *mut u8) = (25i32) as u8;
                let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid20, } = e;
                let (t21_0, t21_1, ) = ulid20;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t21_0);
                *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t21_1);
                
              },
              Value::TypeProceduralTextureHandle(e) => {
                *((ptr0 + 24) as *mut u8) = (26i32) as u8;
                let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid22, } = e;
                let (t23_0, t23_1, ) = ulid22;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t23_0);
                *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t23_1);
                
              },
              Value::TypeProceduralSamplerHandle(e) => {
                *((ptr0 + 24) as *mut u8) = (27i32) as u8;
                let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid24, } = e;
                let (t25_0, t25_1, ) = ulid24;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t25_0);
                *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t25_1);
                
              },
              Value::TypeProceduralMaterialHandle(e) => {
                *((ptr0 + 24) as *mut u8) = (28i32) as u8;
                let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid26, } = e;
                let (t27_0, t27_1, ) = ulid26;
                *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t27_0);
                *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t27_1);
                
              },
              Value::TypeVec(e) => {
                *((ptr0 + 24) as *mut u8) = (29i32) as u8;
                match e {
                  VecValue::TypeBool(e) => {
                    *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                    let vec28 = e;
                    let len28 = vec28.len() as i32;
                    let layout28 = alloc::Layout::from_size_align_unchecked(vec28.len() * 1, 1);
                    let result28 = if layout28.size() != 0
                    {
                      let ptr = alloc::alloc(layout28);
                      if ptr.is_null()
                      {
                        alloc::handle_alloc_error(layout28);
                      }
                      ptr
                    }else {
                      ::core::ptr::null_mut()
                    };
                    for (i, e) in vec28.into_iter().enumerate() {
                      let base = result28 as i32 + (i as i32) * 1;
                      {
                        *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                        
                      }}
                      *((ptr0 + 40) as *mut i32) = len28;
                      *((ptr0 + 36) as *mut i32) = result28 as i32;
                      cleanup_list.extend_from_slice(&[(result28, layout28),]);
                      
                    },
                    VecValue::TypeEntityId(e) => {
                      *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                      let vec29 = e;
                      let ptr29 = vec29.as_ptr() as i32;
                      let len29 = vec29.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len29;
                      *((ptr0 + 36) as *mut i32) = ptr29;
                      
                    },
                    VecValue::TypeF32(e) => {
                      *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                      let vec30 = e;
                      let ptr30 = vec30.as_ptr() as i32;
                      let len30 = vec30.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len30;
                      *((ptr0 + 36) as *mut i32) = ptr30;
                      
                    },
                    VecValue::TypeF64(e) => {
                      *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                      let vec31 = e;
                      let ptr31 = vec31.as_ptr() as i32;
                      let len31 = vec31.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len31;
                      *((ptr0 + 36) as *mut i32) = ptr31;
                      
                    },
                    VecValue::TypeMat4(e) => {
                      *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                      let vec32 = e;
                      let ptr32 = vec32.as_ptr() as i32;
                      let len32 = vec32.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len32;
                      *((ptr0 + 36) as *mut i32) = ptr32;
                      
                    },
                    VecValue::TypeQuat(e) => {
                      *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                      let vec33 = e;
                      let ptr33 = vec33.as_ptr() as i32;
                      let len33 = vec33.len() as i32;
                      *((ptr0 + 40) as *mut i32) = len33;
                      *((ptr0 + 36) as *mut i32) = ptr33;
                      
                    },
                    VecValue::TypeString(e) => {
                      *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                      let vec35 = e;
                      let len35 = vec35.len() as i32;
                      let layout35 = alloc::Layout::from_size_align_unchecked(vec35.len() * 8, 4);
                      let result35 = if layout35.size() != 0
                      {
                        let ptr = alloc::alloc(layout35);
                        if ptr.is_null()
                        {
                          alloc::handle_alloc_error(layout35);
                        }
                        ptr
                      }else {
                        ::core::ptr::null_mut()
                      };
                      for (i, e) in vec35.into_iter().enumerate() {
                        let base = result35 as i32 + (i as i32) * 8;
                        {
                          let vec34 = e;
                          let ptr34 = vec34.as_ptr() as i32;
                          let len34 = vec34.len() as i32;
                          *((base + 4) as *mut i32) = len34;
                          *((base + 0) as *mut i32) = ptr34;
                          
                        }}
                        *((ptr0 + 40) as *mut i32) = len35;
                        *((ptr0 + 36) as *mut i32) = result35 as i32;
                        cleanup_list.extend_from_slice(&[(result35, layout35),]);
                        
                      },
                      VecValue::TypeU8(e) => {
                        *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                        let vec36 = e;
                        let ptr36 = vec36.as_ptr() as i32;
                        let len36 = vec36.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len36;
                        *((ptr0 + 36) as *mut i32) = ptr36;
                        
                      },
                      VecValue::TypeU16(e) => {
                        *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                        let vec37 = e;
                        let ptr37 = vec37.as_ptr() as i32;
                        let len37 = vec37.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len37;
                        *((ptr0 + 36) as *mut i32) = ptr37;
                        
                      },
                      VecValue::TypeU32(e) => {
                        *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                        let vec38 = e;
                        let ptr38 = vec38.as_ptr() as i32;
                        let len38 = vec38.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len38;
                        *((ptr0 + 36) as *mut i32) = ptr38;
                        
                      },
                      VecValue::TypeU64(e) => {
                        *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                        let vec39 = e;
                        let ptr39 = vec39.as_ptr() as i32;
                        let len39 = vec39.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len39;
                        *((ptr0 + 36) as *mut i32) = ptr39;
                        
                      },
                      VecValue::TypeI8(e) => {
                        *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                        let vec40 = e;
                        let ptr40 = vec40.as_ptr() as i32;
                        let len40 = vec40.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len40;
                        *((ptr0 + 36) as *mut i32) = ptr40;
                        
                      },
                      VecValue::TypeI16(e) => {
                        *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                        let vec41 = e;
                        let ptr41 = vec41.as_ptr() as i32;
                        let len41 = vec41.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len41;
                        *((ptr0 + 36) as *mut i32) = ptr41;
                        
                      },
                      VecValue::TypeI32(e) => {
                        *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                        let vec42 = e;
                        let ptr42 = vec42.as_ptr() as i32;
                        let len42 = vec42.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len42;
                        *((ptr0 + 36) as *mut i32) = ptr42;
                        
                      },
                      VecValue::TypeI64(e) => {
                        *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                        let vec43 = e;
                        let ptr43 = vec43.as_ptr() as i32;
                        let len43 = vec43.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len43;
                        *((ptr0 + 36) as *mut i32) = ptr43;
                        
                      },
                      VecValue::TypeVec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                        let vec44 = e;
                        let ptr44 = vec44.as_ptr() as i32;
                        let len44 = vec44.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len44;
                        *((ptr0 + 36) as *mut i32) = ptr44;
                        
                      },
                      VecValue::TypeVec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                        let vec45 = e;
                        let ptr45 = vec45.as_ptr() as i32;
                        let len45 = vec45.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len45;
                        *((ptr0 + 36) as *mut i32) = ptr45;
                        
                      },
                      VecValue::TypeVec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                        let vec46 = e;
                        let ptr46 = vec46.as_ptr() as i32;
                        let len46 = vec46.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len46;
                        *((ptr0 + 36) as *mut i32) = ptr46;
                        
                      },
                      VecValue::TypeUvec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                        let vec47 = e;
                        let ptr47 = vec47.as_ptr() as i32;
                        let len47 = vec47.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len47;
                        *((ptr0 + 36) as *mut i32) = ptr47;
                        
                      },
                      VecValue::TypeUvec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                        let vec48 = e;
                        let ptr48 = vec48.as_ptr() as i32;
                        let len48 = vec48.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len48;
                        *((ptr0 + 36) as *mut i32) = ptr48;
                        
                      },
                      VecValue::TypeUvec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                        let vec49 = e;
                        let ptr49 = vec49.as_ptr() as i32;
                        let len49 = vec49.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len49;
                        *((ptr0 + 36) as *mut i32) = ptr49;
                        
                      },
                      VecValue::TypeIvec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                        let vec50 = e;
                        let ptr50 = vec50.as_ptr() as i32;
                        let len50 = vec50.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len50;
                        *((ptr0 + 36) as *mut i32) = ptr50;
                        
                      },
                      VecValue::TypeIvec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (22i32) as u8;
                        let vec51 = e;
                        let ptr51 = vec51.as_ptr() as i32;
                        let len51 = vec51.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len51;
                        *((ptr0 + 36) as *mut i32) = ptr51;
                        
                      },
                      VecValue::TypeIvec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (23i32) as u8;
                        let vec52 = e;
                        let ptr52 = vec52.as_ptr() as i32;
                        let len52 = vec52.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len52;
                        *((ptr0 + 36) as *mut i32) = ptr52;
                        
                      },
                      VecValue::TypeDuration(e) => {
                        *((ptr0 + 32) as *mut u8) = (24i32) as u8;
                        let vec53 = e;
                        let ptr53 = vec53.as_ptr() as i32;
                        let len53 = vec53.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len53;
                        *((ptr0 + 36) as *mut i32) = ptr53;
                        
                      },
                      VecValue::TypeProceduralMeshHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (25i32) as u8;
                        let vec54 = e;
                        let ptr54 = vec54.as_ptr() as i32;
                        let len54 = vec54.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len54;
                        *((ptr0 + 36) as *mut i32) = ptr54;
                        
                      },
                      VecValue::TypeProceduralTextureHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (26i32) as u8;
                        let vec55 = e;
                        let ptr55 = vec55.as_ptr() as i32;
                        let len55 = vec55.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len55;
                        *((ptr0 + 36) as *mut i32) = ptr55;
                        
                      },
                      VecValue::TypeProceduralSamplerHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (27i32) as u8;
                        let vec56 = e;
                        let ptr56 = vec56.as_ptr() as i32;
                        let len56 = vec56.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len56;
                        *((ptr0 + 36) as *mut i32) = ptr56;
                        
                      },
                      VecValue::TypeProceduralMaterialHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (28i32) as u8;
                        let vec57 = e;
                        let ptr57 = vec57.as_ptr() as i32;
                        let len57 = vec57.len() as i32;
                        *((ptr0 + 40) as *mut i32) = len57;
                        *((ptr0 + 36) as *mut i32) = ptr57;
                        
                      },
                    };
                    
                  },
                  Value::TypeOption(e) => {
                    *((ptr0 + 24) as *mut u8) = (30i32) as u8;
                    match e {
                      OptionValue::TypeBool(e) => {
                        *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 41) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeEntityId(e) => {
                        *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::EntityId{ id0:id058, id1:id158, } = e;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(id058);
                            *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(id158);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeF32(e) => {
                        *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeF64(e) => {
                        *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 48) as *mut f64) = wit_bindgen::rt::as_f64(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeMat4(e) => {
                        *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Mat4{ x:x59, y:y59, z:z59, w:w59, } = e;
                            let super::super::super::ambient::bindings::types::Vec4{ x:x60, y:y60, z:z60, w:w60, } = x59;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x60);
                            *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y60);
                            *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z60);
                            *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w60);
                            let super::super::super::ambient::bindings::types::Vec4{ x:x61, y:y61, z:z61, w:w61, } = y59;
                            *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(x61);
                            *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(y61);
                            *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(z61);
                            *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(w61);
                            let super::super::super::ambient::bindings::types::Vec4{ x:x62, y:y62, z:z62, w:w62, } = z59;
                            *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(x62);
                            *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(y62);
                            *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(z62);
                            *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(w62);
                            let super::super::super::ambient::bindings::types::Vec4{ x:x63, y:y63, z:z63, w:w63, } = w59;
                            *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(x63);
                            *((ptr0 + 96) as *mut f32) = wit_bindgen::rt::as_f32(y63);
                            *((ptr0 + 100) as *mut f32) = wit_bindgen::rt::as_f32(z63);
                            *((ptr0 + 104) as *mut f32) = wit_bindgen::rt::as_f32(w63);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeQuat(e) => {
                        *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Quat{ x:x64, y:y64, z:z64, w:w64, } = e;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x64);
                            *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y64);
                            *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z64);
                            *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w64);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeString(e) => {
                        *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let vec65 = e;
                            let ptr65 = vec65.as_ptr() as i32;
                            let len65 = vec65.len() as i32;
                            *((ptr0 + 48) as *mut i32) = len65;
                            *((ptr0 + 44) as *mut i32) = ptr65;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeU8(e) => {
                        *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeU16(e) => {
                        *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 42) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeU32(e) => {
                        *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeU64(e) => {
                        *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeI8(e) => {
                        *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeI16(e) => {
                        *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 42) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeI32(e) => {
                        *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeI64(e) => {
                        *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeVec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Vec2{ x:x66, y:y66, } = e;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x66);
                            *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y66);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeVec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Vec3{ x:x67, y:y67, z:z67, } = e;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x67);
                            *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y67);
                            *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z67);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeVec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Vec4{ x:x68, y:y68, z:z68, w:w68, } = e;
                            *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x68);
                            *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y68);
                            *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z68);
                            *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w68);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeUvec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Uvec2{ x:x69, y:y69, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x69);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y69);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeUvec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Uvec3{ x:x70, y:y70, z:z70, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x70);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y70);
                            *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z70);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeUvec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Uvec4{ x:x71, y:y71, z:z71, w:w71, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x71);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y71);
                            *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z71);
                            *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w71);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeIvec2(e) => {
                        *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Ivec2{ x:x72, y:y72, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x72);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y72);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeIvec3(e) => {
                        *((ptr0 + 32) as *mut u8) = (22i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Ivec3{ x:x73, y:y73, z:z73, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x73);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y73);
                            *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z73);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeIvec4(e) => {
                        *((ptr0 + 32) as *mut u8) = (23i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Ivec4{ x:x74, y:y74, z:z74, w:w74, } = e;
                            *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x74);
                            *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y74);
                            *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z74);
                            *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w74);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeDuration(e) => {
                        *((ptr0 + 32) as *mut u8) = (24i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::types::Duration{ seconds:seconds75, nanoseconds:nanoseconds75, } = e;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(seconds75);
                            *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds75);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeProceduralMeshHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (25i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid76, } = e;
                            let (t77_0, t77_1, ) = ulid76;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t77_0);
                            *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t77_1);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeProceduralTextureHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (26i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid78, } = e;
                            let (t79_0, t79_1, ) = ulid78;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t79_0);
                            *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t79_1);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeProceduralSamplerHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (27i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid80, } = e;
                            let (t81_0, t81_1, ) = ulid80;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t81_0);
                            *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t81_1);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                      OptionValue::TypeProceduralMaterialHandle(e) => {
                        *((ptr0 + 32) as *mut u8) = (28i32) as u8;
                        match e {
                          Some(e) => {
                            *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                            let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid82, } = e;
                            let (t83_0, t83_1, ) = ulid82;
                            *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t83_0);
                            *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t83_1);
                            
                          },
                          None => {
                            {
                              *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                              
                            }
                          },
                        };
                      },
                    };
                    
                  },
                };
                
                #[link(wasm_import_module = "ambient:bindings/component")]
                extern "C" {
                  #[cfg_attr(target_arch = "wasm32", link_name = "add-component")]
                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_add-component")]
                  fn wit_import(
                  _: i32, );
                }
                wit_import(ptr0);
                for (ptr, layout) in cleanup_list {
                  
                  if layout.size() != 0 {
                    
                    alloc::dealloc(ptr, layout);
                    
                  }
                  
                }
              }
            }
            #[allow(clippy::all)]
            pub fn add_components(entity: EntityId,data: &Entity,){
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              unsafe {
                let mut cleanup_list = Vec::new();
                let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                let vec84 = data;
                let len84 = vec84.len() as i32;
                let layout84 = alloc::Layout::from_size_align_unchecked(vec84.len() * 96, 8);
                let result84 = if layout84.size() != 0
                {
                  let ptr = alloc::alloc(layout84);
                  if ptr.is_null()
                  {
                    alloc::handle_alloc_error(layout84);
                  }
                  ptr
                }else {
                  ::core::ptr::null_mut()
                };
                for (i, e) in vec84.into_iter().enumerate() {
                  let base = result84 as i32 + (i as i32) * 96;
                  {
                    let (t1_0, t1_1, ) = e;
                    *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t1_0);
                    match t1_1 {
                      Value::TypeBool(e) => {
                        *((base + 8) as *mut u8) = (0i32) as u8;
                        *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                        
                      },
                      Value::TypeEntityId(e) => {
                        *((base + 8) as *mut u8) = (1i32) as u8;
                        let super::super::super::ambient::bindings::types::EntityId{ id0:id02, id1:id12, } = e;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id02);
                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id12);
                        
                      },
                      Value::TypeF32(e) => {
                        *((base + 8) as *mut u8) = (2i32) as u8;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                        
                      },
                      Value::TypeF64(e) => {
                        *((base + 8) as *mut u8) = (3i32) as u8;
                        *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                        
                      },
                      Value::TypeMat4(e) => {
                        *((base + 8) as *mut u8) = (4i32) as u8;
                        let super::super::super::ambient::bindings::types::Mat4{ x:x3, y:y3, z:z3, w:w3, } = e;
                        let super::super::super::ambient::bindings::types::Vec4{ x:x4, y:y4, z:z4, w:w4, } = x3;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x4);
                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y4);
                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z4);
                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w4);
                        let super::super::super::ambient::bindings::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = y3;
                        *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                        *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                        *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                        *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                        let super::super::super::ambient::bindings::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = z3;
                        *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                        *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                        *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                        *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                        let super::super::super::ambient::bindings::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = w3;
                        *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                        *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                        *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                        *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                        
                      },
                      Value::TypeQuat(e) => {
                        *((base + 8) as *mut u8) = (5i32) as u8;
                        let super::super::super::ambient::bindings::types::Quat{ x:x8, y:y8, z:z8, w:w8, } = e;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                        
                      },
                      Value::TypeString(e) => {
                        *((base + 8) as *mut u8) = (6i32) as u8;
                        let vec9 = e;
                        let ptr9 = vec9.as_ptr() as i32;
                        let len9 = vec9.len() as i32;
                        *((base + 20) as *mut i32) = len9;
                        *((base + 16) as *mut i32) = ptr9;
                        
                      },
                      Value::TypeU8(e) => {
                        *((base + 8) as *mut u8) = (7i32) as u8;
                        *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                        
                      },
                      Value::TypeU16(e) => {
                        *((base + 8) as *mut u8) = (8i32) as u8;
                        *((base + 16) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                        
                      },
                      Value::TypeU32(e) => {
                        *((base + 8) as *mut u8) = (9i32) as u8;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                        
                      },
                      Value::TypeU64(e) => {
                        *((base + 8) as *mut u8) = (10i32) as u8;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                        
                      },
                      Value::TypeI8(e) => {
                        *((base + 8) as *mut u8) = (11i32) as u8;
                        *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                        
                      },
                      Value::TypeI16(e) => {
                        *((base + 8) as *mut u8) = (12i32) as u8;
                        *((base + 16) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                        
                      },
                      Value::TypeI32(e) => {
                        *((base + 8) as *mut u8) = (13i32) as u8;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                        
                      },
                      Value::TypeI64(e) => {
                        *((base + 8) as *mut u8) = (14i32) as u8;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                        
                      },
                      Value::TypeVec2(e) => {
                        *((base + 8) as *mut u8) = (15i32) as u8;
                        let super::super::super::ambient::bindings::types::Vec2{ x:x10, y:y10, } = e;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x10);
                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y10);
                        
                      },
                      Value::TypeVec3(e) => {
                        *((base + 8) as *mut u8) = (16i32) as u8;
                        let super::super::super::ambient::bindings::types::Vec3{ x:x11, y:y11, z:z11, } = e;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z11);
                        
                      },
                      Value::TypeVec4(e) => {
                        *((base + 8) as *mut u8) = (17i32) as u8;
                        let super::super::super::ambient::bindings::types::Vec4{ x:x12, y:y12, z:z12, w:w12, } = e;
                        *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                        *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                        *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                        *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w12);
                        
                      },
                      Value::TypeUvec2(e) => {
                        *((base + 8) as *mut u8) = (18i32) as u8;
                        let super::super::super::ambient::bindings::types::Uvec2{ x:x13, y:y13, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x13);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y13);
                        
                      },
                      Value::TypeUvec3(e) => {
                        *((base + 8) as *mut u8) = (19i32) as u8;
                        let super::super::super::ambient::bindings::types::Uvec3{ x:x14, y:y14, z:z14, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z14);
                        
                      },
                      Value::TypeUvec4(e) => {
                        *((base + 8) as *mut u8) = (20i32) as u8;
                        let super::super::super::ambient::bindings::types::Uvec4{ x:x15, y:y15, z:z15, w:w15, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                        *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w15);
                        
                      },
                      Value::TypeIvec2(e) => {
                        *((base + 8) as *mut u8) = (21i32) as u8;
                        let super::super::super::ambient::bindings::types::Ivec2{ x:x16, y:y16, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                        
                      },
                      Value::TypeIvec3(e) => {
                        *((base + 8) as *mut u8) = (22i32) as u8;
                        let super::super::super::ambient::bindings::types::Ivec3{ x:x17, y:y17, z:z17, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x17);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y17);
                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z17);
                        
                      },
                      Value::TypeIvec4(e) => {
                        *((base + 8) as *mut u8) = (23i32) as u8;
                        let super::super::super::ambient::bindings::types::Ivec4{ x:x18, y:y18, z:z18, w:w18, } = e;
                        *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x18);
                        *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y18);
                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z18);
                        *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w18);
                        
                      },
                      Value::TypeDuration(e) => {
                        *((base + 8) as *mut u8) = (24i32) as u8;
                        let super::super::super::ambient::bindings::types::Duration{ seconds:seconds19, nanoseconds:nanoseconds19, } = e;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(seconds19);
                        *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds19);
                        
                      },
                      Value::TypeProceduralMeshHandle(e) => {
                        *((base + 8) as *mut u8) = (25i32) as u8;
                        let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid20, } = e;
                        let (t21_0, t21_1, ) = ulid20;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t21_0);
                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t21_1);
                        
                      },
                      Value::TypeProceduralTextureHandle(e) => {
                        *((base + 8) as *mut u8) = (26i32) as u8;
                        let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid22, } = e;
                        let (t23_0, t23_1, ) = ulid22;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t23_0);
                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t23_1);
                        
                      },
                      Value::TypeProceduralSamplerHandle(e) => {
                        *((base + 8) as *mut u8) = (27i32) as u8;
                        let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid24, } = e;
                        let (t25_0, t25_1, ) = ulid24;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t25_0);
                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t25_1);
                        
                      },
                      Value::TypeProceduralMaterialHandle(e) => {
                        *((base + 8) as *mut u8) = (28i32) as u8;
                        let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid26, } = e;
                        let (t27_0, t27_1, ) = ulid26;
                        *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t27_0);
                        *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t27_1);
                        
                      },
                      Value::TypeVec(e) => {
                        *((base + 8) as *mut u8) = (29i32) as u8;
                        match e {
                          VecValue::TypeBool(e) => {
                            *((base + 16) as *mut u8) = (0i32) as u8;
                            let vec28 = e;
                            let len28 = vec28.len() as i32;
                            let layout28 = alloc::Layout::from_size_align_unchecked(vec28.len() * 1, 1);
                            let result28 = if layout28.size() != 0
                            {
                              let ptr = alloc::alloc(layout28);
                              if ptr.is_null()
                              {
                                alloc::handle_alloc_error(layout28);
                              }
                              ptr
                            }else {
                              ::core::ptr::null_mut()
                            };
                            for (i, e) in vec28.into_iter().enumerate() {
                              let base = result28 as i32 + (i as i32) * 1;
                              {
                                *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                
                              }}
                              *((base + 24) as *mut i32) = len28;
                              *((base + 20) as *mut i32) = result28 as i32;
                              cleanup_list.extend_from_slice(&[(result28, layout28),]);
                              
                            },
                            VecValue::TypeEntityId(e) => {
                              *((base + 16) as *mut u8) = (1i32) as u8;
                              let vec29 = e;
                              let ptr29 = vec29.as_ptr() as i32;
                              let len29 = vec29.len() as i32;
                              *((base + 24) as *mut i32) = len29;
                              *((base + 20) as *mut i32) = ptr29;
                              
                            },
                            VecValue::TypeF32(e) => {
                              *((base + 16) as *mut u8) = (2i32) as u8;
                              let vec30 = e;
                              let ptr30 = vec30.as_ptr() as i32;
                              let len30 = vec30.len() as i32;
                              *((base + 24) as *mut i32) = len30;
                              *((base + 20) as *mut i32) = ptr30;
                              
                            },
                            VecValue::TypeF64(e) => {
                              *((base + 16) as *mut u8) = (3i32) as u8;
                              let vec31 = e;
                              let ptr31 = vec31.as_ptr() as i32;
                              let len31 = vec31.len() as i32;
                              *((base + 24) as *mut i32) = len31;
                              *((base + 20) as *mut i32) = ptr31;
                              
                            },
                            VecValue::TypeMat4(e) => {
                              *((base + 16) as *mut u8) = (4i32) as u8;
                              let vec32 = e;
                              let ptr32 = vec32.as_ptr() as i32;
                              let len32 = vec32.len() as i32;
                              *((base + 24) as *mut i32) = len32;
                              *((base + 20) as *mut i32) = ptr32;
                              
                            },
                            VecValue::TypeQuat(e) => {
                              *((base + 16) as *mut u8) = (5i32) as u8;
                              let vec33 = e;
                              let ptr33 = vec33.as_ptr() as i32;
                              let len33 = vec33.len() as i32;
                              *((base + 24) as *mut i32) = len33;
                              *((base + 20) as *mut i32) = ptr33;
                              
                            },
                            VecValue::TypeString(e) => {
                              *((base + 16) as *mut u8) = (6i32) as u8;
                              let vec35 = e;
                              let len35 = vec35.len() as i32;
                              let layout35 = alloc::Layout::from_size_align_unchecked(vec35.len() * 8, 4);
                              let result35 = if layout35.size() != 0
                              {
                                let ptr = alloc::alloc(layout35);
                                if ptr.is_null()
                                {
                                  alloc::handle_alloc_error(layout35);
                                }
                                ptr
                              }else {
                                ::core::ptr::null_mut()
                              };
                              for (i, e) in vec35.into_iter().enumerate() {
                                let base = result35 as i32 + (i as i32) * 8;
                                {
                                  let vec34 = e;
                                  let ptr34 = vec34.as_ptr() as i32;
                                  let len34 = vec34.len() as i32;
                                  *((base + 4) as *mut i32) = len34;
                                  *((base + 0) as *mut i32) = ptr34;
                                  
                                }}
                                *((base + 24) as *mut i32) = len35;
                                *((base + 20) as *mut i32) = result35 as i32;
                                cleanup_list.extend_from_slice(&[(result35, layout35),]);
                                
                              },
                              VecValue::TypeU8(e) => {
                                *((base + 16) as *mut u8) = (7i32) as u8;
                                let vec36 = e;
                                let ptr36 = vec36.as_ptr() as i32;
                                let len36 = vec36.len() as i32;
                                *((base + 24) as *mut i32) = len36;
                                *((base + 20) as *mut i32) = ptr36;
                                
                              },
                              VecValue::TypeU16(e) => {
                                *((base + 16) as *mut u8) = (8i32) as u8;
                                let vec37 = e;
                                let ptr37 = vec37.as_ptr() as i32;
                                let len37 = vec37.len() as i32;
                                *((base + 24) as *mut i32) = len37;
                                *((base + 20) as *mut i32) = ptr37;
                                
                              },
                              VecValue::TypeU32(e) => {
                                *((base + 16) as *mut u8) = (9i32) as u8;
                                let vec38 = e;
                                let ptr38 = vec38.as_ptr() as i32;
                                let len38 = vec38.len() as i32;
                                *((base + 24) as *mut i32) = len38;
                                *((base + 20) as *mut i32) = ptr38;
                                
                              },
                              VecValue::TypeU64(e) => {
                                *((base + 16) as *mut u8) = (10i32) as u8;
                                let vec39 = e;
                                let ptr39 = vec39.as_ptr() as i32;
                                let len39 = vec39.len() as i32;
                                *((base + 24) as *mut i32) = len39;
                                *((base + 20) as *mut i32) = ptr39;
                                
                              },
                              VecValue::TypeI8(e) => {
                                *((base + 16) as *mut u8) = (11i32) as u8;
                                let vec40 = e;
                                let ptr40 = vec40.as_ptr() as i32;
                                let len40 = vec40.len() as i32;
                                *((base + 24) as *mut i32) = len40;
                                *((base + 20) as *mut i32) = ptr40;
                                
                              },
                              VecValue::TypeI16(e) => {
                                *((base + 16) as *mut u8) = (12i32) as u8;
                                let vec41 = e;
                                let ptr41 = vec41.as_ptr() as i32;
                                let len41 = vec41.len() as i32;
                                *((base + 24) as *mut i32) = len41;
                                *((base + 20) as *mut i32) = ptr41;
                                
                              },
                              VecValue::TypeI32(e) => {
                                *((base + 16) as *mut u8) = (13i32) as u8;
                                let vec42 = e;
                                let ptr42 = vec42.as_ptr() as i32;
                                let len42 = vec42.len() as i32;
                                *((base + 24) as *mut i32) = len42;
                                *((base + 20) as *mut i32) = ptr42;
                                
                              },
                              VecValue::TypeI64(e) => {
                                *((base + 16) as *mut u8) = (14i32) as u8;
                                let vec43 = e;
                                let ptr43 = vec43.as_ptr() as i32;
                                let len43 = vec43.len() as i32;
                                *((base + 24) as *mut i32) = len43;
                                *((base + 20) as *mut i32) = ptr43;
                                
                              },
                              VecValue::TypeVec2(e) => {
                                *((base + 16) as *mut u8) = (15i32) as u8;
                                let vec44 = e;
                                let ptr44 = vec44.as_ptr() as i32;
                                let len44 = vec44.len() as i32;
                                *((base + 24) as *mut i32) = len44;
                                *((base + 20) as *mut i32) = ptr44;
                                
                              },
                              VecValue::TypeVec3(e) => {
                                *((base + 16) as *mut u8) = (16i32) as u8;
                                let vec45 = e;
                                let ptr45 = vec45.as_ptr() as i32;
                                let len45 = vec45.len() as i32;
                                *((base + 24) as *mut i32) = len45;
                                *((base + 20) as *mut i32) = ptr45;
                                
                              },
                              VecValue::TypeVec4(e) => {
                                *((base + 16) as *mut u8) = (17i32) as u8;
                                let vec46 = e;
                                let ptr46 = vec46.as_ptr() as i32;
                                let len46 = vec46.len() as i32;
                                *((base + 24) as *mut i32) = len46;
                                *((base + 20) as *mut i32) = ptr46;
                                
                              },
                              VecValue::TypeUvec2(e) => {
                                *((base + 16) as *mut u8) = (18i32) as u8;
                                let vec47 = e;
                                let ptr47 = vec47.as_ptr() as i32;
                                let len47 = vec47.len() as i32;
                                *((base + 24) as *mut i32) = len47;
                                *((base + 20) as *mut i32) = ptr47;
                                
                              },
                              VecValue::TypeUvec3(e) => {
                                *((base + 16) as *mut u8) = (19i32) as u8;
                                let vec48 = e;
                                let ptr48 = vec48.as_ptr() as i32;
                                let len48 = vec48.len() as i32;
                                *((base + 24) as *mut i32) = len48;
                                *((base + 20) as *mut i32) = ptr48;
                                
                              },
                              VecValue::TypeUvec4(e) => {
                                *((base + 16) as *mut u8) = (20i32) as u8;
                                let vec49 = e;
                                let ptr49 = vec49.as_ptr() as i32;
                                let len49 = vec49.len() as i32;
                                *((base + 24) as *mut i32) = len49;
                                *((base + 20) as *mut i32) = ptr49;
                                
                              },
                              VecValue::TypeIvec2(e) => {
                                *((base + 16) as *mut u8) = (21i32) as u8;
                                let vec50 = e;
                                let ptr50 = vec50.as_ptr() as i32;
                                let len50 = vec50.len() as i32;
                                *((base + 24) as *mut i32) = len50;
                                *((base + 20) as *mut i32) = ptr50;
                                
                              },
                              VecValue::TypeIvec3(e) => {
                                *((base + 16) as *mut u8) = (22i32) as u8;
                                let vec51 = e;
                                let ptr51 = vec51.as_ptr() as i32;
                                let len51 = vec51.len() as i32;
                                *((base + 24) as *mut i32) = len51;
                                *((base + 20) as *mut i32) = ptr51;
                                
                              },
                              VecValue::TypeIvec4(e) => {
                                *((base + 16) as *mut u8) = (23i32) as u8;
                                let vec52 = e;
                                let ptr52 = vec52.as_ptr() as i32;
                                let len52 = vec52.len() as i32;
                                *((base + 24) as *mut i32) = len52;
                                *((base + 20) as *mut i32) = ptr52;
                                
                              },
                              VecValue::TypeDuration(e) => {
                                *((base + 16) as *mut u8) = (24i32) as u8;
                                let vec53 = e;
                                let ptr53 = vec53.as_ptr() as i32;
                                let len53 = vec53.len() as i32;
                                *((base + 24) as *mut i32) = len53;
                                *((base + 20) as *mut i32) = ptr53;
                                
                              },
                              VecValue::TypeProceduralMeshHandle(e) => {
                                *((base + 16) as *mut u8) = (25i32) as u8;
                                let vec54 = e;
                                let ptr54 = vec54.as_ptr() as i32;
                                let len54 = vec54.len() as i32;
                                *((base + 24) as *mut i32) = len54;
                                *((base + 20) as *mut i32) = ptr54;
                                
                              },
                              VecValue::TypeProceduralTextureHandle(e) => {
                                *((base + 16) as *mut u8) = (26i32) as u8;
                                let vec55 = e;
                                let ptr55 = vec55.as_ptr() as i32;
                                let len55 = vec55.len() as i32;
                                *((base + 24) as *mut i32) = len55;
                                *((base + 20) as *mut i32) = ptr55;
                                
                              },
                              VecValue::TypeProceduralSamplerHandle(e) => {
                                *((base + 16) as *mut u8) = (27i32) as u8;
                                let vec56 = e;
                                let ptr56 = vec56.as_ptr() as i32;
                                let len56 = vec56.len() as i32;
                                *((base + 24) as *mut i32) = len56;
                                *((base + 20) as *mut i32) = ptr56;
                                
                              },
                              VecValue::TypeProceduralMaterialHandle(e) => {
                                *((base + 16) as *mut u8) = (28i32) as u8;
                                let vec57 = e;
                                let ptr57 = vec57.as_ptr() as i32;
                                let len57 = vec57.len() as i32;
                                *((base + 24) as *mut i32) = len57;
                                *((base + 20) as *mut i32) = ptr57;
                                
                              },
                            };
                            
                          },
                          Value::TypeOption(e) => {
                            *((base + 8) as *mut u8) = (30i32) as u8;
                            match e {
                              OptionValue::TypeBool(e) => {
                                *((base + 16) as *mut u8) = (0i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeEntityId(e) => {
                                *((base + 16) as *mut u8) = (1i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::EntityId{ id0:id058, id1:id158, } = e;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id058);
                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id158);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeF32(e) => {
                                *((base + 16) as *mut u8) = (2i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeF64(e) => {
                                *((base + 16) as *mut u8) = (3i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeMat4(e) => {
                                *((base + 16) as *mut u8) = (4i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Mat4{ x:x59, y:y59, z:z59, w:w59, } = e;
                                    let super::super::super::ambient::bindings::types::Vec4{ x:x60, y:y60, z:z60, w:w60, } = x59;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x60);
                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y60);
                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z60);
                                    *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w60);
                                    let super::super::super::ambient::bindings::types::Vec4{ x:x61, y:y61, z:z61, w:w61, } = y59;
                                    *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x61);
                                    *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y61);
                                    *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z61);
                                    *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w61);
                                    let super::super::super::ambient::bindings::types::Vec4{ x:x62, y:y62, z:z62, w:w62, } = z59;
                                    *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x62);
                                    *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y62);
                                    *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z62);
                                    *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w62);
                                    let super::super::super::ambient::bindings::types::Vec4{ x:x63, y:y63, z:z63, w:w63, } = w59;
                                    *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x63);
                                    *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y63);
                                    *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z63);
                                    *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w63);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeQuat(e) => {
                                *((base + 16) as *mut u8) = (5i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Quat{ x:x64, y:y64, z:z64, w:w64, } = e;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x64);
                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y64);
                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z64);
                                    *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w64);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeString(e) => {
                                *((base + 16) as *mut u8) = (6i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let vec65 = e;
                                    let ptr65 = vec65.as_ptr() as i32;
                                    let len65 = vec65.len() as i32;
                                    *((base + 32) as *mut i32) = len65;
                                    *((base + 28) as *mut i32) = ptr65;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeU8(e) => {
                                *((base + 16) as *mut u8) = (7i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeU16(e) => {
                                *((base + 16) as *mut u8) = (8i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 26) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeU32(e) => {
                                *((base + 16) as *mut u8) = (9i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeU64(e) => {
                                *((base + 16) as *mut u8) = (10i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeI8(e) => {
                                *((base + 16) as *mut u8) = (11i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeI16(e) => {
                                *((base + 16) as *mut u8) = (12i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 26) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeI32(e) => {
                                *((base + 16) as *mut u8) = (13i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeI64(e) => {
                                *((base + 16) as *mut u8) = (14i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeVec2(e) => {
                                *((base + 16) as *mut u8) = (15i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Vec2{ x:x66, y:y66, } = e;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x66);
                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y66);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeVec3(e) => {
                                *((base + 16) as *mut u8) = (16i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Vec3{ x:x67, y:y67, z:z67, } = e;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x67);
                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y67);
                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z67);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeVec4(e) => {
                                *((base + 16) as *mut u8) = (17i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Vec4{ x:x68, y:y68, z:z68, w:w68, } = e;
                                    *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x68);
                                    *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y68);
                                    *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z68);
                                    *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w68);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeUvec2(e) => {
                                *((base + 16) as *mut u8) = (18i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Uvec2{ x:x69, y:y69, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x69);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y69);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeUvec3(e) => {
                                *((base + 16) as *mut u8) = (19i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Uvec3{ x:x70, y:y70, z:z70, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x70);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y70);
                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z70);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeUvec4(e) => {
                                *((base + 16) as *mut u8) = (20i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Uvec4{ x:x71, y:y71, z:z71, w:w71, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x71);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y71);
                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z71);
                                    *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w71);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeIvec2(e) => {
                                *((base + 16) as *mut u8) = (21i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Ivec2{ x:x72, y:y72, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x72);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y72);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeIvec3(e) => {
                                *((base + 16) as *mut u8) = (22i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Ivec3{ x:x73, y:y73, z:z73, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x73);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y73);
                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z73);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeIvec4(e) => {
                                *((base + 16) as *mut u8) = (23i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Ivec4{ x:x74, y:y74, z:z74, w:w74, } = e;
                                    *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x74);
                                    *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y74);
                                    *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z74);
                                    *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w74);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeDuration(e) => {
                                *((base + 16) as *mut u8) = (24i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::types::Duration{ seconds:seconds75, nanoseconds:nanoseconds75, } = e;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(seconds75);
                                    *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds75);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralMeshHandle(e) => {
                                *((base + 16) as *mut u8) = (25i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid76, } = e;
                                    let (t77_0, t77_1, ) = ulid76;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t77_0);
                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t77_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralTextureHandle(e) => {
                                *((base + 16) as *mut u8) = (26i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid78, } = e;
                                    let (t79_0, t79_1, ) = ulid78;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t79_0);
                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t79_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralSamplerHandle(e) => {
                                *((base + 16) as *mut u8) = (27i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid80, } = e;
                                    let (t81_0, t81_1, ) = ulid80;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t81_0);
                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t81_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                              OptionValue::TypeProceduralMaterialHandle(e) => {
                                *((base + 16) as *mut u8) = (28i32) as u8;
                                match e {
                                  Some(e) => {
                                    *((base + 24) as *mut u8) = (1i32) as u8;
                                    let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid82, } = e;
                                    let (t83_0, t83_1, ) = ulid82;
                                    *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t83_0);
                                    *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t83_1);
                                    
                                  },
                                  None => {
                                    {
                                      *((base + 24) as *mut u8) = (0i32) as u8;
                                      
                                    }
                                  },
                                };
                              },
                            };
                            
                          },
                        };
                        
                      }}
                      
                      #[link(wasm_import_module = "ambient:bindings/component")]
                      extern "C" {
                        #[cfg_attr(target_arch = "wasm32", link_name = "add-components")]
                        #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_add-components")]
                        fn wit_import(
                        _: i64, _: i64, _: i32, _: i32, );
                      }
                      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result84 as i32, len84);
                      if layout84.size() != 0 {
                        alloc::dealloc(result84, layout84);
                      }
                      for (ptr, layout) in cleanup_list {
                        
                        if layout.size() != 0 {
                          
                          alloc::dealloc(ptr, layout);
                          
                        }
                        
                      }
                    }
                  }
                  #[allow(clippy::all)]
                  pub fn set_component(entity: EntityId,index: u32,value: &Value,){
                    
                    #[allow(unused_imports)]
                    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                    unsafe {
                      let mut cleanup_list = Vec::new();
                      
                      #[repr(align(8))]
                      struct RetArea([u8; 112]);
                      let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                      let ptr0 = ret_area.as_mut_ptr() as i32;let super::super::super::ambient::bindings::types::EntityId{ id0:id01, id1:id11, } = entity;
                      *((ptr0 + 0) as *mut i64) = wit_bindgen::rt::as_i64(id01);
                      *((ptr0 + 8) as *mut i64) = wit_bindgen::rt::as_i64(id11);
                      *((ptr0 + 16) as *mut i32) = wit_bindgen::rt::as_i32(index);
                      match value {
                        Value::TypeBool(e) => {
                          *((ptr0 + 24) as *mut u8) = (0i32) as u8;
                          *((ptr0 + 32) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                          
                        },
                        Value::TypeEntityId(e) => {
                          *((ptr0 + 24) as *mut u8) = (1i32) as u8;
                          let super::super::super::ambient::bindings::types::EntityId{ id0:id02, id1:id12, } = e;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(id02);
                          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(id12);
                          
                        },
                        Value::TypeF32(e) => {
                          *((ptr0 + 24) as *mut u8) = (2i32) as u8;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(e);
                          
                        },
                        Value::TypeF64(e) => {
                          *((ptr0 + 24) as *mut u8) = (3i32) as u8;
                          *((ptr0 + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                          
                        },
                        Value::TypeMat4(e) => {
                          *((ptr0 + 24) as *mut u8) = (4i32) as u8;
                          let super::super::super::ambient::bindings::types::Mat4{ x:x3, y:y3, z:z3, w:w3, } = e;
                          let super::super::super::ambient::bindings::types::Vec4{ x:x4, y:y4, z:z4, w:w4, } = x3;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x4);
                          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y4);
                          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z4);
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w4);
                          let super::super::super::ambient::bindings::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = y3;
                          *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                          *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                          *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                          *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                          let super::super::super::ambient::bindings::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = z3;
                          *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                          *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                          *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                          *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                          let super::super::super::ambient::bindings::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = w3;
                          *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                          *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                          *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                          *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                          
                        },
                        Value::TypeQuat(e) => {
                          *((ptr0 + 24) as *mut u8) = (5i32) as u8;
                          let super::super::super::ambient::bindings::types::Quat{ x:x8, y:y8, z:z8, w:w8, } = e;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                          
                        },
                        Value::TypeString(e) => {
                          *((ptr0 + 24) as *mut u8) = (6i32) as u8;
                          let vec9 = e;
                          let ptr9 = vec9.as_ptr() as i32;
                          let len9 = vec9.len() as i32;
                          *((ptr0 + 36) as *mut i32) = len9;
                          *((ptr0 + 32) as *mut i32) = ptr9;
                          
                        },
                        Value::TypeU8(e) => {
                          *((ptr0 + 24) as *mut u8) = (7i32) as u8;
                          *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                          
                        },
                        Value::TypeU16(e) => {
                          *((ptr0 + 24) as *mut u8) = (8i32) as u8;
                          *((ptr0 + 32) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                          
                        },
                        Value::TypeU32(e) => {
                          *((ptr0 + 24) as *mut u8) = (9i32) as u8;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                          
                        },
                        Value::TypeU64(e) => {
                          *((ptr0 + 24) as *mut u8) = (10i32) as u8;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                          
                        },
                        Value::TypeI8(e) => {
                          *((ptr0 + 24) as *mut u8) = (11i32) as u8;
                          *((ptr0 + 32) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                          
                        },
                        Value::TypeI16(e) => {
                          *((ptr0 + 24) as *mut u8) = (12i32) as u8;
                          *((ptr0 + 32) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                          
                        },
                        Value::TypeI32(e) => {
                          *((ptr0 + 24) as *mut u8) = (13i32) as u8;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
                          
                        },
                        Value::TypeI64(e) => {
                          *((ptr0 + 24) as *mut u8) = (14i32) as u8;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                          
                        },
                        Value::TypeVec2(e) => {
                          *((ptr0 + 24) as *mut u8) = (15i32) as u8;
                          let super::super::super::ambient::bindings::types::Vec2{ x:x10, y:y10, } = e;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x10);
                          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y10);
                          
                        },
                        Value::TypeVec3(e) => {
                          *((ptr0 + 24) as *mut u8) = (16i32) as u8;
                          let super::super::super::ambient::bindings::types::Vec3{ x:x11, y:y11, z:z11, } = e;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z11);
                          
                        },
                        Value::TypeVec4(e) => {
                          *((ptr0 + 24) as *mut u8) = (17i32) as u8;
                          let super::super::super::ambient::bindings::types::Vec4{ x:x12, y:y12, z:z12, w:w12, } = e;
                          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w12);
                          
                        },
                        Value::TypeUvec2(e) => {
                          *((ptr0 + 24) as *mut u8) = (18i32) as u8;
                          let super::super::super::ambient::bindings::types::Uvec2{ x:x13, y:y13, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x13);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y13);
                          
                        },
                        Value::TypeUvec3(e) => {
                          *((ptr0 + 24) as *mut u8) = (19i32) as u8;
                          let super::super::super::ambient::bindings::types::Uvec3{ x:x14, y:y14, z:z14, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z14);
                          
                        },
                        Value::TypeUvec4(e) => {
                          *((ptr0 + 24) as *mut u8) = (20i32) as u8;
                          let super::super::super::ambient::bindings::types::Uvec4{ x:x15, y:y15, z:z15, w:w15, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                          *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w15);
                          
                        },
                        Value::TypeIvec2(e) => {
                          *((ptr0 + 24) as *mut u8) = (21i32) as u8;
                          let super::super::super::ambient::bindings::types::Ivec2{ x:x16, y:y16, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                          
                        },
                        Value::TypeIvec3(e) => {
                          *((ptr0 + 24) as *mut u8) = (22i32) as u8;
                          let super::super::super::ambient::bindings::types::Ivec3{ x:x17, y:y17, z:z17, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x17);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y17);
                          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z17);
                          
                        },
                        Value::TypeIvec4(e) => {
                          *((ptr0 + 24) as *mut u8) = (23i32) as u8;
                          let super::super::super::ambient::bindings::types::Ivec4{ x:x18, y:y18, z:z18, w:w18, } = e;
                          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(x18);
                          *((ptr0 + 36) as *mut i32) = wit_bindgen::rt::as_i32(y18);
                          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(z18);
                          *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(w18);
                          
                        },
                        Value::TypeDuration(e) => {
                          *((ptr0 + 24) as *mut u8) = (24i32) as u8;
                          let super::super::super::ambient::bindings::types::Duration{ seconds:seconds19, nanoseconds:nanoseconds19, } = e;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(seconds19);
                          *((ptr0 + 40) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds19);
                          
                        },
                        Value::TypeProceduralMeshHandle(e) => {
                          *((ptr0 + 24) as *mut u8) = (25i32) as u8;
                          let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid20, } = e;
                          let (t21_0, t21_1, ) = ulid20;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t21_0);
                          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t21_1);
                          
                        },
                        Value::TypeProceduralTextureHandle(e) => {
                          *((ptr0 + 24) as *mut u8) = (26i32) as u8;
                          let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid22, } = e;
                          let (t23_0, t23_1, ) = ulid22;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t23_0);
                          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t23_1);
                          
                        },
                        Value::TypeProceduralSamplerHandle(e) => {
                          *((ptr0 + 24) as *mut u8) = (27i32) as u8;
                          let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid24, } = e;
                          let (t25_0, t25_1, ) = ulid24;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t25_0);
                          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t25_1);
                          
                        },
                        Value::TypeProceduralMaterialHandle(e) => {
                          *((ptr0 + 24) as *mut u8) = (28i32) as u8;
                          let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid26, } = e;
                          let (t27_0, t27_1, ) = ulid26;
                          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(t27_0);
                          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(t27_1);
                          
                        },
                        Value::TypeVec(e) => {
                          *((ptr0 + 24) as *mut u8) = (29i32) as u8;
                          match e {
                            VecValue::TypeBool(e) => {
                              *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                              let vec28 = e;
                              let len28 = vec28.len() as i32;
                              let layout28 = alloc::Layout::from_size_align_unchecked(vec28.len() * 1, 1);
                              let result28 = if layout28.size() != 0
                              {
                                let ptr = alloc::alloc(layout28);
                                if ptr.is_null()
                                {
                                  alloc::handle_alloc_error(layout28);
                                }
                                ptr
                              }else {
                                ::core::ptr::null_mut()
                              };
                              for (i, e) in vec28.into_iter().enumerate() {
                                let base = result28 as i32 + (i as i32) * 1;
                                {
                                  *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                  
                                }}
                                *((ptr0 + 40) as *mut i32) = len28;
                                *((ptr0 + 36) as *mut i32) = result28 as i32;
                                cleanup_list.extend_from_slice(&[(result28, layout28),]);
                                
                              },
                              VecValue::TypeEntityId(e) => {
                                *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                                let vec29 = e;
                                let ptr29 = vec29.as_ptr() as i32;
                                let len29 = vec29.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len29;
                                *((ptr0 + 36) as *mut i32) = ptr29;
                                
                              },
                              VecValue::TypeF32(e) => {
                                *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                                let vec30 = e;
                                let ptr30 = vec30.as_ptr() as i32;
                                let len30 = vec30.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len30;
                                *((ptr0 + 36) as *mut i32) = ptr30;
                                
                              },
                              VecValue::TypeF64(e) => {
                                *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                                let vec31 = e;
                                let ptr31 = vec31.as_ptr() as i32;
                                let len31 = vec31.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len31;
                                *((ptr0 + 36) as *mut i32) = ptr31;
                                
                              },
                              VecValue::TypeMat4(e) => {
                                *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                                let vec32 = e;
                                let ptr32 = vec32.as_ptr() as i32;
                                let len32 = vec32.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len32;
                                *((ptr0 + 36) as *mut i32) = ptr32;
                                
                              },
                              VecValue::TypeQuat(e) => {
                                *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                                let vec33 = e;
                                let ptr33 = vec33.as_ptr() as i32;
                                let len33 = vec33.len() as i32;
                                *((ptr0 + 40) as *mut i32) = len33;
                                *((ptr0 + 36) as *mut i32) = ptr33;
                                
                              },
                              VecValue::TypeString(e) => {
                                *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                                let vec35 = e;
                                let len35 = vec35.len() as i32;
                                let layout35 = alloc::Layout::from_size_align_unchecked(vec35.len() * 8, 4);
                                let result35 = if layout35.size() != 0
                                {
                                  let ptr = alloc::alloc(layout35);
                                  if ptr.is_null()
                                  {
                                    alloc::handle_alloc_error(layout35);
                                  }
                                  ptr
                                }else {
                                  ::core::ptr::null_mut()
                                };
                                for (i, e) in vec35.into_iter().enumerate() {
                                  let base = result35 as i32 + (i as i32) * 8;
                                  {
                                    let vec34 = e;
                                    let ptr34 = vec34.as_ptr() as i32;
                                    let len34 = vec34.len() as i32;
                                    *((base + 4) as *mut i32) = len34;
                                    *((base + 0) as *mut i32) = ptr34;
                                    
                                  }}
                                  *((ptr0 + 40) as *mut i32) = len35;
                                  *((ptr0 + 36) as *mut i32) = result35 as i32;
                                  cleanup_list.extend_from_slice(&[(result35, layout35),]);
                                  
                                },
                                VecValue::TypeU8(e) => {
                                  *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                                  let vec36 = e;
                                  let ptr36 = vec36.as_ptr() as i32;
                                  let len36 = vec36.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len36;
                                  *((ptr0 + 36) as *mut i32) = ptr36;
                                  
                                },
                                VecValue::TypeU16(e) => {
                                  *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                                  let vec37 = e;
                                  let ptr37 = vec37.as_ptr() as i32;
                                  let len37 = vec37.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len37;
                                  *((ptr0 + 36) as *mut i32) = ptr37;
                                  
                                },
                                VecValue::TypeU32(e) => {
                                  *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                                  let vec38 = e;
                                  let ptr38 = vec38.as_ptr() as i32;
                                  let len38 = vec38.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len38;
                                  *((ptr0 + 36) as *mut i32) = ptr38;
                                  
                                },
                                VecValue::TypeU64(e) => {
                                  *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                                  let vec39 = e;
                                  let ptr39 = vec39.as_ptr() as i32;
                                  let len39 = vec39.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len39;
                                  *((ptr0 + 36) as *mut i32) = ptr39;
                                  
                                },
                                VecValue::TypeI8(e) => {
                                  *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                                  let vec40 = e;
                                  let ptr40 = vec40.as_ptr() as i32;
                                  let len40 = vec40.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len40;
                                  *((ptr0 + 36) as *mut i32) = ptr40;
                                  
                                },
                                VecValue::TypeI16(e) => {
                                  *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                                  let vec41 = e;
                                  let ptr41 = vec41.as_ptr() as i32;
                                  let len41 = vec41.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len41;
                                  *((ptr0 + 36) as *mut i32) = ptr41;
                                  
                                },
                                VecValue::TypeI32(e) => {
                                  *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                                  let vec42 = e;
                                  let ptr42 = vec42.as_ptr() as i32;
                                  let len42 = vec42.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len42;
                                  *((ptr0 + 36) as *mut i32) = ptr42;
                                  
                                },
                                VecValue::TypeI64(e) => {
                                  *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                                  let vec43 = e;
                                  let ptr43 = vec43.as_ptr() as i32;
                                  let len43 = vec43.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len43;
                                  *((ptr0 + 36) as *mut i32) = ptr43;
                                  
                                },
                                VecValue::TypeVec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                                  let vec44 = e;
                                  let ptr44 = vec44.as_ptr() as i32;
                                  let len44 = vec44.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len44;
                                  *((ptr0 + 36) as *mut i32) = ptr44;
                                  
                                },
                                VecValue::TypeVec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                                  let vec45 = e;
                                  let ptr45 = vec45.as_ptr() as i32;
                                  let len45 = vec45.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len45;
                                  *((ptr0 + 36) as *mut i32) = ptr45;
                                  
                                },
                                VecValue::TypeVec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                                  let vec46 = e;
                                  let ptr46 = vec46.as_ptr() as i32;
                                  let len46 = vec46.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len46;
                                  *((ptr0 + 36) as *mut i32) = ptr46;
                                  
                                },
                                VecValue::TypeUvec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                                  let vec47 = e;
                                  let ptr47 = vec47.as_ptr() as i32;
                                  let len47 = vec47.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len47;
                                  *((ptr0 + 36) as *mut i32) = ptr47;
                                  
                                },
                                VecValue::TypeUvec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                                  let vec48 = e;
                                  let ptr48 = vec48.as_ptr() as i32;
                                  let len48 = vec48.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len48;
                                  *((ptr0 + 36) as *mut i32) = ptr48;
                                  
                                },
                                VecValue::TypeUvec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                                  let vec49 = e;
                                  let ptr49 = vec49.as_ptr() as i32;
                                  let len49 = vec49.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len49;
                                  *((ptr0 + 36) as *mut i32) = ptr49;
                                  
                                },
                                VecValue::TypeIvec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                                  let vec50 = e;
                                  let ptr50 = vec50.as_ptr() as i32;
                                  let len50 = vec50.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len50;
                                  *((ptr0 + 36) as *mut i32) = ptr50;
                                  
                                },
                                VecValue::TypeIvec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (22i32) as u8;
                                  let vec51 = e;
                                  let ptr51 = vec51.as_ptr() as i32;
                                  let len51 = vec51.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len51;
                                  *((ptr0 + 36) as *mut i32) = ptr51;
                                  
                                },
                                VecValue::TypeIvec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (23i32) as u8;
                                  let vec52 = e;
                                  let ptr52 = vec52.as_ptr() as i32;
                                  let len52 = vec52.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len52;
                                  *((ptr0 + 36) as *mut i32) = ptr52;
                                  
                                },
                                VecValue::TypeDuration(e) => {
                                  *((ptr0 + 32) as *mut u8) = (24i32) as u8;
                                  let vec53 = e;
                                  let ptr53 = vec53.as_ptr() as i32;
                                  let len53 = vec53.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len53;
                                  *((ptr0 + 36) as *mut i32) = ptr53;
                                  
                                },
                                VecValue::TypeProceduralMeshHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (25i32) as u8;
                                  let vec54 = e;
                                  let ptr54 = vec54.as_ptr() as i32;
                                  let len54 = vec54.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len54;
                                  *((ptr0 + 36) as *mut i32) = ptr54;
                                  
                                },
                                VecValue::TypeProceduralTextureHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (26i32) as u8;
                                  let vec55 = e;
                                  let ptr55 = vec55.as_ptr() as i32;
                                  let len55 = vec55.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len55;
                                  *((ptr0 + 36) as *mut i32) = ptr55;
                                  
                                },
                                VecValue::TypeProceduralSamplerHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (27i32) as u8;
                                  let vec56 = e;
                                  let ptr56 = vec56.as_ptr() as i32;
                                  let len56 = vec56.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len56;
                                  *((ptr0 + 36) as *mut i32) = ptr56;
                                  
                                },
                                VecValue::TypeProceduralMaterialHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (28i32) as u8;
                                  let vec57 = e;
                                  let ptr57 = vec57.as_ptr() as i32;
                                  let len57 = vec57.len() as i32;
                                  *((ptr0 + 40) as *mut i32) = len57;
                                  *((ptr0 + 36) as *mut i32) = ptr57;
                                  
                                },
                              };
                              
                            },
                            Value::TypeOption(e) => {
                              *((ptr0 + 24) as *mut u8) = (30i32) as u8;
                              match e {
                                OptionValue::TypeBool(e) => {
                                  *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 41) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeEntityId(e) => {
                                  *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::EntityId{ id0:id058, id1:id158, } = e;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(id058);
                                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(id158);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeF32(e) => {
                                  *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeF64(e) => {
                                  *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 48) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeMat4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Mat4{ x:x59, y:y59, z:z59, w:w59, } = e;
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x60, y:y60, z:z60, w:w60, } = x59;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x60);
                                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y60);
                                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z60);
                                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w60);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x61, y:y61, z:z61, w:w61, } = y59;
                                      *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(x61);
                                      *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(y61);
                                      *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(z61);
                                      *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(w61);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x62, y:y62, z:z62, w:w62, } = z59;
                                      *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(x62);
                                      *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(y62);
                                      *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(z62);
                                      *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(w62);
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x63, y:y63, z:z63, w:w63, } = w59;
                                      *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(x63);
                                      *((ptr0 + 96) as *mut f32) = wit_bindgen::rt::as_f32(y63);
                                      *((ptr0 + 100) as *mut f32) = wit_bindgen::rt::as_f32(z63);
                                      *((ptr0 + 104) as *mut f32) = wit_bindgen::rt::as_f32(w63);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeQuat(e) => {
                                  *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Quat{ x:x64, y:y64, z:z64, w:w64, } = e;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x64);
                                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y64);
                                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z64);
                                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w64);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeString(e) => {
                                  *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let vec65 = e;
                                      let ptr65 = vec65.as_ptr() as i32;
                                      let len65 = vec65.len() as i32;
                                      *((ptr0 + 48) as *mut i32) = len65;
                                      *((ptr0 + 44) as *mut i32) = ptr65;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeU8(e) => {
                                  *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeU16(e) => {
                                  *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 42) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeU32(e) => {
                                  *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeU64(e) => {
                                  *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeI8(e) => {
                                  *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 41) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeI16(e) => {
                                  *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 42) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeI32(e) => {
                                  *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeI64(e) => {
                                  *((ptr0 + 32) as *mut u8) = (14i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeVec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (15i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Vec2{ x:x66, y:y66, } = e;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x66);
                                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y66);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeVec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (16i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Vec3{ x:x67, y:y67, z:z67, } = e;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x67);
                                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y67);
                                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z67);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeVec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (17i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Vec4{ x:x68, y:y68, z:z68, w:w68, } = e;
                                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x68);
                                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y68);
                                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z68);
                                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w68);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeUvec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (18i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Uvec2{ x:x69, y:y69, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x69);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y69);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeUvec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (19i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Uvec3{ x:x70, y:y70, z:z70, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x70);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y70);
                                      *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z70);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeUvec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (20i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Uvec4{ x:x71, y:y71, z:z71, w:w71, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x71);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y71);
                                      *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z71);
                                      *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w71);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeIvec2(e) => {
                                  *((ptr0 + 32) as *mut u8) = (21i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Ivec2{ x:x72, y:y72, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x72);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y72);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeIvec3(e) => {
                                  *((ptr0 + 32) as *mut u8) = (22i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Ivec3{ x:x73, y:y73, z:z73, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x73);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y73);
                                      *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z73);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeIvec4(e) => {
                                  *((ptr0 + 32) as *mut u8) = (23i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Ivec4{ x:x74, y:y74, z:z74, w:w74, } = e;
                                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(x74);
                                      *((ptr0 + 48) as *mut i32) = wit_bindgen::rt::as_i32(y74);
                                      *((ptr0 + 52) as *mut i32) = wit_bindgen::rt::as_i32(z74);
                                      *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(w74);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeDuration(e) => {
                                  *((ptr0 + 32) as *mut u8) = (24i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::types::Duration{ seconds:seconds75, nanoseconds:nanoseconds75, } = e;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(seconds75);
                                      *((ptr0 + 56) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds75);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeProceduralMeshHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (25i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid76, } = e;
                                      let (t77_0, t77_1, ) = ulid76;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t77_0);
                                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t77_1);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeProceduralTextureHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (26i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid78, } = e;
                                      let (t79_0, t79_1, ) = ulid78;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t79_0);
                                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t79_1);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeProceduralSamplerHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (27i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid80, } = e;
                                      let (t81_0, t81_1, ) = ulid80;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t81_0);
                                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t81_1);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                                OptionValue::TypeProceduralMaterialHandle(e) => {
                                  *((ptr0 + 32) as *mut u8) = (28i32) as u8;
                                  match e {
                                    Some(e) => {
                                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                                      let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid82, } = e;
                                      let (t83_0, t83_1, ) = ulid82;
                                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(t83_0);
                                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(t83_1);
                                      
                                    },
                                    None => {
                                      {
                                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                                        
                                      }
                                    },
                                  };
                                },
                              };
                              
                            },
                          };
                          
                          #[link(wasm_import_module = "ambient:bindings/component")]
                          extern "C" {
                            #[cfg_attr(target_arch = "wasm32", link_name = "set-component")]
                            #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_set-component")]
                            fn wit_import(
                            _: i32, );
                          }
                          wit_import(ptr0);
                          for (ptr, layout) in cleanup_list {
                            
                            if layout.size() != 0 {
                              
                              alloc::dealloc(ptr, layout);
                              
                            }
                            
                          }
                        }
                      }
                      #[allow(clippy::all)]
                      pub fn set_components(entity: EntityId,data: &Entity,){
                        
                        #[allow(unused_imports)]
                        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                        unsafe {
                          let mut cleanup_list = Vec::new();
                          let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                          let vec84 = data;
                          let len84 = vec84.len() as i32;
                          let layout84 = alloc::Layout::from_size_align_unchecked(vec84.len() * 96, 8);
                          let result84 = if layout84.size() != 0
                          {
                            let ptr = alloc::alloc(layout84);
                            if ptr.is_null()
                            {
                              alloc::handle_alloc_error(layout84);
                            }
                            ptr
                          }else {
                            ::core::ptr::null_mut()
                          };
                          for (i, e) in vec84.into_iter().enumerate() {
                            let base = result84 as i32 + (i as i32) * 96;
                            {
                              let (t1_0, t1_1, ) = e;
                              *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t1_0);
                              match t1_1 {
                                Value::TypeBool(e) => {
                                  *((base + 8) as *mut u8) = (0i32) as u8;
                                  *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                  
                                },
                                Value::TypeEntityId(e) => {
                                  *((base + 8) as *mut u8) = (1i32) as u8;
                                  let super::super::super::ambient::bindings::types::EntityId{ id0:id02, id1:id12, } = e;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id02);
                                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id12);
                                  
                                },
                                Value::TypeF32(e) => {
                                  *((base + 8) as *mut u8) = (2i32) as u8;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                  
                                },
                                Value::TypeF64(e) => {
                                  *((base + 8) as *mut u8) = (3i32) as u8;
                                  *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                  
                                },
                                Value::TypeMat4(e) => {
                                  *((base + 8) as *mut u8) = (4i32) as u8;
                                  let super::super::super::ambient::bindings::types::Mat4{ x:x3, y:y3, z:z3, w:w3, } = e;
                                  let super::super::super::ambient::bindings::types::Vec4{ x:x4, y:y4, z:z4, w:w4, } = x3;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x4);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y4);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z4);
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w4);
                                  let super::super::super::ambient::bindings::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = y3;
                                  *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                                  *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                                  *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                                  *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                                  let super::super::super::ambient::bindings::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = z3;
                                  *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                                  *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                                  *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                                  *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                                  let super::super::super::ambient::bindings::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = w3;
                                  *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                                  *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                                  *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                                  *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                                  
                                },
                                Value::TypeQuat(e) => {
                                  *((base + 8) as *mut u8) = (5i32) as u8;
                                  let super::super::super::ambient::bindings::types::Quat{ x:x8, y:y8, z:z8, w:w8, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                                  
                                },
                                Value::TypeString(e) => {
                                  *((base + 8) as *mut u8) = (6i32) as u8;
                                  let vec9 = e;
                                  let ptr9 = vec9.as_ptr() as i32;
                                  let len9 = vec9.len() as i32;
                                  *((base + 20) as *mut i32) = len9;
                                  *((base + 16) as *mut i32) = ptr9;
                                  
                                },
                                Value::TypeU8(e) => {
                                  *((base + 8) as *mut u8) = (7i32) as u8;
                                  *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                  
                                },
                                Value::TypeU16(e) => {
                                  *((base + 8) as *mut u8) = (8i32) as u8;
                                  *((base + 16) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                  
                                },
                                Value::TypeU32(e) => {
                                  *((base + 8) as *mut u8) = (9i32) as u8;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                  
                                },
                                Value::TypeU64(e) => {
                                  *((base + 8) as *mut u8) = (10i32) as u8;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                  
                                },
                                Value::TypeI8(e) => {
                                  *((base + 8) as *mut u8) = (11i32) as u8;
                                  *((base + 16) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                  
                                },
                                Value::TypeI16(e) => {
                                  *((base + 8) as *mut u8) = (12i32) as u8;
                                  *((base + 16) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                  
                                },
                                Value::TypeI32(e) => {
                                  *((base + 8) as *mut u8) = (13i32) as u8;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                  
                                },
                                Value::TypeI64(e) => {
                                  *((base + 8) as *mut u8) = (14i32) as u8;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                  
                                },
                                Value::TypeVec2(e) => {
                                  *((base + 8) as *mut u8) = (15i32) as u8;
                                  let super::super::super::ambient::bindings::types::Vec2{ x:x10, y:y10, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x10);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y10);
                                  
                                },
                                Value::TypeVec3(e) => {
                                  *((base + 8) as *mut u8) = (16i32) as u8;
                                  let super::super::super::ambient::bindings::types::Vec3{ x:x11, y:y11, z:z11, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z11);
                                  
                                },
                                Value::TypeVec4(e) => {
                                  *((base + 8) as *mut u8) = (17i32) as u8;
                                  let super::super::super::ambient::bindings::types::Vec4{ x:x12, y:y12, z:z12, w:w12, } = e;
                                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w12);
                                  
                                },
                                Value::TypeUvec2(e) => {
                                  *((base + 8) as *mut u8) = (18i32) as u8;
                                  let super::super::super::ambient::bindings::types::Uvec2{ x:x13, y:y13, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x13);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y13);
                                  
                                },
                                Value::TypeUvec3(e) => {
                                  *((base + 8) as *mut u8) = (19i32) as u8;
                                  let super::super::super::ambient::bindings::types::Uvec3{ x:x14, y:y14, z:z14, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x14);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y14);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z14);
                                  
                                },
                                Value::TypeUvec4(e) => {
                                  *((base + 8) as *mut u8) = (20i32) as u8;
                                  let super::super::super::ambient::bindings::types::Uvec4{ x:x15, y:y15, z:z15, w:w15, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x15);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y15);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z15);
                                  *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w15);
                                  
                                },
                                Value::TypeIvec2(e) => {
                                  *((base + 8) as *mut u8) = (21i32) as u8;
                                  let super::super::super::ambient::bindings::types::Ivec2{ x:x16, y:y16, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x16);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y16);
                                  
                                },
                                Value::TypeIvec3(e) => {
                                  *((base + 8) as *mut u8) = (22i32) as u8;
                                  let super::super::super::ambient::bindings::types::Ivec3{ x:x17, y:y17, z:z17, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x17);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y17);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z17);
                                  
                                },
                                Value::TypeIvec4(e) => {
                                  *((base + 8) as *mut u8) = (23i32) as u8;
                                  let super::super::super::ambient::bindings::types::Ivec4{ x:x18, y:y18, z:z18, w:w18, } = e;
                                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(x18);
                                  *((base + 20) as *mut i32) = wit_bindgen::rt::as_i32(y18);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(z18);
                                  *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(w18);
                                  
                                },
                                Value::TypeDuration(e) => {
                                  *((base + 8) as *mut u8) = (24i32) as u8;
                                  let super::super::super::ambient::bindings::types::Duration{ seconds:seconds19, nanoseconds:nanoseconds19, } = e;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(seconds19);
                                  *((base + 24) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds19);
                                  
                                },
                                Value::TypeProceduralMeshHandle(e) => {
                                  *((base + 8) as *mut u8) = (25i32) as u8;
                                  let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid20, } = e;
                                  let (t21_0, t21_1, ) = ulid20;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t21_0);
                                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t21_1);
                                  
                                },
                                Value::TypeProceduralTextureHandle(e) => {
                                  *((base + 8) as *mut u8) = (26i32) as u8;
                                  let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid22, } = e;
                                  let (t23_0, t23_1, ) = ulid22;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t23_0);
                                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t23_1);
                                  
                                },
                                Value::TypeProceduralSamplerHandle(e) => {
                                  *((base + 8) as *mut u8) = (27i32) as u8;
                                  let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid24, } = e;
                                  let (t25_0, t25_1, ) = ulid24;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t25_0);
                                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t25_1);
                                  
                                },
                                Value::TypeProceduralMaterialHandle(e) => {
                                  *((base + 8) as *mut u8) = (28i32) as u8;
                                  let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid26, } = e;
                                  let (t27_0, t27_1, ) = ulid26;
                                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(t27_0);
                                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(t27_1);
                                  
                                },
                                Value::TypeVec(e) => {
                                  *((base + 8) as *mut u8) = (29i32) as u8;
                                  match e {
                                    VecValue::TypeBool(e) => {
                                      *((base + 16) as *mut u8) = (0i32) as u8;
                                      let vec28 = e;
                                      let len28 = vec28.len() as i32;
                                      let layout28 = alloc::Layout::from_size_align_unchecked(vec28.len() * 1, 1);
                                      let result28 = if layout28.size() != 0
                                      {
                                        let ptr = alloc::alloc(layout28);
                                        if ptr.is_null()
                                        {
                                          alloc::handle_alloc_error(layout28);
                                        }
                                        ptr
                                      }else {
                                        ::core::ptr::null_mut()
                                      };
                                      for (i, e) in vec28.into_iter().enumerate() {
                                        let base = result28 as i32 + (i as i32) * 1;
                                        {
                                          *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                          
                                        }}
                                        *((base + 24) as *mut i32) = len28;
                                        *((base + 20) as *mut i32) = result28 as i32;
                                        cleanup_list.extend_from_slice(&[(result28, layout28),]);
                                        
                                      },
                                      VecValue::TypeEntityId(e) => {
                                        *((base + 16) as *mut u8) = (1i32) as u8;
                                        let vec29 = e;
                                        let ptr29 = vec29.as_ptr() as i32;
                                        let len29 = vec29.len() as i32;
                                        *((base + 24) as *mut i32) = len29;
                                        *((base + 20) as *mut i32) = ptr29;
                                        
                                      },
                                      VecValue::TypeF32(e) => {
                                        *((base + 16) as *mut u8) = (2i32) as u8;
                                        let vec30 = e;
                                        let ptr30 = vec30.as_ptr() as i32;
                                        let len30 = vec30.len() as i32;
                                        *((base + 24) as *mut i32) = len30;
                                        *((base + 20) as *mut i32) = ptr30;
                                        
                                      },
                                      VecValue::TypeF64(e) => {
                                        *((base + 16) as *mut u8) = (3i32) as u8;
                                        let vec31 = e;
                                        let ptr31 = vec31.as_ptr() as i32;
                                        let len31 = vec31.len() as i32;
                                        *((base + 24) as *mut i32) = len31;
                                        *((base + 20) as *mut i32) = ptr31;
                                        
                                      },
                                      VecValue::TypeMat4(e) => {
                                        *((base + 16) as *mut u8) = (4i32) as u8;
                                        let vec32 = e;
                                        let ptr32 = vec32.as_ptr() as i32;
                                        let len32 = vec32.len() as i32;
                                        *((base + 24) as *mut i32) = len32;
                                        *((base + 20) as *mut i32) = ptr32;
                                        
                                      },
                                      VecValue::TypeQuat(e) => {
                                        *((base + 16) as *mut u8) = (5i32) as u8;
                                        let vec33 = e;
                                        let ptr33 = vec33.as_ptr() as i32;
                                        let len33 = vec33.len() as i32;
                                        *((base + 24) as *mut i32) = len33;
                                        *((base + 20) as *mut i32) = ptr33;
                                        
                                      },
                                      VecValue::TypeString(e) => {
                                        *((base + 16) as *mut u8) = (6i32) as u8;
                                        let vec35 = e;
                                        let len35 = vec35.len() as i32;
                                        let layout35 = alloc::Layout::from_size_align_unchecked(vec35.len() * 8, 4);
                                        let result35 = if layout35.size() != 0
                                        {
                                          let ptr = alloc::alloc(layout35);
                                          if ptr.is_null()
                                          {
                                            alloc::handle_alloc_error(layout35);
                                          }
                                          ptr
                                        }else {
                                          ::core::ptr::null_mut()
                                        };
                                        for (i, e) in vec35.into_iter().enumerate() {
                                          let base = result35 as i32 + (i as i32) * 8;
                                          {
                                            let vec34 = e;
                                            let ptr34 = vec34.as_ptr() as i32;
                                            let len34 = vec34.len() as i32;
                                            *((base + 4) as *mut i32) = len34;
                                            *((base + 0) as *mut i32) = ptr34;
                                            
                                          }}
                                          *((base + 24) as *mut i32) = len35;
                                          *((base + 20) as *mut i32) = result35 as i32;
                                          cleanup_list.extend_from_slice(&[(result35, layout35),]);
                                          
                                        },
                                        VecValue::TypeU8(e) => {
                                          *((base + 16) as *mut u8) = (7i32) as u8;
                                          let vec36 = e;
                                          let ptr36 = vec36.as_ptr() as i32;
                                          let len36 = vec36.len() as i32;
                                          *((base + 24) as *mut i32) = len36;
                                          *((base + 20) as *mut i32) = ptr36;
                                          
                                        },
                                        VecValue::TypeU16(e) => {
                                          *((base + 16) as *mut u8) = (8i32) as u8;
                                          let vec37 = e;
                                          let ptr37 = vec37.as_ptr() as i32;
                                          let len37 = vec37.len() as i32;
                                          *((base + 24) as *mut i32) = len37;
                                          *((base + 20) as *mut i32) = ptr37;
                                          
                                        },
                                        VecValue::TypeU32(e) => {
                                          *((base + 16) as *mut u8) = (9i32) as u8;
                                          let vec38 = e;
                                          let ptr38 = vec38.as_ptr() as i32;
                                          let len38 = vec38.len() as i32;
                                          *((base + 24) as *mut i32) = len38;
                                          *((base + 20) as *mut i32) = ptr38;
                                          
                                        },
                                        VecValue::TypeU64(e) => {
                                          *((base + 16) as *mut u8) = (10i32) as u8;
                                          let vec39 = e;
                                          let ptr39 = vec39.as_ptr() as i32;
                                          let len39 = vec39.len() as i32;
                                          *((base + 24) as *mut i32) = len39;
                                          *((base + 20) as *mut i32) = ptr39;
                                          
                                        },
                                        VecValue::TypeI8(e) => {
                                          *((base + 16) as *mut u8) = (11i32) as u8;
                                          let vec40 = e;
                                          let ptr40 = vec40.as_ptr() as i32;
                                          let len40 = vec40.len() as i32;
                                          *((base + 24) as *mut i32) = len40;
                                          *((base + 20) as *mut i32) = ptr40;
                                          
                                        },
                                        VecValue::TypeI16(e) => {
                                          *((base + 16) as *mut u8) = (12i32) as u8;
                                          let vec41 = e;
                                          let ptr41 = vec41.as_ptr() as i32;
                                          let len41 = vec41.len() as i32;
                                          *((base + 24) as *mut i32) = len41;
                                          *((base + 20) as *mut i32) = ptr41;
                                          
                                        },
                                        VecValue::TypeI32(e) => {
                                          *((base + 16) as *mut u8) = (13i32) as u8;
                                          let vec42 = e;
                                          let ptr42 = vec42.as_ptr() as i32;
                                          let len42 = vec42.len() as i32;
                                          *((base + 24) as *mut i32) = len42;
                                          *((base + 20) as *mut i32) = ptr42;
                                          
                                        },
                                        VecValue::TypeI64(e) => {
                                          *((base + 16) as *mut u8) = (14i32) as u8;
                                          let vec43 = e;
                                          let ptr43 = vec43.as_ptr() as i32;
                                          let len43 = vec43.len() as i32;
                                          *((base + 24) as *mut i32) = len43;
                                          *((base + 20) as *mut i32) = ptr43;
                                          
                                        },
                                        VecValue::TypeVec2(e) => {
                                          *((base + 16) as *mut u8) = (15i32) as u8;
                                          let vec44 = e;
                                          let ptr44 = vec44.as_ptr() as i32;
                                          let len44 = vec44.len() as i32;
                                          *((base + 24) as *mut i32) = len44;
                                          *((base + 20) as *mut i32) = ptr44;
                                          
                                        },
                                        VecValue::TypeVec3(e) => {
                                          *((base + 16) as *mut u8) = (16i32) as u8;
                                          let vec45 = e;
                                          let ptr45 = vec45.as_ptr() as i32;
                                          let len45 = vec45.len() as i32;
                                          *((base + 24) as *mut i32) = len45;
                                          *((base + 20) as *mut i32) = ptr45;
                                          
                                        },
                                        VecValue::TypeVec4(e) => {
                                          *((base + 16) as *mut u8) = (17i32) as u8;
                                          let vec46 = e;
                                          let ptr46 = vec46.as_ptr() as i32;
                                          let len46 = vec46.len() as i32;
                                          *((base + 24) as *mut i32) = len46;
                                          *((base + 20) as *mut i32) = ptr46;
                                          
                                        },
                                        VecValue::TypeUvec2(e) => {
                                          *((base + 16) as *mut u8) = (18i32) as u8;
                                          let vec47 = e;
                                          let ptr47 = vec47.as_ptr() as i32;
                                          let len47 = vec47.len() as i32;
                                          *((base + 24) as *mut i32) = len47;
                                          *((base + 20) as *mut i32) = ptr47;
                                          
                                        },
                                        VecValue::TypeUvec3(e) => {
                                          *((base + 16) as *mut u8) = (19i32) as u8;
                                          let vec48 = e;
                                          let ptr48 = vec48.as_ptr() as i32;
                                          let len48 = vec48.len() as i32;
                                          *((base + 24) as *mut i32) = len48;
                                          *((base + 20) as *mut i32) = ptr48;
                                          
                                        },
                                        VecValue::TypeUvec4(e) => {
                                          *((base + 16) as *mut u8) = (20i32) as u8;
                                          let vec49 = e;
                                          let ptr49 = vec49.as_ptr() as i32;
                                          let len49 = vec49.len() as i32;
                                          *((base + 24) as *mut i32) = len49;
                                          *((base + 20) as *mut i32) = ptr49;
                                          
                                        },
                                        VecValue::TypeIvec2(e) => {
                                          *((base + 16) as *mut u8) = (21i32) as u8;
                                          let vec50 = e;
                                          let ptr50 = vec50.as_ptr() as i32;
                                          let len50 = vec50.len() as i32;
                                          *((base + 24) as *mut i32) = len50;
                                          *((base + 20) as *mut i32) = ptr50;
                                          
                                        },
                                        VecValue::TypeIvec3(e) => {
                                          *((base + 16) as *mut u8) = (22i32) as u8;
                                          let vec51 = e;
                                          let ptr51 = vec51.as_ptr() as i32;
                                          let len51 = vec51.len() as i32;
                                          *((base + 24) as *mut i32) = len51;
                                          *((base + 20) as *mut i32) = ptr51;
                                          
                                        },
                                        VecValue::TypeIvec4(e) => {
                                          *((base + 16) as *mut u8) = (23i32) as u8;
                                          let vec52 = e;
                                          let ptr52 = vec52.as_ptr() as i32;
                                          let len52 = vec52.len() as i32;
                                          *((base + 24) as *mut i32) = len52;
                                          *((base + 20) as *mut i32) = ptr52;
                                          
                                        },
                                        VecValue::TypeDuration(e) => {
                                          *((base + 16) as *mut u8) = (24i32) as u8;
                                          let vec53 = e;
                                          let ptr53 = vec53.as_ptr() as i32;
                                          let len53 = vec53.len() as i32;
                                          *((base + 24) as *mut i32) = len53;
                                          *((base + 20) as *mut i32) = ptr53;
                                          
                                        },
                                        VecValue::TypeProceduralMeshHandle(e) => {
                                          *((base + 16) as *mut u8) = (25i32) as u8;
                                          let vec54 = e;
                                          let ptr54 = vec54.as_ptr() as i32;
                                          let len54 = vec54.len() as i32;
                                          *((base + 24) as *mut i32) = len54;
                                          *((base + 20) as *mut i32) = ptr54;
                                          
                                        },
                                        VecValue::TypeProceduralTextureHandle(e) => {
                                          *((base + 16) as *mut u8) = (26i32) as u8;
                                          let vec55 = e;
                                          let ptr55 = vec55.as_ptr() as i32;
                                          let len55 = vec55.len() as i32;
                                          *((base + 24) as *mut i32) = len55;
                                          *((base + 20) as *mut i32) = ptr55;
                                          
                                        },
                                        VecValue::TypeProceduralSamplerHandle(e) => {
                                          *((base + 16) as *mut u8) = (27i32) as u8;
                                          let vec56 = e;
                                          let ptr56 = vec56.as_ptr() as i32;
                                          let len56 = vec56.len() as i32;
                                          *((base + 24) as *mut i32) = len56;
                                          *((base + 20) as *mut i32) = ptr56;
                                          
                                        },
                                        VecValue::TypeProceduralMaterialHandle(e) => {
                                          *((base + 16) as *mut u8) = (28i32) as u8;
                                          let vec57 = e;
                                          let ptr57 = vec57.as_ptr() as i32;
                                          let len57 = vec57.len() as i32;
                                          *((base + 24) as *mut i32) = len57;
                                          *((base + 20) as *mut i32) = ptr57;
                                          
                                        },
                                      };
                                      
                                    },
                                    Value::TypeOption(e) => {
                                      *((base + 8) as *mut u8) = (30i32) as u8;
                                      match e {
                                        OptionValue::TypeBool(e) => {
                                          *((base + 16) as *mut u8) = (0i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeEntityId(e) => {
                                          *((base + 16) as *mut u8) = (1i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::EntityId{ id0:id058, id1:id158, } = e;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id058);
                                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id158);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeF32(e) => {
                                          *((base + 16) as *mut u8) = (2i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeF64(e) => {
                                          *((base + 16) as *mut u8) = (3i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeMat4(e) => {
                                          *((base + 16) as *mut u8) = (4i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Mat4{ x:x59, y:y59, z:z59, w:w59, } = e;
                                              let super::super::super::ambient::bindings::types::Vec4{ x:x60, y:y60, z:z60, w:w60, } = x59;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x60);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y60);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z60);
                                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w60);
                                              let super::super::super::ambient::bindings::types::Vec4{ x:x61, y:y61, z:z61, w:w61, } = y59;
                                              *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x61);
                                              *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y61);
                                              *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z61);
                                              *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w61);
                                              let super::super::super::ambient::bindings::types::Vec4{ x:x62, y:y62, z:z62, w:w62, } = z59;
                                              *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x62);
                                              *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y62);
                                              *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z62);
                                              *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w62);
                                              let super::super::super::ambient::bindings::types::Vec4{ x:x63, y:y63, z:z63, w:w63, } = w59;
                                              *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x63);
                                              *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y63);
                                              *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z63);
                                              *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w63);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeQuat(e) => {
                                          *((base + 16) as *mut u8) = (5i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Quat{ x:x64, y:y64, z:z64, w:w64, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x64);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y64);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z64);
                                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w64);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeString(e) => {
                                          *((base + 16) as *mut u8) = (6i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let vec65 = e;
                                              let ptr65 = vec65.as_ptr() as i32;
                                              let len65 = vec65.len() as i32;
                                              *((base + 32) as *mut i32) = len65;
                                              *((base + 28) as *mut i32) = ptr65;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeU8(e) => {
                                          *((base + 16) as *mut u8) = (7i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeU16(e) => {
                                          *((base + 16) as *mut u8) = (8i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 26) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeU32(e) => {
                                          *((base + 16) as *mut u8) = (9i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeU64(e) => {
                                          *((base + 16) as *mut u8) = (10i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeI8(e) => {
                                          *((base + 16) as *mut u8) = (11i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 25) as *mut u8) = (wit_bindgen::rt::as_i32(e)) as u8;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeI16(e) => {
                                          *((base + 16) as *mut u8) = (12i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 26) as *mut u16) = (wit_bindgen::rt::as_i32(e)) as u16;
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeI32(e) => {
                                          *((base + 16) as *mut u8) = (13i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeI64(e) => {
                                          *((base + 16) as *mut u8) = (14i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeVec2(e) => {
                                          *((base + 16) as *mut u8) = (15i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Vec2{ x:x66, y:y66, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x66);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y66);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeVec3(e) => {
                                          *((base + 16) as *mut u8) = (16i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Vec3{ x:x67, y:y67, z:z67, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x67);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y67);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z67);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeVec4(e) => {
                                          *((base + 16) as *mut u8) = (17i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Vec4{ x:x68, y:y68, z:z68, w:w68, } = e;
                                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x68);
                                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y68);
                                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z68);
                                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w68);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeUvec2(e) => {
                                          *((base + 16) as *mut u8) = (18i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Uvec2{ x:x69, y:y69, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x69);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y69);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeUvec3(e) => {
                                          *((base + 16) as *mut u8) = (19i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Uvec3{ x:x70, y:y70, z:z70, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x70);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y70);
                                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z70);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeUvec4(e) => {
                                          *((base + 16) as *mut u8) = (20i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Uvec4{ x:x71, y:y71, z:z71, w:w71, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x71);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y71);
                                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z71);
                                              *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w71);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeIvec2(e) => {
                                          *((base + 16) as *mut u8) = (21i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Ivec2{ x:x72, y:y72, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x72);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y72);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeIvec3(e) => {
                                          *((base + 16) as *mut u8) = (22i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Ivec3{ x:x73, y:y73, z:z73, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x73);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y73);
                                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z73);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeIvec4(e) => {
                                          *((base + 16) as *mut u8) = (23i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Ivec4{ x:x74, y:y74, z:z74, w:w74, } = e;
                                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(x74);
                                              *((base + 32) as *mut i32) = wit_bindgen::rt::as_i32(y74);
                                              *((base + 36) as *mut i32) = wit_bindgen::rt::as_i32(z74);
                                              *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(w74);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeDuration(e) => {
                                          *((base + 16) as *mut u8) = (24i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::types::Duration{ seconds:seconds75, nanoseconds:nanoseconds75, } = e;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(seconds75);
                                              *((base + 40) as *mut i32) = wit_bindgen::rt::as_i32(nanoseconds75);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeProceduralMeshHandle(e) => {
                                          *((base + 16) as *mut u8) = (25i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::client_mesh::Handle{ ulid:ulid76, } = e;
                                              let (t77_0, t77_1, ) = ulid76;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t77_0);
                                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t77_1);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeProceduralTextureHandle(e) => {
                                          *((base + 16) as *mut u8) = (26i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::client_texture::Handle{ ulid:ulid78, } = e;
                                              let (t79_0, t79_1, ) = ulid78;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t79_0);
                                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t79_1);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeProceduralSamplerHandle(e) => {
                                          *((base + 16) as *mut u8) = (27i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::client_sampler::Handle{ ulid:ulid80, } = e;
                                              let (t81_0, t81_1, ) = ulid80;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t81_0);
                                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t81_1);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                        OptionValue::TypeProceduralMaterialHandle(e) => {
                                          *((base + 16) as *mut u8) = (28i32) as u8;
                                          match e {
                                            Some(e) => {
                                              *((base + 24) as *mut u8) = (1i32) as u8;
                                              let super::super::super::ambient::bindings::client_material::Handle{ ulid:ulid82, } = e;
                                              let (t83_0, t83_1, ) = ulid82;
                                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(t83_0);
                                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(t83_1);
                                              
                                            },
                                            None => {
                                              {
                                                *((base + 24) as *mut u8) = (0i32) as u8;
                                                
                                              }
                                            },
                                          };
                                        },
                                      };
                                      
                                    },
                                  };
                                  
                                }}
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "set-components")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_set-components")]
                                  fn wit_import(
                                  _: i64, _: i64, _: i32, _: i32, );
                                }
                                wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), result84 as i32, len84);
                                if layout84.size() != 0 {
                                  alloc::dealloc(result84, layout84);
                                }
                                for (ptr, layout) in cleanup_list {
                                  
                                  if layout.size() != 0 {
                                    
                                    alloc::dealloc(ptr, layout);
                                    
                                  }
                                  
                                }
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn has_component(entity: EntityId,index: u32,) -> bool{
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "has-component")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_has-component")]
                                  fn wit_import(
                                  _: i64, _: i64, _: i32, ) -> i32;
                                }
                                let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index));
                                {
                                  #[cfg(not(debug_assertions))]
                                  { ::core::mem::transmute::<u8, bool>(ret as u8) }
                                  #[cfg(debug_assertions)]
                                  {
                                    match ret {
                                      0 => false,
                                      1 => true,
                                      _ => panic!("invalid bool discriminant"),
                                    }
                                  }
                                }
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn has_components(entity: EntityId,indices: &[u32],) -> bool{
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                let vec1 = indices;
                                let ptr1 = vec1.as_ptr() as i32;
                                let len1 = vec1.len() as i32;
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "has-components")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_has-components")]
                                  fn wit_import(
                                  _: i64, _: i64, _: i32, _: i32, ) -> i32;
                                }
                                let ret = wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1, len1);
                                {
                                  #[cfg(not(debug_assertions))]
                                  { ::core::mem::transmute::<u8, bool>(ret as u8) }
                                  #[cfg(debug_assertions)]
                                  {
                                    match ret {
                                      0 => false,
                                      1 => true,
                                      _ => panic!("invalid bool discriminant"),
                                    }
                                  }
                                }
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn remove_component(entity: EntityId,index: u32,){
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "remove-component")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_remove-component")]
                                  fn wit_import(
                                  _: i64, _: i64, _: i32, );
                                }
                                wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index));
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn remove_components(entity: EntityId,indices: &[u32],){
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let super::super::super::ambient::bindings::types::EntityId{ id0:id00, id1:id10, } = entity;
                                let vec1 = indices;
                                let ptr1 = vec1.as_ptr() as i32;
                                let len1 = vec1.len() as i32;
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "remove-components")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_remove-components")]
                                  fn wit_import(
                                  _: i64, _: i64, _: i32, _: i32, );
                                }
                                wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), ptr1, len1);
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn query(q: &QueryBuild,t: QueryEvent,) -> u64{
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                let QueryBuild{ components:components0, includes:includes0, excludes:excludes0, changed:changed0, } = q;
                                let vec1 = components0;
                                let ptr1 = vec1.as_ptr() as i32;
                                let len1 = vec1.len() as i32;
                                let vec2 = includes0;
                                let ptr2 = vec2.as_ptr() as i32;
                                let len2 = vec2.len() as i32;
                                let vec3 = excludes0;
                                let ptr3 = vec3.as_ptr() as i32;
                                let len3 = vec3.len() as i32;
                                let vec4 = changed0;
                                let ptr4 = vec4.as_ptr() as i32;
                                let len4 = vec4.len() as i32;
                                
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "query")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_query")]
                                  fn wit_import(
                                  _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ) -> i64;
                                }
                                let ret = wit_import(ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4, match t {
                                  QueryEvent::Frame => 0,
                                  QueryEvent::Spawn => 1,
                                  QueryEvent::Despawn => 2,
                                });
                                ret as u64
                              }
                            }
                            #[allow(clippy::all)]
                            pub fn query_eval(q: u64,) -> wit_bindgen::rt::vec::Vec::<(EntityId,wit_bindgen::rt::vec::Vec::<Value>,)>{
                              
                              #[allow(unused_imports)]
                              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
                              unsafe {
                                
                                #[repr(align(4))]
                                struct RetArea([u8; 8]);
                                let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
                                let ptr0 = ret_area.as_mut_ptr() as i32;
                                #[link(wasm_import_module = "ambient:bindings/component")]
                                extern "C" {
                                  #[cfg_attr(target_arch = "wasm32", link_name = "query-eval")]
                                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "ambient:bindings/component_query-eval")]
                                  fn wit_import(
                                  _: i64, _: i32, );
                                }
                                wit_import(wit_bindgen::rt::as_i64(q), ptr0);
                                let base34 = *((ptr0 + 0) as *const i32);
                                let len34 = *((ptr0 + 4) as *const i32);
                                let mut result34 = Vec::with_capacity(len34 as usize);
                                for i in 0..len34 {
                                  let base = base34 + i *24;
                                  result34.push({
                                    let base33 = *((base + 16) as *const i32);
                                    let len33 = *((base + 20) as *const i32);
                                    let mut result33 = Vec::with_capacity(len33 as usize);
                                    for i in 0..len33 {
                                      let base = base33 + i *88;
                                      result33.push({{match i32::from(*((base + 0) as *const u8)) {
                                        0 => Value::TypeBool({
                                          #[cfg(not(debug_assertions))]
                                          { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 8) as *const u8)) as u8) }
                                          #[cfg(debug_assertions)]
                                          {
                                            match i32::from(*((base + 8) as *const u8)) {
                                              0 => false,
                                              1 => true,
                                              _ => panic!("invalid bool discriminant"),
                                            }
                                          }
                                        }),
                                        1 => Value::TypeEntityId(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 8) as *const i64) as u64, id1:*((base + 16) as *const i64) as u64, }),
                                        2 => Value::TypeF32(*((base + 8) as *const f32)),
                                        3 => Value::TypeF64(*((base + 8) as *const f64)),
                                        4 => Value::TypeMat4(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 24) as *const f32), y:*((base + 28) as *const f32), z:*((base + 32) as *const f32), w:*((base + 36) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 40) as *const f32), y:*((base + 44) as *const f32), z:*((base + 48) as *const f32), w:*((base + 52) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 56) as *const f32), y:*((base + 60) as *const f32), z:*((base + 64) as *const f32), w:*((base + 68) as *const f32), }, }),
                                        5 => Value::TypeQuat(super::super::super::ambient::bindings::types::Quat{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }),
                                        6 => Value::TypeString({
                                          let len1 = *((base + 12) as *const i32) as usize;
                                          
                                          {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len1, len1))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 8) as *const i32) as *mut _, len1, len1)).unwrap()}}
                                        }),
                                        7 => Value::TypeU8(i32::from(*((base + 8) as *const u8)) as u8),
                                        8 => Value::TypeU16(i32::from(*((base + 8) as *const u16)) as u16),
                                        9 => Value::TypeU32(*((base + 8) as *const i32) as u32),
                                        10 => Value::TypeU64(*((base + 8) as *const i64) as u64),
                                        11 => Value::TypeI8(i32::from(*((base + 8) as *const i8)) as i8),
                                        12 => Value::TypeI16(i32::from(*((base + 8) as *const i16)) as i16),
                                        13 => Value::TypeI32(*((base + 8) as *const i32)),
                                        14 => Value::TypeI64(*((base + 8) as *const i64)),
                                        15 => Value::TypeVec2(super::super::super::ambient::bindings::types::Vec2{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), }),
                                        16 => Value::TypeVec3(super::super::super::ambient::bindings::types::Vec3{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), }),
                                        17 => Value::TypeVec4(super::super::super::ambient::bindings::types::Vec4{x:*((base + 8) as *const f32), y:*((base + 12) as *const f32), z:*((base + 16) as *const f32), w:*((base + 20) as *const f32), }),
                                        18 => Value::TypeUvec2(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, }),
                                        19 => Value::TypeUvec3(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, z:*((base + 16) as *const i32) as u32, }),
                                        20 => Value::TypeUvec4(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 8) as *const i32) as u32, y:*((base + 12) as *const i32) as u32, z:*((base + 16) as *const i32) as u32, w:*((base + 20) as *const i32) as u32, }),
                                        21 => Value::TypeIvec2(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 8) as *const i32), y:*((base + 12) as *const i32), }),
                                        22 => Value::TypeIvec3(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 8) as *const i32), y:*((base + 12) as *const i32), z:*((base + 16) as *const i32), }),
                                        23 => Value::TypeIvec4(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 8) as *const i32), y:*((base + 12) as *const i32), z:*((base + 16) as *const i32), w:*((base + 20) as *const i32), }),
                                        24 => Value::TypeDuration(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 8) as *const i64) as u64, nanoseconds:*((base + 16) as *const i32) as u32, }),
                                        25 => Value::TypeProceduralMeshHandle(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                        26 => Value::TypeProceduralTextureHandle(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                        27 => Value::TypeProceduralSamplerHandle(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                        28 => Value::TypeProceduralMaterialHandle(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 8) as *const i64) as u64, *((base + 16) as *const i64) as u64), }),
                                        29 => Value::TypeVec({{match i32::from(*((base + 8) as *const u8)) {
                                          0 => VecValue::TypeBool({
                                            let base2 = *((base + 12) as *const i32);
                                            let len2 = *((base + 16) as *const i32);
                                            let mut result2 = Vec::with_capacity(len2 as usize);
                                            for i in 0..len2 {
                                              let base = base2 + i *1;
                                              result2.push({
                                                #[cfg(not(debug_assertions))]
                                                { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                                                #[cfg(debug_assertions)]
                                                {
                                                  match i32::from(*((base + 0) as *const u8)) {
                                                    0 => false,
                                                    1 => true,
                                                    _ => panic!("invalid bool discriminant"),
                                                  }
                                                }
                                              });
                                            }
                                            wit_bindgen::rt::dealloc(base2, (len2 as usize) * 1, 1);
                                            
                                            result2
                                          }),
                                          1 => VecValue::TypeEntityId({
                                            let len3 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len3, len3)
                                          }),
                                          2 => VecValue::TypeF32({
                                            let len4 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len4, len4)
                                          }),
                                          3 => VecValue::TypeF64({
                                            let len5 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len5, len5)
                                          }),
                                          4 => VecValue::TypeMat4({
                                            let len6 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len6, len6)
                                          }),
                                          5 => VecValue::TypeQuat({
                                            let len7 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len7, len7)
                                          }),
                                          6 => VecValue::TypeString({
                                            let base9 = *((base + 12) as *const i32);
                                            let len9 = *((base + 16) as *const i32);
                                            let mut result9 = Vec::with_capacity(len9 as usize);
                                            for i in 0..len9 {
                                              let base = base9 + i *8;
                                              result9.push({
                                                let len8 = *((base + 4) as *const i32) as usize;
                                                
                                                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len8, len8))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len8, len8)).unwrap()}}
                                              });
                                            }
                                            wit_bindgen::rt::dealloc(base9, (len9 as usize) * 8, 4);
                                            
                                            result9
                                          }),
                                          7 => VecValue::TypeU8({
                                            let len10 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len10, len10)
                                          }),
                                          8 => VecValue::TypeU16({
                                            let len11 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len11, len11)
                                          }),
                                          9 => VecValue::TypeU32({
                                            let len12 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len12, len12)
                                          }),
                                          10 => VecValue::TypeU64({
                                            let len13 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len13, len13)
                                          }),
                                          11 => VecValue::TypeI8({
                                            let len14 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len14, len14)
                                          }),
                                          12 => VecValue::TypeI16({
                                            let len15 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len15, len15)
                                          }),
                                          13 => VecValue::TypeI32({
                                            let len16 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len16, len16)
                                          }),
                                          14 => VecValue::TypeI64({
                                            let len17 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len17, len17)
                                          }),
                                          15 => VecValue::TypeVec2({
                                            let len18 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len18, len18)
                                          }),
                                          16 => VecValue::TypeVec3({
                                            let len19 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len19, len19)
                                          }),
                                          17 => VecValue::TypeVec4({
                                            let len20 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len20, len20)
                                          }),
                                          18 => VecValue::TypeUvec2({
                                            let len21 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len21, len21)
                                          }),
                                          19 => VecValue::TypeUvec3({
                                            let len22 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len22, len22)
                                          }),
                                          20 => VecValue::TypeUvec4({
                                            let len23 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len23, len23)
                                          }),
                                          21 => VecValue::TypeIvec2({
                                            let len24 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len24, len24)
                                          }),
                                          22 => VecValue::TypeIvec3({
                                            let len25 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len25, len25)
                                          }),
                                          23 => VecValue::TypeIvec4({
                                            let len26 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len26, len26)
                                          }),
                                          24 => VecValue::TypeDuration({
                                            let len27 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len27, len27)
                                          }),
                                          25 => VecValue::TypeProceduralMeshHandle({
                                            let len28 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len28, len28)
                                          }),
                                          26 => VecValue::TypeProceduralTextureHandle({
                                            let len29 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len29, len29)
                                          }),
                                          27 => VecValue::TypeProceduralSamplerHandle({
                                            let len30 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len30, len30)
                                          }),
                                          #[cfg(debug_assertions)]28 => VecValue::TypeProceduralMaterialHandle({
                                            let len31 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len31, len31)
                                          }),
                                          #[cfg(not(debug_assertions))]_ => VecValue::TypeProceduralMaterialHandle({
                                            let len31 = *((base + 16) as *const i32) as usize;
                                            
                                            Vec::from_raw_parts(*((base + 12) as *const i32) as *mut _, len31, len31)
                                          }),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}}),
                                        #[cfg(debug_assertions)]30 => Value::TypeOption({{match i32::from(*((base + 8) as *const u8)) {
                                          0 => OptionValue::TypeBool(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some({
                                              #[cfg(not(debug_assertions))]
                                              { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 17) as *const u8)) as u8) }
                                              #[cfg(debug_assertions)]
                                              {
                                                match i32::from(*((base + 17) as *const u8)) {
                                                  0 => false,
                                                  1 => true,
                                                  _ => panic!("invalid bool discriminant"),
                                                }
                                              }
                                            }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          1 => OptionValue::TypeEntityId(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 24) as *const i64) as u64, id1:*((base + 32) as *const i64) as u64, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          2 => OptionValue::TypeF32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const f32)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          3 => OptionValue::TypeF64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const f64)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          4 => OptionValue::TypeMat4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 36) as *const f32), y:*((base + 40) as *const f32), z:*((base + 44) as *const f32), w:*((base + 48) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 52) as *const f32), y:*((base + 56) as *const f32), z:*((base + 60) as *const f32), w:*((base + 64) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 68) as *const f32), y:*((base + 72) as *const f32), z:*((base + 76) as *const f32), w:*((base + 80) as *const f32), }, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          5 => OptionValue::TypeQuat(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          6 => OptionValue::TypeString(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some({
                                              let len32 = *((base + 24) as *const i32) as usize;
                                              
                                              {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len32, len32))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len32, len32)).unwrap()}}
                                            }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          7 => OptionValue::TypeU8(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 17) as *const u8)) as u8),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          8 => OptionValue::TypeU16(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 18) as *const u16)) as u16),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          9 => OptionValue::TypeU32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const i32) as u32),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          10 => OptionValue::TypeU64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const i64) as u64),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          11 => OptionValue::TypeI8(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 17) as *const i8)) as i8),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          12 => OptionValue::TypeI16(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 18) as *const i16)) as i16),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          13 => OptionValue::TypeI32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const i32)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          14 => OptionValue::TypeI64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const i64)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          15 => OptionValue::TypeVec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          16 => OptionValue::TypeVec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          17 => OptionValue::TypeVec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          18 => OptionValue::TypeUvec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          19 => OptionValue::TypeUvec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          20 => OptionValue::TypeUvec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, w:*((base + 32) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          21 => OptionValue::TypeIvec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          22 => OptionValue::TypeIvec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), z:*((base + 28) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          23 => OptionValue::TypeIvec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), z:*((base + 28) as *const i32), w:*((base + 32) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          24 => OptionValue::TypeDuration(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 24) as *const i64) as u64, nanoseconds:*((base + 32) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          25 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          26 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          27 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(debug_assertions)]28 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}}),
                                        #[cfg(not(debug_assertions))]_ => Value::TypeOption({{match i32::from(*((base + 8) as *const u8)) {
                                          0 => OptionValue::TypeBool(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some({
                                              #[cfg(not(debug_assertions))]
                                              { ::core::mem::transmute::<u8, bool>(i32::from(*((base + 17) as *const u8)) as u8) }
                                              #[cfg(debug_assertions)]
                                              {
                                                match i32::from(*((base + 17) as *const u8)) {
                                                  0 => false,
                                                  1 => true,
                                                  _ => panic!("invalid bool discriminant"),
                                                }
                                              }
                                            }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          1 => OptionValue::TypeEntityId(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::EntityId{id0:*((base + 24) as *const i64) as u64, id1:*((base + 32) as *const i64) as u64, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          2 => OptionValue::TypeF32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const f32)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          3 => OptionValue::TypeF64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const f64)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          4 => OptionValue::TypeMat4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Mat4{x:super::super::super::ambient::bindings::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }, y:super::super::super::ambient::bindings::types::Vec4{x:*((base + 36) as *const f32), y:*((base + 40) as *const f32), z:*((base + 44) as *const f32), w:*((base + 48) as *const f32), }, z:super::super::super::ambient::bindings::types::Vec4{x:*((base + 52) as *const f32), y:*((base + 56) as *const f32), z:*((base + 60) as *const f32), w:*((base + 64) as *const f32), }, w:super::super::super::ambient::bindings::types::Vec4{x:*((base + 68) as *const f32), y:*((base + 72) as *const f32), z:*((base + 76) as *const f32), w:*((base + 80) as *const f32), }, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          5 => OptionValue::TypeQuat(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Quat{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          6 => OptionValue::TypeString(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some({
                                              let len32 = *((base + 24) as *const i32) as usize;
                                              
                                              {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len32, len32))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len32, len32)).unwrap()}}
                                            }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          7 => OptionValue::TypeU8(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 17) as *const u8)) as u8),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          8 => OptionValue::TypeU16(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 18) as *const u16)) as u16),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          9 => OptionValue::TypeU32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const i32) as u32),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          10 => OptionValue::TypeU64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const i64) as u64),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          11 => OptionValue::TypeI8(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 17) as *const i8)) as i8),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          12 => OptionValue::TypeI16(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(i32::from(*((base + 18) as *const i16)) as i16),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          13 => OptionValue::TypeI32(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 20) as *const i32)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          14 => OptionValue::TypeI64(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(*((base + 24) as *const i64)),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          15 => OptionValue::TypeVec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec2{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          16 => OptionValue::TypeVec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec3{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          17 => OptionValue::TypeVec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Vec4{x:*((base + 20) as *const f32), y:*((base + 24) as *const f32), z:*((base + 28) as *const f32), w:*((base + 32) as *const f32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          18 => OptionValue::TypeUvec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec2{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          19 => OptionValue::TypeUvec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec3{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          20 => OptionValue::TypeUvec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Uvec4{x:*((base + 20) as *const i32) as u32, y:*((base + 24) as *const i32) as u32, z:*((base + 28) as *const i32) as u32, w:*((base + 32) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          21 => OptionValue::TypeIvec2(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec2{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          22 => OptionValue::TypeIvec3(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec3{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), z:*((base + 28) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          23 => OptionValue::TypeIvec4(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Ivec4{x:*((base + 20) as *const i32), y:*((base + 24) as *const i32), z:*((base + 28) as *const i32), w:*((base + 32) as *const i32), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          24 => OptionValue::TypeDuration(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::types::Duration{seconds:*((base + 24) as *const i64) as u64, nanoseconds:*((base + 32) as *const i32) as u32, }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          25 => OptionValue::TypeProceduralMeshHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_mesh::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          26 => OptionValue::TypeProceduralTextureHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_texture::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          27 => OptionValue::TypeProceduralSamplerHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_sampler::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(debug_assertions)]28 => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(not(debug_assertions))]_ => OptionValue::TypeProceduralMaterialHandle(match i32::from(*((base + 16) as *const u8)) {
                                            0 => None,
                                            1 => Some(super::super::super::ambient::bindings::client_material::Handle{ulid:(*((base + 24) as *const i64) as u64, *((base + 32) as *const i64) as u64), }),
                                            #[cfg(not(debug_assertions))]
                                            _ => ::core::hint::unreachable_unchecked(),
                                            #[cfg(debug_assertions)]
                                            _ => panic!("invalid enum discriminant"),
                                          }),
                                          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                        }}}),
                                        #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                                      }}});
                                    }
                                    wit_bindgen::rt::dealloc(base33, (len33 as usize) * 88, 8);
                                    
                                    (super::super::super::ambient::bindings::types::EntityId{id0:*((base + 0) as *const i64) as u64, id1:*((base + 8) as *const i64) as u64, }, result33)
                                  });
                                }
                                wit_bindgen::rt::dealloc(base34, (len34 as usize) * 24, 8);
                                result34
                              }
                            }
                            
                          }
                          
                        }
                      }
                      
                      #[cfg(target_arch = "wasm32")]
                      #[link_section = "component-type:bindings"]
                      #[doc(hidden)]
                      pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 14566] = [3, 0, 8, 98, 105, 110, 100, 105, 110, 103, 115, 0, 97, 115, 109, 13, 0, 1, 0, 7, 237, 112, 1, 65, 64, 1, 66, 5, 1, 113, 1, 11, 105, 110, 118, 97, 108, 105, 100, 45, 117, 114, 108, 1, 115, 0, 4, 0, 9, 117, 114, 108, 45, 101, 114, 114, 111, 114, 3, 0, 0, 1, 106, 1, 115, 1, 1, 1, 64, 1, 4, 112, 97, 116, 104, 115, 0, 2, 4, 0, 3, 117, 114, 108, 1, 3, 4, 1, 22, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 97, 115, 115, 101, 116, 5, 0, 1, 66, 5, 1, 107, 115, 1, 64, 0, 0, 0, 4, 0, 3, 103, 101, 116, 1, 1, 1, 64, 1, 4, 116, 101, 120, 116, 115, 1, 0, 4, 0, 3, 115, 101, 116, 1, 2, 4, 1, 33, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 99, 108, 105, 112, 98, 111, 97, 114, 100, 5, 1, 1, 66, 2, 1, 64, 1, 10, 102, 117, 108, 108, 115, 99, 114, 101, 101, 110, 127, 1, 0, 4, 0, 14, 115, 101, 116, 45, 102, 117, 108, 108, 115, 99, 114, 101, 101, 110, 1, 0, 4, 1, 30, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 119, 105, 110, 100, 111, 119, 5, 2, 1, 66, 2, 1, 64, 0, 1, 0, 4, 0, 10, 98, 117, 105, 108, 100, 45, 119, 97, 115, 109, 1, 0, 4, 1, 29, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 97, 115, 115, 101, 116, 5, 3, 1, 66, 2, 1, 64, 1, 3, 117, 114, 108, 115, 1, 0, 4, 0, 3, 103, 101, 116, 1, 0, 4, 1, 28, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 104, 116, 116, 112, 5, 4, 1, 66, 30, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 0, 4, 118, 101, 99, 50, 3, 0, 2, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 0, 4, 118, 101, 99, 51, 3, 0, 4, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 0, 4, 118, 101, 99, 52, 3, 0, 6, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 0, 5, 117, 118, 101, 99, 50, 3, 0, 8, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 0, 5, 117, 118, 101, 99, 51, 3, 0, 10, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 0, 5, 117, 118, 101, 99, 52, 3, 0, 12, 1, 114, 2, 1, 120, 122, 1, 121, 122, 4, 0, 5, 105, 118, 101, 99, 50, 3, 0, 14, 1, 114, 3, 1, 120, 122, 1, 121, 122, 1, 122, 122, 4, 0, 5, 105, 118, 101, 99, 51, 3, 0, 16, 1, 114, 4, 1, 120, 122, 1, 121, 122, 1, 122, 122, 1, 119, 122, 4, 0, 5, 105, 118, 101, 99, 52, 3, 0, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 0, 4, 113, 117, 97, 116, 3, 0, 20, 1, 114, 4, 1, 120, 7, 1, 121, 7, 1, 122, 7, 1, 119, 7, 4, 0, 4, 109, 97, 116, 52, 3, 0, 22, 1, 114, 2, 7, 115, 101, 99, 111, 110, 100, 115, 119, 11, 110, 97, 110, 111, 115, 101, 99, 111, 110, 100, 115, 121, 4, 0, 8, 100, 117, 114, 97, 116, 105, 111, 110, 3, 0, 24, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 5, 3, 100, 105, 114, 5, 4, 0, 3, 114, 97, 121, 3, 0, 26, 1, 111, 2, 119, 119, 4, 0, 4, 117, 108, 105, 100, 3, 0, 28, 4, 1, 22, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 116, 121, 112, 101, 115, 5, 5, 2, 3, 0, 5, 4, 118, 101, 99, 51, 2, 3, 0, 5, 4, 118, 101, 99, 50, 2, 3, 0, 5, 3, 114, 97, 121, 2, 3, 0, 5, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 66, 16, 2, 3, 2, 1, 6, 4, 0, 4, 118, 101, 99, 51, 3, 0, 0, 2, 3, 2, 1, 7, 4, 0, 4, 118, 101, 99, 50, 3, 0, 2, 2, 3, 2, 1, 8, 4, 0, 3, 114, 97, 121, 3, 0, 4, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 6, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 14, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 45, 112, 111, 115, 3, 0, 5, 4, 0, 26, 99, 108, 105, 112, 45, 112, 111, 115, 105, 116, 105, 111, 110, 45, 116, 111, 45, 119, 111, 114, 108, 100, 45, 114, 97, 121, 1, 8, 1, 64, 1, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 3, 0, 3, 4, 0, 20, 115, 99, 114, 101, 101, 110, 45, 116, 111, 45, 99, 108, 105, 112, 45, 115, 112, 97, 99, 101, 1, 9, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 3, 0, 5, 4, 0, 28, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 105, 116, 105, 111, 110, 45, 116, 111, 45, 119, 111, 114, 108, 100, 45, 114, 97, 121, 1, 10, 1, 64, 2, 6, 99, 97, 109, 101, 114, 97, 7, 10, 115, 99, 114, 101, 101, 110, 45, 112, 111, 115, 1, 0, 3, 4, 0, 15, 119, 111, 114, 108, 100, 45, 116, 111, 45, 115, 99, 114, 101, 101, 110, 1, 11, 4, 1, 30, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 99, 97, 109, 101, 114, 97, 5, 10, 1, 66, 23, 2, 3, 2, 1, 7, 4, 0, 4, 118, 101, 99, 50, 3, 0, 0, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 2, 1, 109, 163, 1, 4, 107, 101, 121, 49, 4, 107, 101, 121, 50, 4, 107, 101, 121, 51, 4, 107, 101, 121, 52, 4, 107, 101, 121, 53, 4, 107, 101, 121, 54, 4, 107, 101, 121, 55, 4, 107, 101, 121, 56, 4, 107, 101, 121, 57, 4, 107, 101, 121, 48, 1, 97, 1, 98, 1, 99, 1, 100, 1, 101, 1, 102, 1, 103, 1, 104, 1, 105, 1, 106, 1, 107, 1, 108, 1, 109, 1, 110, 1, 111, 1, 112, 1, 113, 1, 114, 1, 115, 1, 116, 1, 117, 1, 118, 1, 119, 1, 120, 1, 121, 1, 122, 6, 101, 115, 99, 97, 112, 101, 2, 102, 49, 2, 102, 50, 2, 102, 51, 2, 102, 52, 2, 102, 53, 2, 102, 54, 2, 102, 55, 2, 102, 56, 2, 102, 57, 3, 102, 49, 48, 3, 102, 49, 49, 3, 102, 49, 50, 3, 102, 49, 51, 3, 102, 49, 52, 3, 102, 49, 53, 3, 102, 49, 54, 3, 102, 49, 55, 3, 102, 49, 56, 3, 102, 49, 57, 3, 102, 50, 48, 3, 102, 50, 49, 3, 102, 50, 50, 3, 102, 50, 51, 3, 102, 50, 52, 8, 115, 110, 97, 112, 115, 104, 111, 116, 6, 115, 99, 114, 111, 108, 108, 5, 112, 97, 117, 115, 101, 6, 105, 110, 115, 101, 114, 116, 4, 104, 111, 109, 101, 6, 100, 101, 108, 101, 116, 101, 3, 101, 110, 100, 9, 112, 97, 103, 101, 45, 100, 111, 119, 110, 7, 112, 97, 103, 101, 45, 117, 112, 4, 108, 101, 102, 116, 2, 117, 112, 5, 114, 105, 103, 104, 116, 4, 100, 111, 119, 110, 4, 98, 97, 99, 107, 6, 114, 101, 116, 117, 114, 110, 5, 115, 112, 97, 99, 101, 7, 99, 111, 109, 112, 111, 115, 101, 5, 99, 97, 114, 101, 116, 7, 110, 117, 109, 108, 111, 99, 107, 7, 110, 117, 109, 112, 97, 100, 48, 7, 110, 117, 109, 112, 97, 100, 49, 7, 110, 117, 109, 112, 97, 100, 50, 7, 110, 117, 109, 112, 97, 100, 51, 7, 110, 117, 109, 112, 97, 100, 52, 7, 110, 117, 109, 112, 97, 100, 53, 7, 110, 117, 109, 112, 97, 100, 54, 7, 110, 117, 109, 112, 97, 100, 55, 7, 110, 117, 109, 112, 97, 100, 56, 7, 110, 117, 109, 112, 97, 100, 57, 10, 110, 117, 109, 112, 97, 100, 45, 97, 100, 100, 13, 110, 117, 109, 112, 97, 100, 45, 100, 105, 118, 105, 100, 101, 14, 110, 117, 109, 112, 97, 100, 45, 100, 101, 99, 105, 109, 97, 108, 12, 110, 117, 109, 112, 97, 100, 45, 99, 111, 109, 109, 97, 12, 110, 117, 109, 112, 97, 100, 45, 101, 110, 116, 101, 114, 13, 110, 117, 109, 112, 97, 100, 45, 101, 113, 117, 97, 108, 115, 15, 110, 117, 109, 112, 97, 100, 45, 109, 117, 108, 116, 105, 112, 108, 121, 15, 110, 117, 109, 112, 97, 100, 45, 115, 117, 98, 116, 114, 97, 99, 116, 7, 97, 98, 110, 116, 45, 99, 49, 7, 97, 98, 110, 116, 45, 99, 50, 10, 97, 112, 111, 115, 116, 114, 111, 112, 104, 101, 4, 97, 112, 112, 115, 8, 97, 115, 116, 101, 114, 105, 115, 107, 2, 97, 116, 2, 97, 120, 9, 98, 97, 99, 107, 115, 108, 97, 115, 104, 10, 99, 97, 108, 99, 117, 108, 97, 116, 111, 114, 7, 99, 97, 112, 105, 116, 97, 108, 5, 99, 111, 108, 111, 110, 5, 99, 111, 109, 109, 97, 7, 99, 111, 110, 118, 101, 114, 116, 6, 101, 113, 117, 97, 108, 115, 5, 103, 114, 97, 118, 101, 4, 107, 97, 110, 97, 5, 107, 97, 110, 106, 105, 5, 108, 45, 97, 108, 116, 9, 108, 45, 98, 114, 97, 99, 107, 101, 116, 9, 108, 45, 99, 111, 110, 116, 114, 111, 108, 7, 108, 45, 115, 104, 105, 102, 116, 5, 108, 45, 119, 105, 110, 4, 109, 97, 105, 108, 12, 109, 101, 100, 105, 97, 45, 115, 101, 108, 101, 99, 116, 10, 109, 101, 100, 105, 97, 45, 115, 116, 111, 112, 5, 109, 105, 110, 117, 115, 4, 109, 117, 116, 101, 11, 109, 121, 45, 99, 111, 109, 112, 117, 116, 101, 114, 16, 110, 97, 118, 105, 103, 97, 116, 101, 45, 102, 111, 114, 119, 97, 114, 100, 17, 110, 97, 118, 105, 103, 97, 116, 101, 45, 98, 97, 99, 107, 119, 97, 114, 100, 10, 110, 101, 120, 116, 45, 116, 114, 97, 99, 107, 10, 110, 111, 45, 99, 111, 110, 118, 101, 114, 116, 6, 111, 101, 109, 49, 48, 50, 6, 112, 101, 114, 105, 111, 100, 10, 112, 108, 97, 121, 45, 112, 97, 117, 115, 101, 4, 112, 108, 117, 115, 5, 112, 111, 119, 101, 114, 10, 112, 114, 101, 118, 45, 116, 114, 97, 99, 107, 5, 114, 45, 97, 108, 116, 9, 114, 45, 98, 114, 97, 99, 107, 101, 116, 9, 114, 45, 99, 111, 110, 116, 114, 111, 108, 7, 114, 45, 115, 104, 105, 102, 116, 5, 114, 45, 119, 105, 110, 9, 115, 101, 109, 105, 99, 111, 108, 111, 110, 5, 115, 108, 97, 115, 104, 5, 115, 108, 101, 101, 112, 4, 115, 116, 111, 112, 5, 115, 121, 115, 114, 113, 3, 116, 97, 98, 9, 117, 110, 100, 101, 114, 108, 105, 110, 101, 9, 117, 110, 108, 97, 98, 101, 108, 101, 100, 11, 118, 111, 108, 117, 109, 101, 45, 100, 111, 119, 110, 9, 118, 111, 108, 117, 109, 101, 45, 117, 112, 4, 119, 97, 107, 101, 8, 119, 101, 98, 45, 98, 97, 99, 107, 13, 119, 101, 98, 45, 102, 97, 118, 111, 114, 105, 116, 101, 115, 11, 119, 101, 98, 45, 102, 111, 114, 119, 97, 114, 100, 8, 119, 101, 98, 45, 104, 111, 109, 101, 11, 119, 101, 98, 45, 114, 101, 102, 114, 101, 115, 104, 10, 119, 101, 98, 45, 115, 101, 97, 114, 99, 104, 8, 119, 101, 98, 45, 115, 116, 111, 112, 3, 121, 101, 110, 4, 99, 111, 112, 121, 5, 112, 97, 115, 116, 101, 3, 99, 117, 116, 4, 0, 16, 118, 105, 114, 116, 117, 97, 108, 45, 107, 101, 121, 45, 99, 111, 100, 101, 3, 0, 4, 1, 113, 4, 4, 108, 101, 102, 116, 0, 0, 5, 114, 105, 103, 104, 116, 0, 0, 6, 109, 105, 100, 100, 108, 101, 0, 0, 5, 111, 116, 104, 101, 114, 1, 123, 0, 4, 0, 12, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 3, 0, 6, 1, 112, 5, 1, 112, 7, 1, 114, 5, 4, 107, 101, 121, 115, 8, 14, 109, 111, 117, 115, 101, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 11, 109, 111, 117, 115, 101, 45, 100, 101, 108, 116, 97, 1, 11, 109, 111, 117, 115, 101, 45, 119, 104, 101, 101, 108, 118, 13, 109, 111, 117, 115, 101, 45, 98, 117, 116, 116, 111, 110, 115, 9, 4, 0, 5, 105, 110, 112, 117, 116, 3, 0, 10, 1, 113, 35, 12, 100, 101, 102, 97, 117, 108, 116, 45, 105, 99, 111, 110, 0, 0, 9, 99, 114, 111, 115, 115, 104, 97, 105, 114, 0, 0, 4, 104, 97, 110, 100, 0, 0, 5, 97, 114, 114, 111, 119, 0, 0, 4, 109, 111, 118, 101, 0, 0, 4, 116, 101, 120, 116, 0, 0, 4, 119, 97, 105, 116, 0, 0, 4, 104, 101, 108, 112, 0, 0, 8, 112, 114, 111, 103, 114, 101, 115, 115, 0, 0, 11, 110, 111, 116, 45, 97, 108, 108, 111, 119, 101, 100, 0, 0, 12, 99, 111, 110, 116, 101, 120, 116, 45, 109, 101, 110, 117, 0, 0, 4, 99, 101, 108, 108, 0, 0, 13, 118, 101, 114, 116, 105, 99, 97, 108, 45, 116, 101, 120, 116, 0, 0, 5, 97, 108, 105, 97, 115, 0, 0, 4, 99, 111, 112, 121, 0, 0, 7, 110, 111, 45, 100, 114, 111, 112, 0, 0, 4, 103, 114, 97, 98, 0, 0, 8, 103, 114, 97, 98, 98, 105, 110, 103, 0, 0, 10, 97, 108, 108, 45, 115, 99, 114, 111, 108, 108, 0, 0, 7, 122, 111, 111, 109, 45, 105, 110, 0, 0, 8, 122, 111, 111, 109, 45, 111, 117, 116, 0, 0, 8, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 110, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 115, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 115, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 115, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 8, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 101, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 9, 110, 115, 45, 114, 101, 115, 105, 122, 101, 0, 0, 11, 110, 101, 115, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 11, 110, 119, 115, 101, 45, 114, 101, 115, 105, 122, 101, 0, 0, 10, 99, 111, 108, 45, 114, 101, 115, 105, 122, 101, 0, 0, 10, 114, 111, 119, 45, 114, 101, 115, 105, 122, 101, 0, 0, 4, 0, 11, 99, 117, 114, 115, 111, 114, 45, 105, 99, 111, 110, 3, 0, 12, 1, 64, 0, 0, 11, 4, 0, 3, 103, 101, 116, 1, 14, 4, 0, 12, 103, 101, 116, 45, 112, 114, 101, 118, 105, 111, 117, 115, 1, 14, 1, 64, 1, 4, 105, 99, 111, 110, 13, 1, 0, 4, 0, 10, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 1, 15, 1, 64, 1, 7, 118, 105, 115, 105, 98, 108, 101, 127, 1, 0, 4, 0, 18, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 45, 118, 105, 115, 105, 98, 108, 101, 1, 16, 1, 64, 1, 6, 108, 111, 99, 107, 101, 100, 127, 1, 0, 4, 0, 15, 115, 101, 116, 45, 99, 117, 114, 115, 111, 114, 45, 108, 111, 99, 107, 1, 17, 4, 1, 29, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 105, 110, 112, 117, 116, 5, 11, 2, 3, 0, 5, 4, 117, 108, 105, 100, 1, 66, 18, 2, 3, 2, 1, 7, 4, 0, 4, 118, 101, 99, 50, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 4, 118, 101, 99, 51, 3, 0, 2, 2, 3, 2, 1, 12, 4, 0, 4, 117, 108, 105, 100, 3, 0, 4, 1, 114, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 110, 111, 114, 109, 97, 108, 3, 7, 116, 97, 110, 103, 101, 110, 116, 3, 9, 116, 101, 120, 99, 111, 111, 114, 100, 48, 1, 4, 0, 6, 118, 101, 114, 116, 101, 120, 3, 0, 6, 1, 112, 7, 1, 112, 121, 1, 114, 2, 8, 118, 101, 114, 116, 105, 99, 101, 115, 8, 7, 105, 110, 100, 105, 99, 101, 115, 9, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 10, 1, 114, 1, 4, 117, 108, 105, 100, 5, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 12, 1, 64, 1, 4, 100, 101, 115, 99, 11, 0, 13, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 14, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 13, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 15, 4, 1, 28, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 5, 13, 1, 66, 7, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 113, 4, 17, 115, 101, 114, 118, 101, 114, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 15, 115, 101, 114, 118, 101, 114, 45, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 15, 108, 111, 99, 97, 108, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 1, 127, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 4, 0, 6, 116, 97, 114, 103, 101, 116, 3, 0, 2, 1, 112, 125, 1, 64, 3, 9, 116, 97, 114, 103, 101, 116, 45, 105, 100, 3, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 4, 1, 0, 4, 0, 4, 115, 101, 110, 100, 1, 5, 4, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 115, 97, 103, 101, 5, 14, 1, 66, 4, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 64, 0, 0, 1, 4, 0, 9, 103, 101, 116, 45, 108, 111, 99, 97, 108, 1, 2, 4, 1, 30, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 112, 108, 97, 121, 101, 114, 5, 15, 1, 66, 14, 2, 3, 2, 1, 12, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 1, 113, 3, 13, 99, 108, 97, 109, 112, 45, 116, 111, 45, 101, 100, 103, 101, 0, 0, 6, 114, 101, 112, 101, 97, 116, 0, 0, 13, 109, 105, 114, 114, 111, 114, 45, 114, 101, 112, 101, 97, 116, 0, 0, 4, 0, 12, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 3, 0, 2, 1, 113, 2, 7, 110, 101, 97, 114, 101, 115, 116, 0, 0, 6, 108, 105, 110, 101, 97, 114, 0, 0, 4, 0, 11, 102, 105, 108, 116, 101, 114, 45, 109, 111, 100, 101, 3, 0, 4, 1, 114, 6, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 117, 3, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 118, 3, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 119, 3, 10, 109, 97, 103, 45, 102, 105, 108, 116, 101, 114, 5, 10, 109, 105, 110, 45, 102, 105, 108, 116, 101, 114, 5, 13, 109, 105, 112, 109, 97, 112, 45, 102, 105, 108, 116, 101, 114, 5, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 7, 0, 9, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 9, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 11, 4, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 5, 16, 1, 66, 13, 2, 3, 2, 1, 12, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 1, 113, 42, 8, 114, 56, 45, 117, 110, 111, 114, 109, 0, 0, 8, 114, 56, 45, 115, 110, 111, 114, 109, 0, 0, 7, 114, 56, 45, 117, 105, 110, 116, 0, 0, 7, 114, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 117, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 115, 105, 110, 116, 0, 0, 9, 114, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 56, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 103, 56, 45, 115, 110, 111, 114, 109, 0, 0, 8, 114, 103, 56, 45, 117, 105, 110, 116, 0, 0, 8, 114, 103, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 117, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 115, 105, 110, 116, 0, 0, 9, 114, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 49, 54, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 49, 54, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 11, 114, 103, 98, 97, 56, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 98, 97, 56, 45, 117, 105, 110, 116, 0, 0, 10, 114, 103, 98, 97, 56, 45, 115, 105, 110, 116, 0, 0, 11, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 13, 114, 103, 98, 57, 101, 53, 45, 117, 102, 108, 111, 97, 116, 0, 0, 13, 114, 103, 98, 49, 48, 97, 50, 45, 117, 110, 111, 114, 109, 0, 0, 13, 114, 103, 49, 49, 98, 49, 48, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 51, 50, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 51, 50, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 4, 0, 6, 102, 111, 114, 109, 97, 116, 3, 0, 2, 1, 112, 125, 1, 114, 4, 5, 119, 105, 100, 116, 104, 121, 6, 104, 101, 105, 103, 104, 116, 121, 6, 102, 111, 114, 109, 97, 116, 3, 4, 100, 97, 116, 97, 4, 4, 0, 12, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 50, 100, 3, 0, 5, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 7, 1, 64, 1, 4, 100, 101, 115, 99, 6, 0, 8, 4, 0, 8, 99, 114, 101, 97, 116, 101, 50, 100, 1, 9, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 8, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 10, 4, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 5, 17, 2, 3, 0, 12, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 11, 6, 104, 97, 110, 100, 108, 101, 1, 66, 14, 2, 3, 2, 1, 12, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 2, 3, 2, 1, 18, 4, 0, 14, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 3, 0, 2, 2, 3, 2, 1, 19, 4, 0, 14, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 3, 0, 4, 1, 114, 5, 14, 98, 97, 115, 101, 45, 99, 111, 108, 111, 114, 45, 109, 97, 112, 3, 10, 110, 111, 114, 109, 97, 108, 45, 109, 97, 112, 3, 22, 109, 101, 116, 97, 108, 108, 105, 99, 45, 114, 111, 117, 103, 104, 110, 101, 115, 115, 45, 109, 97, 112, 3, 7, 115, 97, 109, 112, 108, 101, 114, 5, 11, 116, 114, 97, 110, 115, 112, 97, 114, 101, 110, 116, 127, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 7, 0, 9, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 9, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 11, 4, 1, 32, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 5, 20, 2, 3, 0, 5, 4, 109, 97, 116, 52, 2, 3, 0, 5, 4, 113, 117, 97, 116, 2, 3, 0, 5, 4, 118, 101, 99, 52, 2, 3, 0, 5, 5, 117, 118, 101, 99, 50, 2, 3, 0, 5, 5, 117, 118, 101, 99, 51, 2, 3, 0, 5, 5, 117, 118, 101, 99, 52, 2, 3, 0, 5, 5, 105, 118, 101, 99, 50, 2, 3, 0, 5, 5, 105, 118, 101, 99, 51, 2, 3, 0, 5, 5, 105, 118, 101, 99, 52, 2, 3, 0, 5, 8, 100, 117, 114, 97, 116, 105, 111, 110, 2, 3, 0, 8, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 13, 6, 104, 97, 110, 100, 108, 101, 1, 66, 137, 1, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 2, 3, 2, 1, 21, 4, 0, 4, 109, 97, 116, 52, 3, 0, 2, 2, 3, 2, 1, 22, 4, 0, 4, 113, 117, 97, 116, 3, 0, 4, 2, 3, 2, 1, 7, 4, 0, 4, 118, 101, 99, 50, 3, 0, 6, 2, 3, 2, 1, 6, 4, 0, 4, 118, 101, 99, 51, 3, 0, 8, 2, 3, 2, 1, 23, 4, 0, 4, 118, 101, 99, 52, 3, 0, 10, 2, 3, 2, 1, 24, 4, 0, 5, 117, 118, 101, 99, 50, 3, 0, 12, 2, 3, 2, 1, 25, 4, 0, 5, 117, 118, 101, 99, 51, 3, 0, 14, 2, 3, 2, 1, 26, 4, 0, 5, 117, 118, 101, 99, 52, 3, 0, 16, 2, 3, 2, 1, 27, 4, 0, 5, 105, 118, 101, 99, 50, 3, 0, 18, 2, 3, 2, 1, 28, 4, 0, 5, 105, 118, 101, 99, 51, 3, 0, 20, 2, 3, 2, 1, 29, 4, 0, 5, 105, 118, 101, 99, 52, 3, 0, 22, 2, 3, 2, 1, 30, 4, 0, 8, 100, 117, 114, 97, 116, 105, 111, 110, 3, 0, 24, 2, 3, 2, 1, 31, 4, 0, 22, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 3, 0, 26, 2, 3, 2, 1, 18, 4, 0, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 3, 0, 28, 2, 3, 2, 1, 19, 4, 0, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 3, 0, 30, 2, 3, 2, 1, 32, 4, 0, 26, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 3, 0, 32, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 5, 1, 112, 115, 1, 112, 125, 1, 112, 123, 1, 112, 121, 1, 112, 119, 1, 112, 126, 1, 112, 124, 1, 112, 122, 1, 112, 120, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 112, 19, 1, 112, 21, 1, 112, 23, 1, 112, 25, 1, 112, 27, 1, 112, 29, 1, 112, 31, 1, 112, 33, 1, 113, 29, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 34, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 35, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 36, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 37, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 38, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 39, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 40, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 41, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 42, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 43, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 44, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 45, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 46, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 47, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 48, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 49, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 50, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 51, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 52, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 53, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 54, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 55, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 56, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 57, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 58, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 59, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 60, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 61, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 62, 0, 4, 0, 9, 118, 101, 99, 45, 118, 97, 108, 117, 101, 3, 0, 63, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 5, 1, 107, 115, 1, 107, 125, 1, 107, 123, 1, 107, 121, 1, 107, 119, 1, 107, 126, 1, 107, 124, 1, 107, 122, 1, 107, 120, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 107, 19, 1, 107, 21, 1, 107, 23, 1, 107, 25, 1, 107, 27, 1, 107, 29, 1, 107, 31, 1, 107, 33, 1, 113, 29, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 193, 0, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 194, 0, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 195, 0, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 196, 0, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 197, 0, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 198, 0, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 199, 0, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 200, 0, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 201, 0, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 202, 0, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 203, 0, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 204, 0, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 205, 0, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 206, 0, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 207, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 208, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 209, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 210, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 211, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 212, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 213, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 214, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 215, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 216, 0, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 217, 0, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 218, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 219, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 220, 0, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 221, 0, 0, 4, 0, 12, 111, 112, 116, 105, 111, 110, 45, 118, 97, 108, 117, 101, 3, 0, 94, 1, 113, 31, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 125, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 123, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 126, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 124, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 120, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 19, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 21, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 23, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 25, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 27, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 29, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 31, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 33, 0, 8, 116, 121, 112, 101, 45, 118, 101, 99, 1, 192, 0, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 223, 0, 0, 4, 0, 5, 118, 97, 108, 117, 101, 3, 0, 96, 1, 111, 2, 121, 225, 0, 1, 112, 226, 0, 4, 0, 6, 101, 110, 116, 105, 116, 121, 3, 0, 99, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 43, 8, 105, 110, 99, 108, 117, 100, 101, 115, 43, 8, 101, 120, 99, 108, 117, 100, 101, 115, 43, 7, 99, 104, 97, 110, 103, 101, 100, 43, 4, 0, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 3, 0, 101, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 0, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 3, 0, 103, 1, 64, 1, 2, 105, 100, 115, 0, 202, 0, 4, 0, 9, 103, 101, 116, 45, 105, 110, 100, 101, 120, 1, 105, 1, 64, 1, 5, 105, 110, 100, 101, 120, 121, 0, 199, 0, 4, 0, 6, 103, 101, 116, 45, 105, 100, 1, 106, 1, 107, 225, 0, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 235, 0, 4, 0, 13, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 108, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 43, 0, 228, 0, 4, 0, 14, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 109, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 228, 0, 4, 0, 18, 103, 101, 116, 45, 97, 108, 108, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 110, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 5, 118, 97, 108, 117, 101, 225, 0, 1, 0, 4, 0, 13, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 111, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 4, 100, 97, 116, 97, 228, 0, 1, 0, 4, 0, 14, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 112, 4, 0, 13, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 111, 4, 0, 14, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 112, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 127, 4, 0, 13, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 113, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 43, 0, 127, 4, 0, 14, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 114, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 1, 0, 4, 0, 16, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 115, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 43, 1, 0, 4, 0, 17, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 116, 1, 64, 2, 1, 113, 230, 0, 1, 116, 232, 0, 0, 119, 4, 0, 5, 113, 117, 101, 114, 121, 1, 117, 1, 112, 225, 0, 1, 111, 2, 1, 246, 0, 1, 112, 247, 0, 1, 64, 1, 1, 113, 119, 0, 248, 0, 4, 0, 10, 113, 117, 101, 114, 121, 45, 101, 118, 97, 108, 1, 121, 4, 1, 26, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 33, 2, 3, 0, 14, 6, 101, 110, 116, 105, 116, 121, 1, 66, 29, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 4, 118, 101, 99, 51, 3, 0, 2, 2, 3, 2, 1, 22, 4, 0, 4, 113, 117, 97, 116, 3, 0, 4, 2, 3, 2, 1, 21, 4, 0, 4, 109, 97, 116, 52, 3, 0, 6, 2, 3, 2, 1, 34, 4, 0, 11, 101, 110, 116, 105, 116, 121, 45, 100, 97, 116, 97, 3, 0, 8, 1, 112, 1, 1, 112, 7, 1, 64, 2, 8, 101, 110, 116, 105, 116, 105, 101, 115, 10, 6, 111, 114, 105, 103, 105, 110, 1, 0, 11, 4, 0, 26, 103, 101, 116, 45, 116, 114, 97, 110, 115, 102, 111, 114, 109, 115, 45, 114, 101, 108, 97, 116, 105, 118, 101, 45, 116, 111, 1, 12, 1, 64, 1, 4, 100, 97, 116, 97, 9, 0, 1, 4, 0, 5, 115, 112, 97, 119, 110, 1, 13, 1, 107, 9, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 14, 4, 0, 7, 100, 101, 115, 112, 97, 119, 110, 1, 15, 1, 64, 2, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 114, 97, 100, 105, 117, 115, 118, 0, 10, 4, 0, 7, 105, 110, 45, 97, 114, 101, 97, 1, 16, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 127, 4, 0, 6, 101, 120, 105, 115, 116, 115, 1, 17, 1, 64, 1, 5, 105, 110, 100, 101, 120, 121, 0, 10, 4, 0, 7, 103, 101, 116, 45, 97, 108, 108, 1, 18, 1, 64, 0, 0, 1, 4, 0, 9, 114, 101, 115, 111, 117, 114, 99, 101, 115, 1, 19, 4, 0, 22, 115, 121, 110, 99, 104, 114, 111, 110, 105, 122, 101, 100, 45, 114, 101, 115, 111, 117, 114, 99, 101, 115, 1, 19, 4, 0, 19, 112, 101, 114, 115, 105, 115, 116, 101, 100, 45, 114, 101, 115, 111, 117, 114, 99, 101, 115, 1, 19, 4, 1, 23, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 101, 110, 116, 105, 116, 121, 5, 35, 1, 66, 9, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 113, 4, 7, 114, 117, 110, 116, 105, 109, 101, 0, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 6, 115, 101, 114, 118, 101, 114, 0, 0, 6, 99, 108, 105, 101, 110, 116, 1, 115, 0, 4, 0, 6, 115, 111, 117, 114, 99, 101, 3, 0, 2, 1, 64, 0, 1, 0, 4, 0, 4, 105, 110, 105, 116, 1, 4, 1, 112, 125, 1, 64, 3, 14, 109, 101, 115, 115, 97, 103, 101, 45, 115, 111, 117, 114, 99, 101, 3, 12, 109, 101, 115, 115, 97, 103, 101, 45, 110, 97, 109, 101, 115, 12, 109, 101, 115, 115, 97, 103, 101, 45, 100, 97, 116, 97, 5, 1, 0, 4, 0, 4, 101, 120, 101, 99, 1, 6, 4, 1, 22, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 103, 117, 101, 115, 116, 5, 36, 1, 66, 4, 2, 3, 2, 1, 34, 4, 0, 6, 101, 110, 116, 105, 116, 121, 3, 0, 0, 1, 64, 1, 4, 110, 97, 109, 101, 115, 1, 0, 4, 0, 9, 115, 117, 98, 115, 99, 114, 105, 98, 101, 1, 2, 4, 1, 24, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 109, 101, 115, 115, 97, 103, 101, 5, 37, 1, 66, 5, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 107, 1, 1, 64, 1, 7, 117, 115, 101, 114, 45, 105, 100, 115, 0, 2, 4, 0, 14, 103, 101, 116, 45, 98, 121, 45, 117, 115, 101, 114, 45, 105, 100, 1, 3, 4, 1, 23, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 112, 108, 97, 121, 101, 114, 5, 38, 1, 66, 7, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 113, 6, 27, 99, 108, 105, 101, 110, 116, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 25, 99, 108, 105, 101, 110, 116, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 45, 114, 101, 108, 105, 97, 98, 108, 101, 0, 0, 26, 99, 108, 105, 101, 110, 116, 45, 116, 97, 114, 103, 101, 116, 101, 100, 45, 117, 110, 114, 101, 108, 105, 97, 98, 108, 101, 1, 115, 0, 24, 99, 108, 105, 101, 110, 116, 45, 116, 97, 114, 103, 101, 116, 101, 100, 45, 114, 101, 108, 105, 97, 98, 108, 101, 1, 115, 0, 15, 108, 111, 99, 97, 108, 45, 98, 114, 111, 97, 100, 99, 97, 115, 116, 1, 127, 0, 5, 108, 111, 99, 97, 108, 1, 1, 0, 4, 0, 6, 116, 97, 114, 103, 101, 116, 3, 0, 2, 1, 112, 125, 1, 64, 3, 9, 116, 97, 114, 103, 101, 116, 45, 105, 100, 3, 4, 110, 97, 109, 101, 115, 4, 100, 97, 116, 97, 4, 1, 0, 4, 0, 4, 115, 101, 110, 100, 1, 5, 4, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 109, 101, 115, 115, 97, 103, 101, 5, 39, 1, 66, 43, 2, 3, 2, 1, 9, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 2, 3, 2, 1, 6, 4, 0, 4, 118, 101, 99, 51, 3, 0, 2, 2, 3, 2, 1, 21, 4, 0, 4, 109, 97, 116, 52, 3, 0, 4, 1, 114, 3, 4, 115, 105, 100, 101, 127, 2, 117, 112, 127, 4, 100, 111, 119, 110, 127, 4, 0, 19, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 99, 111, 108, 108, 105, 115, 105, 111, 110, 3, 0, 6, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 102, 111, 114, 99, 101, 3, 1, 0, 4, 0, 9, 97, 100, 100, 45, 102, 111, 114, 99, 101, 1, 8, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 109, 112, 117, 108, 115, 101, 3, 1, 0, 4, 0, 11, 97, 100, 100, 45, 105, 109, 112, 117, 108, 115, 101, 1, 9, 1, 107, 118, 1, 64, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 7, 105, 109, 112, 117, 108, 115, 101, 118, 6, 114, 97, 100, 105, 117, 115, 118, 14, 102, 97, 108, 108, 111, 102, 102, 45, 114, 97, 100, 105, 117, 115, 10, 1, 0, 4, 0, 18, 97, 100, 100, 45, 114, 97, 100, 105, 97, 108, 45, 105, 109, 112, 117, 108, 115, 101, 1, 11, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 102, 111, 114, 99, 101, 3, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 0, 21, 97, 100, 100, 45, 102, 111, 114, 99, 101, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 12, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 109, 112, 117, 108, 115, 101, 3, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 0, 23, 97, 100, 100, 45, 105, 109, 112, 117, 108, 115, 101, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 13, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 0, 3, 4, 0, 24, 103, 101, 116, 45, 118, 101, 108, 111, 99, 105, 116, 121, 45, 97, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 14, 1, 64, 1, 7, 103, 114, 97, 118, 105, 116, 121, 3, 1, 0, 4, 0, 11, 115, 101, 116, 45, 103, 114, 97, 118, 105, 116, 121, 1, 15, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 1, 0, 4, 0, 8, 117, 110, 102, 114, 101, 101, 122, 101, 1, 16, 4, 0, 6, 102, 114, 101, 101, 122, 101, 1, 16, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 118, 101, 108, 111, 99, 105, 116, 121, 118, 1, 0, 4, 0, 11, 115, 116, 97, 114, 116, 45, 109, 111, 116, 111, 114, 1, 17, 4, 0, 10, 115, 116, 111, 112, 45, 109, 111, 116, 111, 114, 1, 16, 1, 64, 4, 6, 97, 99, 116, 111, 114, 48, 1, 10, 116, 114, 97, 110, 115, 102, 111, 114, 109, 48, 5, 6, 97, 99, 116, 111, 114, 49, 1, 10, 116, 114, 97, 110, 115, 102, 111, 114, 109, 49, 5, 1, 0, 4, 0, 21, 99, 114, 101, 97, 116, 101, 45, 114, 101, 118, 111, 108, 117, 116, 101, 45, 106, 111, 105, 110, 116, 1, 18, 1, 111, 2, 1, 118, 1, 107, 19, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 20, 4, 0, 13, 114, 97, 121, 99, 97, 115, 116, 45, 102, 105, 114, 115, 116, 1, 21, 1, 112, 19, 1, 64, 2, 6, 111, 114, 105, 103, 105, 110, 3, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 22, 4, 0, 7, 114, 97, 121, 99, 97, 115, 116, 1, 23, 1, 64, 4, 6, 101, 110, 116, 105, 116, 121, 1, 12, 100, 105, 115, 112, 108, 97, 99, 101, 109, 101, 110, 116, 3, 8, 109, 105, 110, 45, 100, 105, 115, 116, 118, 12, 101, 108, 97, 112, 115, 101, 100, 45, 116, 105, 109, 101, 118, 0, 7, 4, 0, 14, 109, 111, 118, 101, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 1, 24, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 1, 0, 4, 0, 22, 115, 101, 116, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 25, 4, 0, 27, 115, 101, 116, 45, 99, 104, 97, 114, 97, 99, 116, 101, 114, 45, 102, 111, 111, 116, 45, 112, 111, 115, 105, 116, 105, 111, 110, 1, 25, 4, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 115, 101, 114, 118, 101, 114, 45, 112, 104, 121, 115, 105, 99, 115, 5, 40, 1, 65, 32, 1, 66, 30, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 0, 4, 118, 101, 99, 50, 3, 0, 2, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 0, 4, 118, 101, 99, 51, 3, 0, 4, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 0, 4, 118, 101, 99, 52, 3, 0, 6, 1, 114, 2, 1, 120, 121, 1, 121, 121, 4, 0, 5, 117, 118, 101, 99, 50, 3, 0, 8, 1, 114, 3, 1, 120, 121, 1, 121, 121, 1, 122, 121, 4, 0, 5, 117, 118, 101, 99, 51, 3, 0, 10, 1, 114, 4, 1, 120, 121, 1, 121, 121, 1, 122, 121, 1, 119, 121, 4, 0, 5, 117, 118, 101, 99, 52, 3, 0, 12, 1, 114, 2, 1, 120, 122, 1, 121, 122, 4, 0, 5, 105, 118, 101, 99, 50, 3, 0, 14, 1, 114, 3, 1, 120, 122, 1, 121, 122, 1, 122, 122, 4, 0, 5, 105, 118, 101, 99, 51, 3, 0, 16, 1, 114, 4, 1, 120, 122, 1, 121, 122, 1, 122, 122, 1, 119, 122, 4, 0, 5, 105, 118, 101, 99, 52, 3, 0, 18, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 0, 4, 113, 117, 97, 116, 3, 0, 20, 1, 114, 4, 1, 120, 7, 1, 121, 7, 1, 122, 7, 1, 119, 7, 4, 0, 4, 109, 97, 116, 52, 3, 0, 22, 1, 114, 2, 7, 115, 101, 99, 111, 110, 100, 115, 119, 11, 110, 97, 110, 111, 115, 101, 99, 111, 110, 100, 115, 121, 4, 0, 8, 100, 117, 114, 97, 116, 105, 111, 110, 3, 0, 24, 1, 114, 2, 6, 111, 114, 105, 103, 105, 110, 5, 3, 100, 105, 114, 5, 4, 0, 3, 114, 97, 121, 3, 0, 26, 1, 111, 2, 119, 119, 4, 0, 4, 117, 108, 105, 100, 3, 0, 28, 3, 1, 22, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 116, 121, 112, 101, 115, 5, 0, 1, 66, 5, 1, 113, 1, 11, 105, 110, 118, 97, 108, 105, 100, 45, 117, 114, 108, 1, 115, 0, 4, 0, 9, 117, 114, 108, 45, 101, 114, 114, 111, 114, 3, 0, 0, 1, 106, 1, 115, 1, 1, 1, 64, 1, 4, 112, 97, 116, 104, 115, 0, 2, 4, 0, 3, 117, 114, 108, 1, 3, 3, 1, 22, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 97, 115, 115, 101, 116, 5, 1, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 117, 108, 105, 100, 1, 66, 18, 2, 3, 2, 1, 2, 4, 0, 4, 118, 101, 99, 50, 3, 0, 0, 2, 3, 2, 1, 3, 4, 0, 4, 118, 101, 99, 51, 3, 0, 2, 2, 3, 2, 1, 4, 4, 0, 4, 117, 108, 105, 100, 3, 0, 4, 1, 114, 4, 8, 112, 111, 115, 105, 116, 105, 111, 110, 3, 6, 110, 111, 114, 109, 97, 108, 3, 7, 116, 97, 110, 103, 101, 110, 116, 3, 9, 116, 101, 120, 99, 111, 111, 114, 100, 48, 1, 4, 0, 6, 118, 101, 114, 116, 101, 120, 3, 0, 6, 1, 112, 7, 1, 112, 121, 1, 114, 2, 8, 118, 101, 114, 116, 105, 99, 101, 115, 8, 7, 105, 110, 100, 105, 99, 101, 115, 9, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 10, 1, 114, 1, 4, 117, 108, 105, 100, 5, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 12, 1, 64, 1, 4, 100, 101, 115, 99, 11, 0, 13, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 14, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 13, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 15, 3, 1, 28, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 109, 101, 115, 104, 5, 5, 1, 66, 13, 2, 3, 2, 1, 4, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 1, 113, 42, 8, 114, 56, 45, 117, 110, 111, 114, 109, 0, 0, 8, 114, 56, 45, 115, 110, 111, 114, 109, 0, 0, 7, 114, 56, 45, 117, 105, 110, 116, 0, 0, 7, 114, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 117, 105, 110, 116, 0, 0, 8, 114, 49, 54, 45, 115, 105, 110, 116, 0, 0, 9, 114, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 9, 114, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 56, 45, 117, 110, 111, 114, 109, 0, 0, 9, 114, 103, 56, 45, 115, 110, 111, 114, 109, 0, 0, 8, 114, 103, 56, 45, 117, 105, 110, 116, 0, 0, 8, 114, 103, 56, 45, 115, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 117, 105, 110, 116, 0, 0, 8, 114, 51, 50, 45, 115, 105, 110, 116, 0, 0, 9, 114, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 49, 54, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 49, 54, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 114, 103, 98, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 11, 114, 103, 98, 97, 56, 45, 115, 110, 111, 114, 109, 0, 0, 10, 114, 103, 98, 97, 56, 45, 117, 105, 110, 116, 0, 0, 10, 114, 103, 98, 97, 56, 45, 115, 105, 110, 116, 0, 0, 11, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 0, 0, 16, 98, 103, 114, 97, 56, 45, 117, 110, 111, 114, 109, 45, 115, 114, 103, 98, 0, 0, 13, 114, 103, 98, 57, 101, 53, 45, 117, 102, 108, 111, 97, 116, 0, 0, 13, 114, 103, 98, 49, 48, 97, 50, 45, 117, 110, 111, 114, 109, 0, 0, 13, 114, 103, 49, 49, 98, 49, 48, 45, 102, 108, 111, 97, 116, 0, 0, 9, 114, 103, 51, 50, 45, 117, 105, 110, 116, 0, 0, 9, 114, 103, 51, 50, 45, 115, 105, 110, 116, 0, 0, 10, 114, 103, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 49, 54, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 117, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 115, 110, 111, 114, 109, 0, 0, 12, 114, 103, 98, 97, 49, 54, 45, 102, 108, 111, 97, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 117, 105, 110, 116, 0, 0, 11, 114, 103, 98, 97, 51, 50, 45, 115, 105, 110, 116, 0, 0, 12, 114, 103, 98, 97, 51, 50, 45, 102, 108, 111, 97, 116, 0, 0, 4, 0, 6, 102, 111, 114, 109, 97, 116, 3, 0, 2, 1, 112, 125, 1, 114, 4, 5, 119, 105, 100, 116, 104, 121, 6, 104, 101, 105, 103, 104, 116, 121, 6, 102, 111, 114, 109, 97, 116, 3, 4, 100, 97, 116, 97, 4, 4, 0, 12, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 50, 100, 3, 0, 5, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 7, 1, 64, 1, 4, 100, 101, 115, 99, 6, 0, 8, 4, 0, 8, 99, 114, 101, 97, 116, 101, 50, 100, 1, 9, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 8, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 10, 3, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 116, 101, 120, 116, 117, 114, 101, 5, 6, 1, 66, 14, 2, 3, 2, 1, 4, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 1, 113, 3, 13, 99, 108, 97, 109, 112, 45, 116, 111, 45, 101, 100, 103, 101, 0, 0, 6, 114, 101, 112, 101, 97, 116, 0, 0, 13, 109, 105, 114, 114, 111, 114, 45, 114, 101, 112, 101, 97, 116, 0, 0, 4, 0, 12, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 3, 0, 2, 1, 113, 2, 7, 110, 101, 97, 114, 101, 115, 116, 0, 0, 6, 108, 105, 110, 101, 97, 114, 0, 0, 4, 0, 11, 102, 105, 108, 116, 101, 114, 45, 109, 111, 100, 101, 3, 0, 4, 1, 114, 6, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 117, 3, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 118, 3, 14, 97, 100, 100, 114, 101, 115, 115, 45, 109, 111, 100, 101, 45, 119, 3, 10, 109, 97, 103, 45, 102, 105, 108, 116, 101, 114, 5, 10, 109, 105, 110, 45, 102, 105, 108, 116, 101, 114, 5, 13, 109, 105, 112, 109, 97, 112, 45, 102, 105, 108, 116, 101, 114, 5, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 7, 0, 9, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 9, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 11, 3, 1, 31, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 115, 97, 109, 112, 108, 101, 114, 5, 7, 2, 3, 0, 3, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 4, 6, 104, 97, 110, 100, 108, 101, 1, 66, 14, 2, 3, 2, 1, 4, 4, 0, 4, 117, 108, 105, 100, 3, 0, 0, 2, 3, 2, 1, 8, 4, 0, 14, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 3, 0, 2, 2, 3, 2, 1, 9, 4, 0, 14, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 3, 0, 4, 1, 114, 5, 14, 98, 97, 115, 101, 45, 99, 111, 108, 111, 114, 45, 109, 97, 112, 3, 10, 110, 111, 114, 109, 97, 108, 45, 109, 97, 112, 3, 22, 109, 101, 116, 97, 108, 108, 105, 99, 45, 114, 111, 117, 103, 104, 110, 101, 115, 115, 45, 109, 97, 112, 3, 7, 115, 97, 109, 112, 108, 101, 114, 5, 11, 116, 114, 97, 110, 115, 112, 97, 114, 101, 110, 116, 127, 4, 0, 10, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 6, 1, 114, 1, 4, 117, 108, 105, 100, 1, 4, 0, 6, 104, 97, 110, 100, 108, 101, 3, 0, 8, 1, 64, 1, 4, 100, 101, 115, 99, 7, 0, 9, 4, 0, 6, 99, 114, 101, 97, 116, 101, 1, 10, 1, 64, 1, 6, 104, 97, 110, 100, 108, 101, 9, 1, 0, 4, 0, 7, 100, 101, 115, 116, 114, 111, 121, 1, 11, 3, 1, 32, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 108, 105, 101, 110, 116, 45, 109, 97, 116, 101, 114, 105, 97, 108, 5, 10, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 52, 2, 3, 0, 0, 5, 117, 118, 101, 99, 50, 2, 3, 0, 0, 5, 117, 118, 101, 99, 51, 2, 3, 0, 0, 5, 117, 118, 101, 99, 52, 2, 3, 0, 0, 5, 105, 118, 101, 99, 50, 2, 3, 0, 0, 5, 105, 118, 101, 99, 51, 2, 3, 0, 0, 5, 105, 118, 101, 99, 52, 2, 3, 0, 0, 8, 100, 117, 114, 97, 116, 105, 111, 110, 2, 3, 0, 2, 6, 104, 97, 110, 100, 108, 101, 2, 3, 0, 5, 6, 104, 97, 110, 100, 108, 101, 1, 66, 137, 1, 2, 3, 2, 1, 11, 4, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 3, 0, 0, 2, 3, 2, 1, 12, 4, 0, 4, 109, 97, 116, 52, 3, 0, 2, 2, 3, 2, 1, 13, 4, 0, 4, 113, 117, 97, 116, 3, 0, 4, 2, 3, 2, 1, 2, 4, 0, 4, 118, 101, 99, 50, 3, 0, 6, 2, 3, 2, 1, 3, 4, 0, 4, 118, 101, 99, 51, 3, 0, 8, 2, 3, 2, 1, 14, 4, 0, 4, 118, 101, 99, 52, 3, 0, 10, 2, 3, 2, 1, 15, 4, 0, 5, 117, 118, 101, 99, 50, 3, 0, 12, 2, 3, 2, 1, 16, 4, 0, 5, 117, 118, 101, 99, 51, 3, 0, 14, 2, 3, 2, 1, 17, 4, 0, 5, 117, 118, 101, 99, 52, 3, 0, 16, 2, 3, 2, 1, 18, 4, 0, 5, 105, 118, 101, 99, 50, 3, 0, 18, 2, 3, 2, 1, 19, 4, 0, 5, 105, 118, 101, 99, 51, 3, 0, 20, 2, 3, 2, 1, 20, 4, 0, 5, 105, 118, 101, 99, 52, 3, 0, 22, 2, 3, 2, 1, 21, 4, 0, 8, 100, 117, 114, 97, 116, 105, 111, 110, 3, 0, 24, 2, 3, 2, 1, 22, 4, 0, 22, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 3, 0, 26, 2, 3, 2, 1, 8, 4, 0, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 3, 0, 28, 2, 3, 2, 1, 9, 4, 0, 25, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 3, 0, 30, 2, 3, 2, 1, 23, 4, 0, 26, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 3, 0, 32, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 5, 1, 112, 115, 1, 112, 125, 1, 112, 123, 1, 112, 121, 1, 112, 119, 1, 112, 126, 1, 112, 124, 1, 112, 122, 1, 112, 120, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 112, 13, 1, 112, 15, 1, 112, 17, 1, 112, 19, 1, 112, 21, 1, 112, 23, 1, 112, 25, 1, 112, 27, 1, 112, 29, 1, 112, 31, 1, 112, 33, 1, 113, 29, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 34, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 35, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 36, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 37, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 38, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 39, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 40, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 41, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 42, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 43, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 44, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 45, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 46, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 47, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 48, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 49, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 50, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 51, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 52, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 53, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 54, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 55, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 56, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 57, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 58, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 59, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 60, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 61, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 62, 0, 4, 0, 9, 118, 101, 99, 45, 118, 97, 108, 117, 101, 3, 0, 63, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 5, 1, 107, 115, 1, 107, 125, 1, 107, 123, 1, 107, 121, 1, 107, 119, 1, 107, 126, 1, 107, 124, 1, 107, 122, 1, 107, 120, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 107, 13, 1, 107, 15, 1, 107, 17, 1, 107, 19, 1, 107, 21, 1, 107, 23, 1, 107, 25, 1, 107, 27, 1, 107, 29, 1, 107, 31, 1, 107, 33, 1, 113, 29, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 193, 0, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 194, 0, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 195, 0, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 196, 0, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 197, 0, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 198, 0, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 199, 0, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 200, 0, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 201, 0, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 202, 0, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 203, 0, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 204, 0, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 205, 0, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 206, 0, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 207, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 208, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 209, 0, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 210, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 211, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 212, 0, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 213, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 214, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 215, 0, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 216, 0, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 217, 0, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 218, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 219, 0, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 220, 0, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 221, 0, 0, 4, 0, 12, 111, 112, 116, 105, 111, 110, 45, 118, 97, 108, 117, 101, 3, 0, 94, 1, 113, 31, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 7, 116, 121, 112, 101, 45, 117, 56, 1, 125, 0, 8, 116, 121, 112, 101, 45, 117, 49, 54, 1, 123, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 7, 116, 121, 112, 101, 45, 105, 56, 1, 126, 0, 8, 116, 121, 112, 101, 45, 105, 49, 54, 1, 124, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 8, 116, 121, 112, 101, 45, 105, 54, 52, 1, 120, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 50, 1, 13, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 51, 1, 15, 0, 10, 116, 121, 112, 101, 45, 117, 118, 101, 99, 52, 1, 17, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 50, 1, 19, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 51, 1, 21, 0, 10, 116, 121, 112, 101, 45, 105, 118, 101, 99, 52, 1, 23, 0, 13, 116, 121, 112, 101, 45, 100, 117, 114, 97, 116, 105, 111, 110, 1, 25, 0, 27, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 101, 115, 104, 45, 104, 97, 110, 100, 108, 101, 1, 27, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 116, 101, 120, 116, 117, 114, 101, 45, 104, 97, 110, 100, 108, 101, 1, 29, 0, 30, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 115, 97, 109, 112, 108, 101, 114, 45, 104, 97, 110, 100, 108, 101, 1, 31, 0, 31, 116, 121, 112, 101, 45, 112, 114, 111, 99, 101, 100, 117, 114, 97, 108, 45, 109, 97, 116, 101, 114, 105, 97, 108, 45, 104, 97, 110, 100, 108, 101, 1, 33, 0, 8, 116, 121, 112, 101, 45, 118, 101, 99, 1, 192, 0, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 223, 0, 0, 4, 0, 5, 118, 97, 108, 117, 101, 3, 0, 96, 1, 111, 2, 121, 225, 0, 1, 112, 226, 0, 4, 0, 6, 101, 110, 116, 105, 116, 121, 3, 0, 99, 1, 114, 4, 10, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 43, 8, 105, 110, 99, 108, 117, 100, 101, 115, 43, 8, 101, 120, 99, 108, 117, 100, 101, 115, 43, 7, 99, 104, 97, 110, 103, 101, 100, 43, 4, 0, 11, 113, 117, 101, 114, 121, 45, 98, 117, 105, 108, 100, 3, 0, 101, 1, 109, 3, 5, 102, 114, 97, 109, 101, 5, 115, 112, 97, 119, 110, 7, 100, 101, 115, 112, 97, 119, 110, 4, 0, 11, 113, 117, 101, 114, 121, 45, 101, 118, 101, 110, 116, 3, 0, 103, 1, 64, 1, 2, 105, 100, 115, 0, 202, 0, 4, 0, 9, 103, 101, 116, 45, 105, 110, 100, 101, 120, 1, 105, 1, 64, 1, 5, 105, 110, 100, 101, 120, 121, 0, 199, 0, 4, 0, 6, 103, 101, 116, 45, 105, 100, 1, 106, 1, 107, 225, 0, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 235, 0, 4, 0, 13, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 108, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 43, 0, 228, 0, 4, 0, 14, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 109, 1, 64, 1, 6, 101, 110, 116, 105, 116, 121, 1, 0, 228, 0, 4, 0, 18, 103, 101, 116, 45, 97, 108, 108, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 110, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 5, 118, 97, 108, 117, 101, 225, 0, 1, 0, 4, 0, 13, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 111, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 4, 100, 97, 116, 97, 228, 0, 1, 0, 4, 0, 14, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 112, 4, 0, 13, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 111, 4, 0, 14, 115, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 112, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 127, 4, 0, 13, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 113, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 43, 0, 127, 4, 0, 14, 104, 97, 115, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 114, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 1, 0, 4, 0, 16, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 1, 115, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 7, 105, 110, 100, 105, 99, 101, 115, 43, 1, 0, 4, 0, 17, 114, 101, 109, 111, 118, 101, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 115, 1, 116, 1, 64, 2, 1, 113, 230, 0, 1, 116, 232, 0, 0, 119, 4, 0, 5, 113, 117, 101, 114, 121, 1, 117, 1, 112, 225, 0, 1, 111, 2, 1, 246, 0, 1, 112, 247, 0, 1, 64, 1, 1, 113, 119, 0, 248, 0, 4, 0, 10, 113, 117, 101, 114, 121, 45, 101, 118, 97, 108, 1, 121, 3, 1, 26, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 24, 4, 1, 25, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 98, 105, 110, 100, 105, 110, 103, 115, 4, 41, 0, 69, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 6, 48, 46, 49, 50, 46, 48, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 5, 48, 46, 57, 46, 48, 11, 26, 1, 1, 20, 97, 109, 98, 105, 101, 110, 116, 58, 98, 105, 110, 100, 105, 110, 103, 115, 47, 119, 105, 116, 3, 0, 0];
                      
                      #[inline(never)]
                      #[doc(hidden)]
                      #[cfg(target_arch = "wasm32")]
                      pub fn __link_section() {}
                      