`"const _PROJECT_MANIFEST : & 'static str = include_str ! (\"ambient.toml\") ; # [doc = r\" Auto-generated component definitions. These come from `ambient.toml` in the root of the project.\"] pub mod components { use ambient_api2 :: { once_cell :: sync :: Lazy , ecs :: { Component , __internal_get_component } } ; pub mod core { use ambient_api2 :: { once_cell :: sync :: Lazy , ecs :: { Component , __internal_get_component } } ; pub mod primitives { use ambient_api2 :: { once_cell :: sync :: Lazy , ecs :: { Component , __internal_get_component } } ; static SPHERE : Lazy < Component < () > > = Lazy :: new (|| __internal_get_component (\"my_project::core::primitives::sphere\")) ; # [doc = \"**Sphere**\"] pub fn sphere () -> Component < () > { * SPHERE } static SPHERE_RADIUS : Lazy < Component < f32 > > = Lazy :: new (|| __internal_get_component (\"my_project::core::primitives::sphere_radius\")) ; # [doc = \"**Sphere radius**\"] pub fn sphere_radius () -> Component < f32 > { * SPHERE_RADIUS } static SPHERE_SECTORS : Lazy < Component < u32 > > = Lazy :: new (|| __internal_get_component (\"my_project::core::primitives::sphere_sectors\")) ; # [doc = \"**Sphere sectors**\"] pub fn sphere_sectors () -> Component < u32 > { * SPHERE_SECTORS } static SPHERE_STACKS : Lazy < Component < u32 > > = Lazy :: new (|| __internal_get_component (\"my_project::core::primitives::sphere_stacks\")) ; # [doc = \"**Sphere stacks**\"] pub fn sphere_stacks () -> Component < u32 > { * SPHERE_STACKS } } pub mod rendering { use ambient_api2 :: { once_cell :: sync :: Lazy , ecs :: { Component , __internal_get_component } } ; static COLOR : Lazy < Component < ambient_api2 :: global :: Vec4 > > = Lazy :: new (|| __internal_get_component (\"my_project::core::rendering::color\")) ; # [doc = \"**Color**\"] pub fn color () -> Component < ambient_api2 :: global :: Vec4 > { * COLOR } } pub mod transform { use ambient_api2 :: { once_cell :: sync :: Lazy , ecs :: { Component , __internal_get_component } } ; static ROTATION : Lazy < Component < ambient_api2 :: global :: Quat > > = Lazy :: new (|| __internal_get_component (\"my_project::core::transform::rotation\")) ; # [doc = \"**Rotation**\"] pub fn rotation () -> Component < ambient_api2 :: global :: Quat > { * ROTATION } static SCALE : Lazy < Component < ambient_api2 :: global :: Vec3 > > = Lazy :: new (|| __internal_get_component (\"my_project::core::transform::scale\")) ; # [doc = \"**Scale**\"] pub fn scale () -> Component < ambient_api2 :: global :: Vec3 > { * SCALE } static SPHERICAL_BILLBOARD : Lazy < Component < () > > = Lazy :: new (|| __internal_get_component (\"my_project::core::transform::spherical_billboard\")) ; # [doc = \"**Spherical billboard**\"] pub fn spherical_billboard () -> Component < () > { * SPHERICAL_BILLBOARD } static TRANSLATION : Lazy < Component < ambient_api2 :: global :: Vec3 > > = Lazy :: new (|| __internal_get_component (\"my_project::core::transform::translation\")) ; # [doc = \"**Translation**\"] pub fn translation () -> Component < ambient_api2 :: global :: Vec3 > { * TRANSLATION } } } } # [doc = r\" Auto-generated concept definitions. Concepts are collections of components that describe some form of gameplay concept.\"] pub mod concepts { use super :: components ; use ambient_api2 :: prelude :: * ; # [allow (clippy :: approx_constant)] # [doc = \"Makes a Colored Sphere (A sphere with some color!)\"] pub fn make_my_project () -> Entity { Entity :: new () . with_merge (make_sphere ()) . with (components :: core :: rendering :: color () , Vec4 :: new (1f32 , 1f32 , 1f32 , 1f32)) } # [doc = \"Checks if the entity is a Colored Sphere (A sphere with some color!)\"] pub fn make_my_project (id : EntityId) -> bool { is_sphere (id) && entity :: has_components (id , & [& components :: core :: rendering :: color ()]) } # [allow (clippy :: approx_constant)] # [doc = \"Makes a Sphere (A primitive sphere.)\"] pub fn make_my_project () -> Entity { Entity :: new () . with_merge (make_transformable ()) . with (components :: core :: primitives :: sphere () , ()) . with (components :: core :: primitives :: sphere_radius () , 0.5f32) . with (components :: core :: primitives :: sphere_sectors () , 36u32) . with (components :: core :: primitives :: sphere_stacks () , 18u32) } # [doc = \"Checks if the entity is a Sphere (A primitive sphere.)\"] pub fn make_my_project (id : EntityId) -> bool { is_transformable (id) && entity :: has_components (id , & [& components :: core :: primitives :: sphere () , & components :: core :: primitives :: sphere_radius () , & components :: core :: primitives :: sphere_sectors () , & components :: core :: primitives :: sphere_stacks ()]) } # [allow (clippy :: approx_constant)] # [doc = \"Makes a Transformable (Can be translated, rotated and scaled.)\"] pub fn make_my_project () -> Entity { Entity :: new () . with (components :: core :: transform :: rotation () , Quat :: from_xyzw (0f32 , 0f32 , 0f32 , 1f32)) . with (components :: core :: transform :: scale () , Vec3 :: new (1f32 , 1f32 , 1f32)) . with (components :: core :: transform :: translation () , Vec3 :: new (0f32 , 0f32 , 0f32)) } # [doc = \"Checks if the entity is a Transformable (Can be translated, rotated and scaled.)\"] pub fn make_my_project (id : EntityId) -> bool { entity :: has_components (id , & [& components :: core :: transform :: rotation () , & components :: core :: transform :: scale () , & components :: core :: transform :: translation ()]) } }"`